{"mappings":"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","sources":["node_modules/tslib/tslib.es6.js","node_modules/rxjs/src/internal/util/isFunction.ts","node_modules/rxjs/src/internal/util/createErrorClass.ts","node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","node_modules/rxjs/src/internal/util/arrRemove.ts","node_modules/rxjs/src/internal/Subscription.ts","node_modules/rxjs/src/internal/config.ts","node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts","node_modules/rxjs/src/internal/util/reportUnhandledError.ts","node_modules/rxjs/src/internal/util/noop.ts","node_modules/rxjs/src/internal/NotificationFactories.ts","node_modules/rxjs/src/internal/util/errorContext.ts","node_modules/rxjs/src/internal/Subscriber.ts","node_modules/rxjs/src/internal/symbol/observable.ts","node_modules/rxjs/src/internal/util/identity.ts","node_modules/rxjs/src/internal/util/pipe.ts","node_modules/rxjs/src/internal/Observable.ts","node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","node_modules/rxjs/src/internal/Subject.ts","node_modules/rxjs/src/internal/AsyncSubject.ts","node_modules/rxjs/src/internal/BehaviorSubject.ts","node_modules/rxjs/src/internal/util/argsArgArrayOrObject.ts","node_modules/rxjs/src/internal/util/isArrayLike.ts","node_modules/rxjs/src/internal/util/isPromise.ts","node_modules/rxjs/src/internal/util/isInteropObservable.ts","node_modules/rxjs/src/internal/util/isAsyncIterable.ts","node_modules/rxjs/src/internal/util/throwUnobservableError.ts","node_modules/rxjs/src/internal/symbol/iterator.ts","node_modules/rxjs/src/internal/util/isIterable.ts","node_modules/rxjs/src/internal/util/isReadableStreamLike.ts","node_modules/rxjs/src/internal/observable/innerFrom.ts","node_modules/rxjs/src/internal/util/executeSchedule.ts","node_modules/rxjs/src/internal/util/lift.ts","node_modules/rxjs/src/internal/operators/OperatorSubscriber.ts","node_modules/rxjs/src/internal/operators/observeOn.ts","node_modules/rxjs/src/internal/operators/subscribeOn.ts","node_modules/rxjs/src/internal/scheduled/scheduleObservable.ts","node_modules/rxjs/src/internal/scheduled/schedulePromise.ts","node_modules/rxjs/src/internal/scheduled/scheduleArray.ts","node_modules/rxjs/src/internal/scheduled/scheduleIterable.ts","node_modules/rxjs/src/internal/scheduled/scheduleAsyncIterable.ts","node_modules/rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts","node_modules/rxjs/src/internal/scheduled/scheduled.ts","node_modules/rxjs/src/internal/observable/from.ts","node_modules/rxjs/src/internal/operators/map.ts","node_modules/rxjs/src/internal/util/mapOneOrManyArgs.ts","node_modules/rxjs/src/internal/util/isScheduler.ts","node_modules/rxjs/src/internal/util/args.ts","node_modules/rxjs/src/internal/util/createObject.ts","node_modules/rxjs/src/internal/observable/combineLatest.ts","node_modules/rxjs/src/internal/operators/mergeInternals.ts","node_modules/rxjs/src/internal/operators/mergeMap.ts","node_modules/rxjs/src/internal/operators/mergeAll.ts","node_modules/rxjs/src/internal/operators/concatAll.ts","node_modules/rxjs/src/internal/observable/concat.ts","node_modules/rxjs/src/internal/operators/concat.ts","node_modules/rxjs/src/internal/operators/concatWith.ts","node_modules/rxjs/src/internal/observable/defer.ts","node_modules/rxjs/src/internal/observable/empty.ts","node_modules/rxjs/src/internal/operators/filter.ts","node_modules/rxjs/src/internal/util/EmptyError.ts","node_modules/rxjs/src/internal/firstValueFrom.ts","node_modules/rxjs/src/internal/observable/fromEvent.ts","node_modules/rxjs/src/internal/scheduler/Action.ts","node_modules/rxjs/src/internal/scheduler/intervalProvider.ts","node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","node_modules/rxjs/src/internal/scheduler/dateTimestampProvider.ts","node_modules/rxjs/src/internal/Scheduler.ts","node_modules/rxjs/src/internal/scheduler/async.ts","node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","node_modules/rxjs/src/internal/util/isDate.ts","node_modules/rxjs/src/internal/observable/timer.ts","node_modules/rxjs/src/internal/lastValueFrom.ts","node_modules/rxjs/src/internal/observable/merge.ts","node_modules/rxjs/src/internal/observable/never.ts","node_modules/rxjs/src/internal/observable/of.ts","node_modules/rxjs/src/internal/ReplaySubject.ts","node_modules/rxjs/src/internal/operators/switchMap.ts","node_modules/rxjs/src/internal/observable/throwError.ts","node_modules/rxjs/src/internal/operators/timeout.ts","node_modules/rxjs/src/internal/operators/withLatestFrom.ts","node_modules/rxjs/src/internal/operators/auditTime.ts","node_modules/rxjs/src/internal/operators/audit.ts","node_modules/rxjs/src/internal/operators/catchError.ts","node_modules/rxjs/src/internal/util/argsOrArgArray.ts","projects/scion/toolkit/util/src/defined.util.ts","projects/scion/toolkit/util/src/arrays.util.ts","projects/scion/toolkit/util/src/objects.util.ts","projects/scion/toolkit/util/src/dictionaries.util.ts","projects/scion/toolkit/util/src/maps.util.ts","projects/scion/toolkit/util/src/observables.util.ts","node_modules/rxjs/src/internal/operators/combineLatest.ts","node_modules/rxjs/src/internal/operators/combineLatestWith.ts","node_modules/rxjs/src/internal/operators/distinctUntilChanged.ts","node_modules/rxjs/src/internal/operators/expand.ts","node_modules/rxjs/src/internal/operators/finalize.ts","node_modules/rxjs/src/internal/operators/take.ts","node_modules/rxjs/src/internal/operators/defaultIfEmpty.ts","node_modules/rxjs/src/internal/operators/throwIfEmpty.ts","node_modules/rxjs/src/internal/operators/first.ts","node_modules/rxjs/src/internal/operators/share.ts","node_modules/rxjs/src/internal/operators/startWith.ts","node_modules/rxjs/src/internal/operators/takeUntil.ts","node_modules/rxjs/src/internal/operators/takeWhile.ts","node_modules/rxjs/src/internal/operators/tap.ts","projects/scion/toolkit/bean-manager/src/bean-manager.ts","projects/scion/toolkit/uuid/src/uuid.util.ts","projects/scion/toolkit/operators/src/operators.ts","projects/scion/toolkit/observable/src/dimension.observable.ts","projects/scion/microfrontend-platform/src/lib/platform.model.ts","projects/scion/microfrontend-platform/src/lib/messaging.model.ts","projects/scion/microfrontend-platform/src/lib/messaging.model.ts","projects/scion/microfrontend-platform/src/lib/topics.util.ts","projects/scion/microfrontend-platform/src/lib/client/messaging/message-client.ts","projects/scion/microfrontend-platform/src/lib/topic-matcher.util.ts","projects/scion/microfrontend-platform/src/lib/operators.ts","projects/scion/microfrontend-platform/src/lib/logger.ts","projects/scion/microfrontend-platform/src/lib/platform-state.ts","projects/scion/microfrontend-platform/src/lib/client/messaging/broker-gateway.ts","projects/scion/microfrontend-platform/src/lib/microfrontend-platform-ref.ts","projects/scion/microfrontend-platform/src/lib/safe-runner.ts","projects/scion/microfrontend-platform/src/lib/error.util.ts","node_modules/rxjs/src/internal/observable/interval.ts","projects/scion/microfrontend-platform/src/lib/platform-property-service.ts","projects/scion/microfrontend-platform/src/lib/client/messaging/intent-client.ts","projects/scion/microfrontend-platform/src/lib/host/manifest-registry/manifest-registry.ts","projects/scion/microfrontend-platform/src/lib/url.util.ts","projects/scion/microfrontend-platform/src/lib/host/microfrontend-platform-config.ts","projects/scion/microfrontend-platform/src/lib/host/application-registry.ts","projects/scion/microfrontend-platform/src/lib/host/http-client.ts","projects/scion/microfrontend-platform/src/lib/host/progress-monitor/progress-monitor.ts","projects/scion/microfrontend-platform/src/lib/host/progress-monitor/progress-monitors.ts","projects/scion/microfrontend-platform/src/lib/host/host-manifest-interceptor.ts","projects/scion/microfrontend-platform/src/lib/host/manifest-collector.ts","projects/scion/microfrontend-platform/src/lib/host/client-registry/client.registry.ts","projects/scion/microfrontend-platform/src/lib/host/message-broker/message-subscription.registry.ts","projects/scion/microfrontend-platform/src/lib/host/message-broker/topic-subscription.registry.ts","projects/scion/microfrontend-platform/src/lib/host/message-broker/message-interception.ts","projects/scion/microfrontend-platform/src/lib/host/semver.ts","projects/scion/microfrontend-platform/src/lib/host/client-registry/client.constants.ts","projects/scion/microfrontend-platform/src/lib/qualifier-matcher.ts","projects/scion/microfrontend-platform/src/lib/host/message-broker/intent-subscription.registry.ts","projects/scion/microfrontend-platform/src/lib/host/client-registry/client.ts","node_modules/rxjs/src/internal/operators/debounceTime.ts","projects/scion/microfrontend-platform/src/lib/host/message-broker/predicates.util.ts","projects/scion/microfrontend-platform/src/lib/host/message-broker/message-broker.ts","projects/scion/microfrontend-platform/src/lib/client/context/context.model.ts","projects/scion/microfrontend-platform/src/lib/client/context/router-outlet-context-provider.ts","projects/scion/microfrontend-platform/src/lib/client/router-outlet/router-outlet-url-assigner.ts","projects/scion/microfrontend-platform/src/lib/client/keyboard-event/keystroke.ts","projects/scion/microfrontend-platform/src/lib/client/router-outlet/metadata.ts","projects/scion/microfrontend-platform/src/lib/client/router-outlet/router-outlet.element.ts","node_modules/rxjs/src/internal/operators/pairwise.ts","node_modules/rxjs/src/internal/operators/skipWhile.ts","projects/scion/microfrontend-platform/src/lib/client/context/context-service.ts","projects/scion/microfrontend-platform/src/lib/client/router-outlet/relative-path-resolver.ts","projects/scion/microfrontend-platform/src/lib/client/router-outlet/outlet-router.ts","projects/scion/microfrontend-platform/src/lib/client/focus/focus-monitor.ts","projects/scion/microfrontend-platform/src/lib/client/focus/focus-in-event-dispatcher.ts","projects/scion/microfrontend-platform/src/lib/host/focus/focus-tracker.ts","projects/scion/microfrontend-platform/src/lib/client/preferred-size/preferred-size-service.ts","projects/scion/microfrontend-platform/src/lib/client/mouse-event/mouse-move-event-dispatcher.ts","projects/scion/microfrontend-platform/src/lib/client/mouse-event/mouse-up-event-dispatcher.ts","projects/scion/microfrontend-platform/src/lib/client/keyboard-event/keyboard-event-dispatcher.ts","projects/scion/microfrontend-platform/src/lib/host/manifest-registry/manifest-object-store.ts","projects/scion/microfrontend-platform/src/lib/host/manifest-registry/capability-interceptors.ts","projects/scion/microfrontend-platform/src/lib/host/manifest-registry/manifest-registry.ts","projects/scion/microfrontend-platform/src/lib/client/manifest-registry/manifest-service.ts","projects/scion/microfrontend-platform/src/lib/host/activator/activator-installer.ts","projects/scion/microfrontend-platform/src/lib/client/messaging/message-handler.ts","projects/scion/microfrontend-platform/src/lib/client/messaging/intent-client.ts","projects/scion/microfrontend-platform/src/lib/client/messaging/message-client.ts","projects/scion/microfrontend-platform/src/lib/host/host-application-config-provider.ts","projects/scion/microfrontend-platform/src/lib/microfrontend-platform-stopper.ts","projects/scion/microfrontend-platform/src/lib/host/client-registry/client.registry.ts","projects/scion/microfrontend-platform/src/lib/host/router/microfrontend-intent-navigator.interceptor.ts","projects/scion/microfrontend-platform/src/lib/host/message-broker/param-matcher.ts","projects/scion/microfrontend-platform/src/lib/host/message-broker/intent-param-validator.interceptor.ts","projects/scion/microfrontend-platform/src/lib/microfrontend-platform.ts","src/refs.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n","/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n","import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n","/** Symbol.observable or a string \"@@observable\". Used for interop */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: Partial<Observer<T>>): Subscription;\n  subscribe(next: (value: T) => void): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');","import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n","import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n","import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n","/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n","import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n","import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n","import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n","/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n","import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n","import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n","import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param {ObservableInput<T>} A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param {SchedulerLike} An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return {Observable<T>}\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n","import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n","export function createObject(keys: string[], values: any[]) {\n  return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {} as any);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf, ObservableInputTuple } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { Subscriber } from '../Subscriber';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { Subscription } from '../Subscription';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { AnyCatcher } from '../AnyCatcher';\nimport { executeSchedule } from '../util/executeSchedule';\n\n// combineLatest(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function combineLatest<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// combineLatest([a, b, c])\nexport function combineLatest(sources: []): Observable<never>;\nexport function combineLatest<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R,\n  scheduler: SchedulerLike\n): Observable<R>;\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  sources: readonly [...ObservableInputTuple<A>],\n  scheduler: SchedulerLike\n): Observable<A>;\n\n// combineLatest(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelectorAndScheduler: [...ObservableInputTuple<A>, (...values: A) => R, SchedulerLike]\n): Observable<R>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): Observable<A>;\n\n// combineLatest({a, b, c})\nexport function combineLatest(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function combineLatest<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed in the\n * observables array. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to this operator,\n * the returned Observable will always emit an array of `n` values, in an order\n * corresponding to the order of the passed Observables (the value from the first Observable\n * will be at index 0 of the array and so on).\n *\n * Static version of `combineLatest` accepts an array of Observables. Note that an array of\n * Observables is a good choice, if you don't know beforehand how many Observables\n * you will combine. Passing an empty array will result in an Observable that\n * completes immediately.\n *\n * To ensure the output array always has the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all these values but the last\n * will be lost. On the other hand, if some Observable does not emit a value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will now be impossible to include a value from the\n * completed Observable in the resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, the resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, the result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of a completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * ## Examples\n *\n * Combine two timer Observables\n *\n * ```ts\n * import { timer, combineLatest } from 'rxjs';\n *\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest([firstTimer, secondTimer]);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * Combine a dictionary of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = {\n *   a: of(1).pipe(delay(1000), startWith(0)),\n *   b: of(5).pipe(delay(5000), startWith(0)),\n *   c: of(10).pipe(delay(10000), startWith(0))\n * };\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // { a: 0, b: 0, c: 0 } immediately\n * // { a: 1, b: 0, c: 0 } after 1s\n * // { a: 1, b: 5, c: 0 } after 5s\n * // { a: 1, b: 5, c: 10 } after 10s\n * ```\n *\n * Combine an array of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000), // emit 0 and then emit n after n seconds\n *     startWith(0)\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n * Use map operator to dynamically calculate the Body-Mass Index\n *\n * ```ts\n * import { of, combineLatest, map } from 'rxjs';\n *\n * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest([weight, height]).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} [observables] An array of input Observables to combine with each other.\n * An array of Observables must be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\nexport function combineLatest<O extends ObservableInput<any>, R>(...args: any[]): Observable<R> | Observable<ObservedValueOf<O>[]> {\n  const scheduler = popScheduler(args);\n  const resultSelector = popResultSelector(args);\n\n  const { args: observables, keys } = argsArgArrayOrObject(args);\n\n  if (observables.length === 0) {\n    // If no observables are passed, or someone has passed an empty array\n    // of observables, or even an empty object POJO, we need to just\n    // complete (EMPTY), but we have to honor the scheduler provided if any.\n    return from([], scheduler as any);\n  }\n\n  const result = new Observable<ObservedValueOf<O>[]>(\n    combineLatestInit(\n      observables as ObservableInput<ObservedValueOf<O>>[],\n      scheduler,\n      keys\n        ? // A handler for scrubbing the array of args into a dictionary.\n          (values) => createObject(keys, values)\n        : // A passthrough to just return the array\n          identity\n    )\n  );\n\n  return resultSelector ? (result.pipe(mapOneOrManyArgs(resultSelector)) as Observable<R>) : result;\n}\n\nexport function combineLatestInit(\n  observables: ObservableInput<any>[],\n  scheduler?: SchedulerLike,\n  valueTransform: (values: any[]) => any = identity\n) {\n  return (subscriber: Subscriber<any>) => {\n    // The outer subscription. We're capturing this in a function\n    // because we may have to schedule it.\n    maybeSchedule(\n      scheduler,\n      () => {\n        const { length } = observables;\n        // A store for the values each observable has emitted so far. We match observable to value on index.\n        const values = new Array(length);\n        // The number of currently active subscriptions, as they complete, we decrement this number to see if\n        // we are all done combining values, so we can complete the result.\n        let active = length;\n        // The number of inner sources that still haven't emitted the first value\n        // We need to track this because all sources need to emit one value in order\n        // to start emitting values.\n        let remainingFirstValues = length;\n        // The loop to kick off subscription. We're keying everything on index `i` to relate the observables passed\n        // in to the slot in the output array or the key in the array of keys in the output dictionary.\n        for (let i = 0; i < length; i++) {\n          maybeSchedule(\n            scheduler,\n            () => {\n              const source = from(observables[i], scheduler as any);\n              let hasFirstValue = false;\n              source.subscribe(\n                createOperatorSubscriber(\n                  subscriber,\n                  (value) => {\n                    // When we get a value, record it in our set of values.\n                    values[i] = value;\n                    if (!hasFirstValue) {\n                      // If this is our first value, record that.\n                      hasFirstValue = true;\n                      remainingFirstValues--;\n                    }\n                    if (!remainingFirstValues) {\n                      // We're not waiting for any more\n                      // first values, so we can emit!\n                      subscriber.next(valueTransform(values.slice()));\n                    }\n                  },\n                  () => {\n                    if (!--active) {\n                      // We only complete the result if we have no more active\n                      // inner observables.\n                      subscriber.complete();\n                    }\n                  }\n                )\n              );\n            },\n            subscriber\n          );\n        }\n      },\n      subscriber\n    );\n  };\n}\n\n/**\n * A small utility to handle the couple of locations where we want to schedule if a scheduler was provided,\n * but we don't if there was no scheduler.\n */\nfunction maybeSchedule(scheduler: SchedulerLike | undefined, execute: () => void, subscription: Subscription) {\n  if (scheduler) {\n    executeSchedule(subscription, scheduler, execute);\n  } else {\n    execute();\n  }\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n","import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Infinity] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n","import { mergeAll } from './mergeAll';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * ![](concatAll.svg)\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, map, interval, take, concatAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(4)))\n * );\n * const firstOrder = higherOrder.pipe(concatAll());\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaustAll}\n * @see {@link mergeAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable emitting values from all the\n * inner Observables concatenated.\n */\nexport function concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeAll(1);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple, SchedulerLike } from '../types';\nimport { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function concat<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function concat<T extends readonly unknown[]>(\n  ...inputsAndScheduler: [...ObservableInputTuple<T>, SchedulerLike]\n): Observable<T[number]>;\n\n/**\n * Creates an output Observable which sequentially emits all values from the first given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * ![](concat.png)\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * ## Examples\n *\n * Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\n *\n * ```ts\n * import { interval, take, range, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(4));\n * const sequence = range(1, 10);\n * const result = concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n * ```\n *\n * Concatenate 3 Observables\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const result = concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n * ```\n *\n * Concatenate the same Observable to repeat it\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(2));\n *\n * concat(timer, timer) // concatenating the same Observable!\n *   .subscribe({\n *     next: value => console.log(value),\n *     complete: () => console.log('...and it is done!')\n *   });\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // '...and it is done!' also after 4s\n * ```\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link startWith}\n * @see {@link endWith}\n *\n * @param args Input Observables to concatenate.\n */\nexport function concat(...args: any[]): Observable<unknown> {\n  return concatAll()(from(args, popScheduler(args)));\n}\n","import { ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { concatAll } from './concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * @deprecated Replaced with {@link concatWith}. Will be removed in v8.\n */\nexport function concat<T, R>(...args: any[]): OperatorFunction<T, R> {\n  const scheduler = popScheduler(args);\n  return operate((source, subscriber) => {\n    concatAll()(from([source, ...args], scheduler)).subscribe(subscriber);\n  });\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { concat } from './concat';\n\n/**\n * Emits all of the values from the source observable, then, once it completes, subscribes\n * to each observable source provided, one at a time, emitting all of their values, and not subscribing\n * to the next one until it completes.\n *\n * `concat(a$, b$, c$)` is the same as `a$.pipe(concatWith(b$, c$))`.\n *\n * ## Example\n *\n * Listen for one mouse click, then listen for all mouse moves.\n *\n * ```ts\n * import { fromEvent, map, take, concatWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click');\n * const moves$ = fromEvent(document, 'mousemove');\n *\n * clicks$.pipe(\n *   map(() => 'click'),\n *   take(1),\n *   concatWith(\n *     moves$.pipe(\n *       map(() => 'move')\n *     )\n *   )\n * )\n * .subscribe(x => console.log(x));\n *\n * // 'click'\n * // 'move'\n * // 'move'\n * // 'move'\n * // ...\n * ```\n *\n * @param otherSources Other observable sources to subscribe to, in sequence, after the original source is complete.\n * @return A function that returns an Observable that concatenates\n * subscriptions to the source and provided Observables subscribing to the next\n * only once the current subscription completes.\n */\nexport function concatWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return concat(...otherSources);\n}\n","import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInput } from '../types';\nimport { innerFrom } from './innerFrom';\n\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create an Observable only when the Observer\n * subscribes. It waits until an Observer subscribes to it, calls the given\n * factory function to get an Observable -- where a factory function typically\n * generates a new Observable -- and subscribes the Observer to this Observable.\n * In case the factory function returns a falsy value, then EMPTY is used as\n * Observable instead. Last but not least, an exception during the factory\n * function call is transferred to the Observer by calling `error`.\n *\n * ## Example\n *\n * Subscribe to either an Observable of clicks or an Observable of interval, at random\n *\n * ```ts\n * import { defer, fromEvent, interval } from 'rxjs';\n *\n * const clicksOrInterval = defer(() => {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param {function(): ObservableInput} observableFactory The Observable\n * factory function to invoke for each Observer that subscribes to the output\n * Observable. May also return a Promise, which will be converted on the fly\n * to an Observable.\n * @return {Observable} An Observable whose Observers' subscriptions trigger\n * an invocation of the given Observable factory function.\n */\nexport function defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\n  return new Observable<ObservedValueOf<R>>((subscriber) => {\n    innerFrom(observableFactory()).subscribe(subscriber);\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n *\n * Emit only click events whose target was a DIV element\n *\n * ```ts\n * import { fromEvent, filter } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param thisArg An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits items from the\n * source Observable that satisfy the specified `predicate`.\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // An index passed to our predicate function on each call.\n    let index = 0;\n\n    // Subscribe to the source, all errors and completions are\n    // forwarded to the consumer.\n    source.subscribe(\n      // Call the predicate with the appropriate `this` context,\n      // if the predicate returns `true`, then send the value\n      // to the consumer.\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\n    );\n  });\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass((_super) => function EmptyErrorImpl(this: any) {\n  _super(this);\n  this.name = 'EmptyError';\n  this.message = 'no elements in sequence';\n});\n","import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\n\nexport interface FirstValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * and returning a promise that will resolve as soon as the first value\n * arrives from the observable. The subscription will then be closed.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\n * *OR* complete. If the source observable does not emit one value or complete, you will\n * end up with a promise that is hung up, and potentially all of the state of an\n * async function hanging out in memory. To avoid this situation, look into adding\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\n * amongst others.\n *\n * ## Example\n *\n * Wait for the first value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, firstValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000);\n *   const firstNumber = await firstValueFrom(source$);\n *   console.log(`The first number is ${ firstNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The first number is 0'\n * ```\n *\n * @see {@link lastValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    const subscriber = new SafeSubscriber<T>({\n      next: (value) => {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: () => {\n        if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n    source.subscribe(subscriber);\n  });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter\n *                                                              // which will be passed to addEventListener\n * const clicksInDiv = fromEvent(someDivInDocument, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n * @param {string} eventName The event name of interest, being emitted by the\n * `target`.\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n * @return {Observable<T>}\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  // Figure out our add and remove methods. In order to do this,\n  // we are going to analyze the target in a preferred order, if\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\n  // method names and apply them to a map to create opposite versions of the\n  // same function. This is because they all operate in duplicate pairs,\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\n  // The call only differs by method name, as to whether or not you're adding or removing.\n  const [add, remove] =\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n    isEventTarget(target)\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\n      : // In all other cases, the call pattern is identical with the exception of the method names.\n      isNodeStyleEventEmitter(target)\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n      : isJQueryStyleEventEmitter(target)\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n      : [];\n\n  // If add is falsy, it's because we didn't match a pattern above.\n  // Check to see if it is an ArrayLike, because if it is, we want to\n  // try to apply fromEvent to all of it's items. We do this check last,\n  // because there are may be some types that are both ArrayLike *and* implement\n  // event registry points, and we'd rather delegate to that when possible.\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\n        innerFrom(target)\n      ) as Observable<T>;\n    }\n  }\n\n  // If add is falsy and we made it here, it's because we didn't\n  // match any valid target objects above.\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    // The handler we are going to register. Forwards the event object, by itself, or\n    // an array of arguments to the event handler, if there is more than one argument,\n    // to the consumer.\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    // Do the work of adding the handler to the target.\n    add(handler);\n    // When we finalize, we want to remove the handler and free up memory.\n    return () => remove!(handler);\n  });\n}\n\n/**\n * Used to create `add` and `remove` functions to register and unregister event handlers\n * from a target in the most common handler pattern, where there are only two arguments.\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\n * @param target The target we're calling methods on\n * @param eventName The event name for the event we're creating register or unregister functions for\n */\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n","import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","/**\n * Checks to see if a value is not only a `Date` object,\n * but a *valid* `Date` object that can be converted to a\n * number. For example, `new Date('blah')` is indeed an\n * `instanceof Date`, however it cannot be converted to a\n * number.\n */\nexport function isValidDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(value as any);\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\n\n/**\n * Creates an observable that will wait for a specified time period, or exact date, before\n * emitting the number 0.\n *\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\n *\n * This observable is useful for creating delays in code, or racing against other values\n * for ad-hoc timeouts.\n *\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Examples\n *\n * Wait 3 seconds and start another observable\n *\n * You might want to use `timer` to delay subscription to an\n * observable by a set amount of time. Here we use a timer with\n * {@link concatMapTo} or {@link concatMap} in order to wait\n * a few seconds and start a subscription to a source.\n *\n * ```ts\n * import { of, timer, concatMap } from 'rxjs';\n *\n * // This could be any observable\n * const source = of(1, 2, 3);\n *\n * timer(3000)\n *   .pipe(concatMap(() => source))\n *   .subscribe(console.log);\n * ```\n *\n * Take all values until the start of the next minute\n *\n * Using a `Date` as the trigger for the first emission, you can\n * do things like wait until midnight to fire an event, or in this case,\n * wait until a new minute starts (chosen so the example wouldn't take\n * too long to run) in order to stop watching a stream. Leveraging\n * {@link takeUntil}.\n *\n * ```ts\n * import { interval, takeUntil, timer } from 'rxjs';\n *\n * // Build a Date object that marks the\n * // next minute.\n * const currentDate = new Date();\n * const startOfNextMinute = new Date(\n *   currentDate.getFullYear(),\n *   currentDate.getMonth(),\n *   currentDate.getDate(),\n *   currentDate.getHours(),\n *   currentDate.getMinutes() + 1\n * );\n *\n * // This could be any observable stream\n * const source = interval(1000);\n *\n * const result = source.pipe(\n *   takeUntil(timer(startOfNextMinute))\n * );\n *\n * result.subscribe(console.log);\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `dueTime`.\n *\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\n * If a `Date`, the exact time at which to emit.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\n\n/**\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\n * on each interval after words.\n *\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Example\n *\n * ### Start an interval that starts right away\n *\n * Since {@link interval} waits for the passed delay before starting,\n * sometimes that's not ideal. You may want to start an interval immediately.\n * `timer` works well for this. Here we have both side-by-side so you can\n * see them in comparison.\n *\n * Note that this observable will never complete.\n *\n * ```ts\n * import { timer, interval } from 'rxjs';\n *\n * timer(0, 1000).subscribe(n => console.log('timer', n));\n * interval(1000).subscribe(n => console.log('interval', n));\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `startDue`.\n * @param startDue If a `number`, is the time to wait before starting the interval.\n * If a `Date`, is the exact time at which to start the interval.\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\n * negative number here will result in immediate completion after the first value is emitted, as though\n * no `intervalDuration` was passed at all.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\n\n/**\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\n */\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\n\nexport function timer(\n  dueTime: number | Date = 0,\n  intervalOrScheduler?: number | SchedulerLike,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  // Since negative intervalDuration is treated as though no\n  // interval was specified at all, we start with a negative number.\n  let intervalDuration = -1;\n\n  if (intervalOrScheduler != null) {\n    // If we have a second argument, and it's a scheduler,\n    // override the scheduler we had defaulted. Otherwise,\n    // it must be an interval.\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      // Note that this *could* be negative, in which case\n      // it's like not passing an intervalDuration at all.\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n\n  return new Observable((subscriber) => {\n    // If a valid date is passed, calculate how long to wait before\n    // executing the first value... otherwise, if it's a number just schedule\n    // that many milliseconds (or scheduler-specified unit size) in the future.\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\n\n    if (due < 0) {\n      // Ensure we don't schedule in the future.\n      due = 0;\n    }\n\n    // The incrementing value we emit.\n    let n = 0;\n\n    // Start the timer.\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        // Emit the next value and increment.\n        subscriber.next(n++);\n\n        if (0 <= intervalDuration) {\n          // If we have a interval after the initial timer,\n          // reschedule with the period.\n          this.schedule(undefined, intervalDuration);\n        } else {\n          // We didn't have an interval. So just complete.\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}\n","import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\n\nexport interface LastValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * waiting for it to complete, and resolving the returned promise with the\n * last value from the observed stream.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will complete. If the source\n * observable does not complete, you will end up with a promise that is hung up, and\n * potentially all of the state of an async function hanging out in memory. To avoid\n * this situation, look into adding something like {@link timeout}, {@link take},\n * {@link takeWhile}, or {@link takeUntil} amongst others.\n *\n * ## Example\n *\n * Wait for the last value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, take, lastValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000).pipe(take(10));\n *   const finalNumber = await lastValueFrom(source$);\n *   console.log(`The final number is ${ finalNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The final number is 9'\n * ```\n *\n * @see {@link firstValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    let _hasValue = false;\n    let _value: T;\n    source.subscribe({\n      next: (value) => {\n        _value = value;\n        _hasValue = true;\n      },\n      error: reject,\n      complete: () => {\n        if (_hasValue) {\n          resolve(_value);\n        } else if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n  });\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      innerFrom(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(from(sources, scheduler));\n}\n","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n","import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n","import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param bufferSize The size of the buffer to replay on subscription\n   * @param windowTime The amount of time the buffered items will say buffered\n   * @param timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n *\n * Generate new Observable according to source Observable values\n *\n * ```ts\n * import { of, switchMap } from 'rxjs';\n *\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // 3\n * // 9\n * // 27\n * ```\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMap, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * only the values from the most recently projected inner Observable.\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return operate((source, subscriber) => {\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\n    let index = 0;\n    // Whether or not the source subscription has completed\n    let isComplete = false;\n\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\n    // This is called both when the source completes and when the inners complete.\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Cancel the previous inner subscription if there was one\n          innerSubscriber?.unsubscribe();\n          let innerIndex = 0;\n          const outerIndex = index++;\n          // Start the next inner subscription\n          innerFrom(project(value, outerIndex)).subscribe(\n            (innerSubscriber = createOperatorSubscriber(\n              subscriber,\n              // When we get a new inner value, next it through. Note that this is\n              // handling the deprecate result selector here. This is because with this architecture\n              // it ends up being smaller than using the map operator.\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\n              () => {\n                // The inner has completed. Null out the inner subscriber to\n                // free up memory and to signal that we have no inner subscription\n                // currently.\n                innerSubscriber = null!;\n                checkComplete();\n              }\n            ))\n          );\n        },\n        () => {\n          isComplete = true;\n          checkComplete();\n        }\n      )\n    );\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n","import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { identity } from '../util/identity';\nimport { noop } from '../util/noop';\nimport { popResultSelector } from '../util/args';\n\nexport function withLatestFrom<T, O extends unknown[]>(...inputs: [...ObservableInputTuple<O>]): OperatorFunction<T, [T, ...O]>;\n\nexport function withLatestFrom<T, O extends unknown[], R>(\n  ...inputs: [...ObservableInputTuple<O>, (...value: [T, ...O]) => R]\n): OperatorFunction<T, R>;\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * ![](withLatestFrom.png)\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * ## Example\n *\n * On every click event, emit an array with the latest timer event plus the click event\n *\n * ```ts\n * import { fromEvent, interval, withLatestFrom } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const result = clicks.pipe(withLatestFrom(timer));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return A function that returns an Observable of projected values from the\n * most recent values from each input Observable, or an array of the most\n * recent values from each input Observable.\n */\nexport function withLatestFrom<T, R>(...inputs: any[]): OperatorFunction<T, R | any[]> {\n  const project = popResultSelector(inputs) as ((...args: any[]) => R) | undefined;\n\n  return operate((source, subscriber) => {\n    const len = inputs.length;\n    const otherValues = new Array(len);\n    // An array of whether or not the other sources have emitted. Matched with them by index.\n    // TODO: At somepoint, we should investigate the performance implications here, and look\n    // into using a `Set()` and checking the `size` to see if we're ready.\n    let hasValue = inputs.map(() => false);\n    // Flipped true when we have at least one value from all other sources and\n    // we are ready to start emitting values.\n    let ready = false;\n\n    // Other sources. Note that here we are not checking `subscriber.closed`,\n    // this causes all inputs to be subscribed to, even if nothing can be emitted\n    // from them. This is an important distinction because subscription constitutes\n    // a side-effect.\n    for (let i = 0; i < len; i++) {\n      innerFrom(inputs[i]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            otherValues[i] = value;\n            if (!ready && !hasValue[i]) {\n              // If we're not ready yet, flag to show this observable has emitted.\n              hasValue[i] = true;\n              // Intentionally terse code.\n              // If all of our other observables have emitted, set `ready` to `true`,\n              // so we know we can start emitting values, then clean up the `hasValue` array,\n              // because we don't need it anymore.\n              (ready = hasValue.every(identity)) && (hasValue = null!);\n            }\n          },\n          // Completing one of the other sources has\n          // no bearing on the completion of our result.\n          noop\n        )\n      );\n    }\n\n    // Source subscription\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        if (ready) {\n          // We have at least one value from the other sources. Go ahead and emit.\n          const values = [value, ...otherValues];\n          subscriber.next(project ? project(...values) : values);\n        }\n      })\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source value, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, auditTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function auditTime<T>(duration: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return audit(() => timer(duration, scheduler));\n}\n","import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\n\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.svg)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, audit, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function audit<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    let durationSubscriber: Subscriber<any> | null = null;\n    let isComplete = false;\n\n    const endDuration = () => {\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n      isComplete && subscriber.complete();\n    };\n\n    const cleanupDuration = () => {\n      durationSubscriber = null;\n      isComplete && subscriber.complete();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          lastValue = value;\n          if (!durationSubscriber) {\n            innerFrom(durationSelector(value)).subscribe(\n              (durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration))\n            );\n          }\n        },\n        () => {\n          isComplete = true;\n          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { Subscription } from '../Subscription';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\n\n/* tslint:disable:max-line-length */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <span class=\"informal\">\n * It only listens to the error channel and ignores notifications.\n * Handles errors from the source observable, and maps them to a new observable.\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\n * </span>\n *\n * ![](catch.png)\n *\n * This operator handles errors, but forwards along all other events to the resulting observable.\n * If the source observable terminates with an error, it will map that error to a new observable,\n * subscribe to it, and forward all of its events to the resulting observable.\n *\n * ## Examples\n *\n * Continue with a different Observable when there's an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\n *\n * ```ts\n * import { of, map, catchError, take } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30)\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throw a new error when the source Observable throws an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     })\n *   )\n *   .subscribe({\n *     next: x => console.log(x),\n *     error: err => console.log(err)\n *   });\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n * @see {@link onErrorResumeNext}\n * @see {@link repeat}\n * @see {@link repeatWhen}\n * @see {@link retry }\n * @see {@link retryWhen}\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n * is returned by the `selector` will be used to continue the observable chain.\n * @return A function that returns an Observable that originates from either\n * the source or the Observable returned by the `selector` function.\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null = null;\n    let syncUnsub = false;\n    let handledResult: Observable<ObservedValueOf<O>>;\n\n    innerSub = source.subscribe(\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\n        if (innerSub) {\n          innerSub.unsubscribe();\n          innerSub = null;\n          handledResult.subscribe(subscriber);\n        } else {\n          // We don't have an innerSub yet, that means the error was synchronous\n          // because the subscribe call hasn't returned yet.\n          syncUnsub = true;\n        }\n      })\n    );\n\n    if (syncUnsub) {\n      // We have a synchronous error, we need to make sure to\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\n      // at the right time, and that finalization occurs at the expected\n      // time between the source error and the subscription to the\n      // next observable.\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult!.subscribe(subscriber);\n    }\n  });\n}\n","const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\n/**\n * Provides utility methods to work with `undefined` values. The value `null` is considered as a defined value.\n *\n * Note: TypeScript 3.7 introduces the `nullish coalescing operator` [1] `(??)`, which is similar to the `Defined` function,\n * but also applies for `null` values.\n *\n * ## Links:\n * [1] https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing\n */\nexport namespace Defined {\n\n  /**\n   * Returns the value if not `undefined`, otherwise \"orElseValue\". The \"orElseValue\" value can be created with a factory function.\n   *\n   * Unlike JavaScript's \"nullish coalescing operator (??)\", the \"orElse\" function only tests for `undefined`, not `null`.\n   */\n  export function orElse<T>(value: T | undefined, orElseValue: T | (() => T)): T {\n    return (value !== undefined ? value : (typeof orElseValue === 'function' ? (orElseValue as (() => T))() : orElseValue));\n  }\n\n  /**\n   * Returns the value if not `undefined`, otherwise throws the error created by the passed factory function.\n   */\n  export function orElseThrow<T>(value: T | undefined, orElseThrowFn: () => Error): T {\n    if (value !== undefined) {\n      return value;\n    }\n    throw orElseThrowFn();\n  }\n}\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Defined} from './defined.util';\nimport {identity} from 'rxjs';\n\n/**\n * Provides array utility methods.\n */\nexport namespace Arrays {\n\n  /**\n   * Returns the value, if an array, or adds it to an array. If `null` or `undefined` is given, by default, returns an empty array.\n   */\n  export function coerce<T>(value: T | T[] | null | undefined, options?: {coerceNullOrUndefined: true} | {}): NonNullable<T[]>;\n  export function coerce<T>(value: T | T[] | null | undefined, options: {coerceNullOrUndefined: false}): T[] | null | undefined;\n  export function coerce<T>(value: T | T[] | null | undefined, options?: {coerceNullOrUndefined?: boolean}): T[] | null | undefined {\n    if (value === null || value === undefined) {\n      if (Defined.orElse(options && options.coerceNullOrUndefined, true)) {\n        return [];\n      }\n      return value as null | undefined;\n    }\n\n    return Array.isArray(value) ? value : [value];\n  }\n\n  /**\n   * Compares items of given arrays for reference equality.\n   *\n   * Use the parameter `exactOrder` to control if the item order must be equal (which is by default) or not.\n   */\n  export function isEqual(array1: any[] | null | undefined, array2: any[] | null | undefined, options?: {exactOrder?: boolean}): boolean {\n    if (array1 === array2) {\n      return true;\n    }\n    if (!array1 || !array2) {\n      return false;\n    }\n    if (array1.length !== array2.length) {\n      return false;\n    }\n\n    const exactOrder = Defined.orElse(options && options.exactOrder, true);\n    return array1.every((item, index) => {\n      if (exactOrder) {\n        return item === array2[index];\n      }\n      else {\n        return array2.includes(item);\n      }\n    });\n  }\n\n  /**\n   * Removes the specified element from an array, or the elements which satisfy the provided predicate function.\n   * The original array will be changed.\n   *\n   * @param  array - The array from which elements should be removed.\n   * @param  element - The element to be removed, or a predicate function to resolve elements which to be removed.\n   * @param  options - Control if to remove all occurrences of the element. If not specified, all occurrences are removed.\n   * @return the elements removed from the array.\n   */\n  export function remove<T>(array: T[], element: T | ((element: T) => boolean), options?: {firstOnly: boolean}): T[] {\n    const firstOnly = Defined.orElse(options && options.firstOnly, false);\n\n    // define a function to resolve the element's index in the original array\n    const indexOfElementFn = ((): () => number => {\n      if (typeof element === 'function') {\n        const predicate = element as (element: T) => boolean;\n        return (): number => array.findIndex(predicate);\n      }\n      else {\n        return (): number => array.indexOf(element);\n      }\n    })();\n\n    const removedElements = [];\n    for (let i = indexOfElementFn(); i !== -1; i = indexOfElementFn()) {\n      removedElements.push(...array.splice(i, 1)); // changes the original array\n      if (firstOnly) {\n        break;\n      }\n    }\n    return removedElements;\n  }\n\n  /**\n   * Removes duplicate items from the array. The original array will not be modified.\n   *\n   * Use the parameter `keySelector` to provide a function for comparing objects.\n   */\n  export function distinct<T>(items: T[], keySelector: (item: T) => any = identity): T[] {\n    const itemSet = new Set(items.map(keySelector));\n    return items.filter(item => itemSet.delete(keySelector(item)));\n  }\n\n  /**\n   * Intersects the given arrays, returning a new array containing all the elements contained in every array.\n   * Arrays which are `undefined` or `null` are ignored.\n   */\n  export function intersect<T>(...arrays: Array<T[] | undefined | null>): T[] {\n    const _arrays = arrays.filter(array => array !== undefined && array !== null) as Array<T[]>;\n\n    if (!_arrays.length) {\n      return [];\n    }\n\n    const first = _arrays.pop()!;\n    return _arrays.reduce((intersection, array) => intersection.filter(value => array.includes(value)), [...first]);\n  }\n\n  /**\n   * Returns the last element in the given array, optionally matching the predicate if given.\n   *\n   * Returns `undefined` if no element is found.\n   */\n  export function last<T>(array: T[] | null | undefined, predicate?: (item: T) => boolean): T | undefined {\n    if (!array) {\n      return undefined;\n    }\n\n    if (!predicate) {\n      return array[array.length - 1];\n    }\n\n    for (let i = array.length - 1; i >= 0; i--) {\n      if (predicate(array[i])) {\n        return array[i];\n      }\n    }\n\n    return undefined;\n  }\n}\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\nexport namespace Objects {\n\n  /**\n   * Compares the two objects for shallow equality.\n   */\n  export function isEqual(a: any, b: any): boolean {\n    if (a === b) {\n      return true;\n    }\n\n    if (!a || !b) {\n      return false;\n    }\n\n    if (Object.keys(a).length !== Object.keys(b).length) {\n      return false;\n    }\n\n    return Object.entries(a).every(([key, value]) => (b[key] === value));\n  }\n}\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Defined} from './defined.util';\n\n/**\n * Provides dictionary utility methods.\n */\nexport namespace Dictionaries {\n\n  /**\n   * Creates a {@link Dictionary} from the given dictionary-like object. If given a `Dictionary`, it is returned. If given `null` or `undefined`, by default, returns an empty {@link Dictionary}.\n   */\n  export function coerce<T = any>(dictionaryLike: Dictionary<T> | Map<string, T> | undefined | null, options?: {coerceNullOrUndefined: true} | {}): NonNullable<Dictionary<T>>;\n  export function coerce<T = any>(dictionaryLike: Dictionary<T> | Map<string, T> | undefined | null, options: {coerceNullOrUndefined: false}): Dictionary<T> | null | undefined;\n  export function coerce<T = any>(dictionaryLike: Dictionary<T> | Map<string, T> | undefined | null, options?: {coerceNullOrUndefined?: boolean}): Dictionary<T> | null | undefined {\n    if (dictionaryLike === null || dictionaryLike === undefined) {\n      if (Defined.orElse(options && options.coerceNullOrUndefined, true)) {\n        return {};\n      }\n      return dictionaryLike as null | undefined;\n    }\n\n    if (dictionaryLike instanceof Map) {\n      return createDictionaryFromMap(dictionaryLike);\n    }\n\n    // Data sent from one JavaScript realm to another is serialized with the structured clone algorithm.\n    // Although the algorithm supports the `Map` data type, a deserialized map object cannot be checked to be instance of `Map`.\n    // This is most likely because the serialization takes place in a different realm.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    // @see http://man.hubwiz.com/docset/JavaScript.docset/Contents/Resources/Documents/developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm.html\n    try {\n      const map = new Map(dictionaryLike as any);\n      return createDictionaryFromMap(map);\n    }\n    catch {\n      // noop\n    }\n\n    return dictionaryLike;\n  }\n\n  /**\n   * Returns a new {@link Dictionary} with `undefined` values removed.\n   */\n  export function withoutUndefinedEntries(object: Dictionary): Dictionary {\n    return Object.entries(object).reduce<Dictionary>((dictionary, [key, value]) => {\n      if (value !== undefined) {\n        dictionary[key] = value;\n      }\n      return dictionary;\n    }, {});\n  }\n}\n\n/**\n * Represents an object with a variable number of properties, whose keys are not known at development time.\n */\nexport interface Dictionary<T = any> {\n  [key: string]: T;\n}\n\nfunction createDictionaryFromMap(map: Map<any, any>): Dictionary {\n  return Array\n    .from(map.entries())\n    .reduce(\n      (dictionary: Dictionary, [key, value]: [string, any]): Dictionary => {\n        dictionary[key] = value;\n        return dictionary;\n      },\n      {},\n    );\n}\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Arrays} from './arrays.util';\nimport {Dictionary} from './dictionaries.util';\nimport {Defined} from './defined.util';\n\n/**\n * Provides utility methods for {@link Map}.\n */\nexport namespace Maps {\n\n  /**\n   * Creates a {@link Map} from the given map-like object. If given a `Map`, it is returned. If given `null` or `undefined`, by default, returns an empty {@link Map}.\n   */\n  export function coerce<T = any>(mapLike: Map<string, T> | Dictionary<T> | undefined | null, options?: {coerceNullOrUndefined: true} | {}): NonNullable<Map<string, T>>;\n  export function coerce<T = any>(mapLike: Map<string, T> | Dictionary<T> | undefined | null, options: {coerceNullOrUndefined: false}): Map<string, T> | null | undefined;\n  export function coerce<T = any>(mapLike: Map<string, T> | Dictionary<T> | undefined | null, options?: {coerceNullOrUndefined?: boolean}): Map<string, T> | null | undefined {\n    if (mapLike === null || mapLike === undefined) {\n      if (Defined.orElse(options && options.coerceNullOrUndefined, true)) {\n        return new Map<string, T>();\n      }\n      return mapLike as null | undefined;\n    }\n\n    if (mapLike instanceof Map) {\n      return mapLike;\n    }\n\n    // Data sent from one JavaScript realm to another is serialized with the structured clone algorithm.\n    // Although the algorithm supports the `Map` data type, a deserialized map object cannot be checked to be instance of `Map`.\n    // This is most likely because the serialization takes place in a different realm.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    // @see http://man.hubwiz.com/docset/JavaScript.docset/Contents/Resources/Documents/developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm.html\n    try {\n      return new Map(mapLike as any);\n    }\n    catch {\n      // noop\n    }\n\n    return Object\n      .entries(mapLike)\n      .reduce(\n        (map: Map<string, any>, [key, value]: [string, any]) => map.set(key, value),\n        new Map<string, any>(),\n      );\n  }\n\n  /**\n   * Adds the given value into a {@link Set} in the multi value {@link Map}.\n   */\n  export function addSetValue<K, V>(multiValueMap: Map<K, Set<V>>, key: K, value: V): Map<K, Set<V>> {\n    const values = multiValueMap.get(key) || new Set<V>();\n    return multiValueMap.set(key, values.add(value));\n  }\n\n  /**\n   * Removes the given value or values matching the given predicate from the multi {@link Map}.\n   *\n   * @return `true` if the element was removed, or `false` otherwise.\n   */\n  export function removeSetValue<K, V>(multiValueMap: Map<K, Set<V>>, key: K, value: V | PredicateFn<V>): boolean {\n    const values = multiValueMap.get(key) || new Set<V>();\n\n    let hasRemoved;\n    if (typeof value === 'function') {\n      const predicateFn = value as PredicateFn<V>;\n      hasRemoved = Array.from(values)\n        .filter(predicateFn)\n        .reduce<boolean>((removed, it) => values.delete(it) || removed, false);\n    }\n    else {\n      hasRemoved = values.delete(value);\n    }\n\n    if (hasRemoved && !values.size) {\n      multiValueMap.delete(key);\n    }\n    return hasRemoved;\n  }\n\n  /**\n   * Adds the given value into an {@link Array} in the multi value {@link Map}.\n   */\n  export function addListValue<K, V>(map: Map<K, V[]>, key: K, value: V): Map<K, V[]> {\n    const values = map.get(key) || [];\n    return map.set(key, values.concat(value));\n  }\n\n  /**\n   * Removes the given value or values matching the given predicate from the multi {@link Map}.\n   *\n   * @return `true` if the element was removed, or `false` otherwise.\n   */\n  export function removeListValue<K, V>(multiValueMap: Map<K, V[]>, key: K, value: V | PredicateFn<V>): boolean {\n    const values = multiValueMap.get(key) || [];\n    const hasRemoved = Arrays.remove(values, value, {firstOnly: false}).length > 0;\n    if (hasRemoved && !values.length) {\n      multiValueMap.delete(key);\n    }\n    return hasRemoved;\n  }\n}\n\n/**\n * Represents a predicate function which returns `true` or `false`.\n */\nexport type PredicateFn<T> = (value: T) => boolean;\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\nimport {from, Observable, of} from 'rxjs';\n\nexport namespace Observables {\n\n  /**\n   * Creates an `Observable` from the passed value, which will emit the value and then complete,\n   * or, if passing an `Observable`, returns it unchanged. If passing a `Promise`, it is converted\n   * to an `Observable`.\n   */\n  export function coerce<T>(value: T | Observable<T> | Promise<T>): Observable<T> {\n    if (value instanceof Observable) {\n      return value;\n    }\n    if (value instanceof Promise) {\n      return from(value);\n    }\n    return of(value);\n  }\n}\n","import { combineLatestInit } from '../observable/combineLatest';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { popResultSelector } from '../util/args';\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  project: (...values: [T, ...A]) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  ...sourcesAndProject: [...ObservableInputTuple<A>, (...values: [T, ...A]) => R]\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/**\n * @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8.\n */\nexport function combineLatest<T, R>(...args: (ObservableInput<any> | ((...values: any[]) => R))[]): OperatorFunction<T, unknown> {\n  const resultSelector = popResultSelector(args);\n  return resultSelector\n    ? pipe(combineLatest(...(args as Array<ObservableInput<any>>)), mapOneOrManyArgs(resultSelector))\n    : operate((source, subscriber) => {\n        combineLatestInit([source, ...argsOrArgArray(args)])(subscriber);\n      });\n}\n","import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { combineLatest } from './combineLatest';\n\n/**\n * Create an observable that combines the latest values from all passed observables and the source\n * into arrays and emits them.\n *\n * Returns an observable, that when subscribed to, will subscribe to the source observable and all\n * sources provided as arguments. Once all sources emit at least one value, all of the latest values\n * will be emitted as an array. After that, every time any source emits a value, all of the latest values\n * will be emitted as an array.\n *\n * This is a useful operator for eagerly calculating values based off of changed inputs.\n *\n * ## Example\n *\n * Simple concatenation of values from two inputs\n *\n * ```ts\n * import { fromEvent, combineLatestWith, map } from 'rxjs';\n *\n * // Setup: Add two inputs to the page\n * const input1 = document.createElement('input');\n * document.body.appendChild(input1);\n * const input2 = document.createElement('input');\n * document.body.appendChild(input2);\n *\n * // Get streams of changes\n * const input1Changes$ = fromEvent(input1, 'change');\n * const input2Changes$ = fromEvent(input2, 'change');\n *\n * // Combine the changes by adding them together\n * input1Changes$.pipe(\n *   combineLatestWith(input2Changes$),\n *   map(([e1, e2]) => (<HTMLInputElement>e1.target).value + ' - ' + (<HTMLInputElement>e2.target).value)\n * )\n * .subscribe(x => console.log(x));\n * ```\n *\n * @param otherSources the other sources to subscribe to.\n * @return A function that returns an Observable that emits the latest\n * emissions from both source and provided Observables.\n */\nexport function combineLatestWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, Cons<T, A>> {\n  return combineLatest(...otherSources);\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(\n  comparator: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a result {@link Observable} that emits all values pushed by the source observable if they\n * are distinct in comparison to the last value the result observable emitted.\n *\n * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),\n * it behaves like this:\n *\n * 1. It will always emit the first value from the source.\n * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values\n *    using the provided `comparator` or an `===` equality check.\n * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and\n *    becomes the new \"previously emitted value\" internally.\n *\n * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior\n * changes:\n *\n * 1. It will always emit the first value from the source.\n * 2. The `keySelector` will be run against all values, including the first value.\n * 3. For all values after the first, the selected key will be compared against the key selected from\n *    the previously emitted value using the `comparator`.\n * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted\n *    and the selected key from that value is saved for future comparisons against other keys.\n *\n * ## Examples\n *\n * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,\n * because it's distinct in comparison to the _previously emitted_ value,\n * not in comparison to _all other emitted values_.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)\n *   .pipe(distinctUntilChanged())\n *   .subscribe(console.log);\n * // Logs: 1, 2, 1, 3\n * ```\n *\n * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say\n * you only want to emit a value when all of its components have\n * changed:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const totallyDifferentBuilds$ = of(\n *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },\n *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },\n *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ).pipe(\n *   distinctUntilChanged((prev, curr) => {\n *     return (\n *       prev.engineVersion === curr.engineVersion ||\n *       prev.transmissionVersion === curr.transmissionVersion\n *     );\n *   })\n * );\n *\n * totallyDifferentBuilds$.subscribe(console.log);\n *\n * // Logs:\n * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }\n * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }\n * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ```\n *\n * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted\n * changes are only in one direction. Let's say you only want to get\n * the next record temperature:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);\n *\n * const recordHighs$ = temps$.pipe(\n *   distinctUntilChanged((prevHigh, temp) => {\n *     // If the current temp is less than\n *     // or the same as the previous record,\n *     // the record hasn't changed.\n *     return temp <= prevHigh;\n *   })\n * );\n *\n * recordHighs$.subscribe(console.log);\n * // Logs: 30, 31, 34, 35\n * ```\n *\n * Selecting update events only when the `updatedBy` field shows\n * the account changed hands.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * // A stream of updates to a given account\n * const accountUpdates$ = of(\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'blesh', data: [] }\n * );\n *\n * // We only want the events where it changed hands\n * const changedHands$ = accountUpdates$.pipe(\n *   distinctUntilChanged(undefined, update => update.updatedBy)\n * );\n *\n * changedHands$.subscribe(console.log);\n * // Logs:\n * // { updatedBy: 'blesh', data: Array[0] }\n * // { updatedBy: 'ncjamieson', data: Array[0] }\n * // { updatedBy: 'blesh', data: Array[0] }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param comparator A function used to compare the previous and current keys for\n * equality. Defaults to a `===` check.\n * @param keySelector Used to select a key value to be passed to the `comparator`.\n *\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinctUntilChanged<T, K>(\n  comparator?: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K = identity as (value: T) => K\n): MonoTypeOperatorFunction<T> {\n  // We've been allowing `null` do be passed as the `compare`, so we can't do\n  // a default value for the parameter, because that will only work\n  // for `undefined`.\n  comparator = comparator ?? defaultCompare;\n\n  return operate((source, subscriber) => {\n    // The previous key, used to compare against keys selected\n    // from new arrivals to determine \"distinctiveness\".\n    let previousKey: K;\n    // Whether or not this is the first value we've gotten.\n    let first = true;\n\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        // We always call the key selector.\n        const currentKey = keySelector(value);\n\n        // If it's the first value, we always emit it.\n        // Otherwise, we compare this key to the previous key, and\n        // if the comparer returns false, we emit.\n        if (first || !comparator!(previousKey, currentKey)) {\n          // Update our state *before* we emit the value\n          // as emission can be the source of re-entrant code\n          // in functional libraries like this. We only really\n          // need to do this if it's the first value, or if the\n          // key we're tracking in previous needs to change.\n          first = false;\n          previousKey = currentKey;\n\n          // Emit the value!\n          subscriber.next(value);\n        }\n      })\n    );\n  });\n}\n\nfunction defaultCompare(a: any, b: any) {\n  return a === b;\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/* tslint:disable:max-line-length */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. If you need to schedule the inner subscription,\n * use `subscribeOn` within the projection function: `expand((value) => fn(value).pipe(subscribeOn(scheduler)))`.\n * Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent: number | undefined,\n  scheduler: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * ![](expand.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * ## Example\n *\n * Start emitting the powers of two on every click, at most 10 of them\n *\n * ```ts\n * import { fromEvent, map, expand, of, delay, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const powersOfTwo = clicks.pipe(\n *   map(() => 1),\n *   expand(x => of(2 * x).pipe(delay(1000))),\n *   take(10)\n * );\n * powersOfTwo.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each projected inner Observable.\n * @return A function that returns an Observable that emits the source values\n * and also result of applying the projection function to each value emitted on\n * the output Observable and merging the results of the Observables obtained\n * from this transformation.\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent = Infinity,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>> {\n  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;\n  return operate((source, subscriber) =>\n    mergeInternals(\n      // General merge params\n      source,\n      subscriber,\n      project,\n      concurrent,\n\n      // onBeforeNext\n      undefined,\n\n      // Expand-specific\n      true, // Use expand path\n      scheduler // Inner subscription scheduler\n    )\n  );\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * The specified function will also be called when the subscriber explicitly unsubscribes.\n *\n * ## Examples\n *\n * Execute callback function when the observable completes\n *\n * ```ts\n * import { interval, take, finalize } from 'rxjs';\n *\n * // emit value in sequence every 1 second\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(5), //take only the first 5 values\n *   finalize(() => console.log('Sequence complete')) // Execute when the observable completes\n * );\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 'Sequence complete'\n * ```\n *\n * Execute callback function when the subscriber explicitly unsubscribes\n *\n * ```ts\n * import { interval, finalize, tap, noop, timer } from 'rxjs';\n *\n * const source = interval(100).pipe(\n *   finalize(() => console.log('[finalize] Called')),\n *   tap({\n *     next: () => console.log('[next] Called'),\n *     error: () => console.log('[error] Not called'),\n *     complete: () => console.log('[tap complete] Not called')\n *   })\n * );\n *\n * const sub = source.subscribe({\n *   next: x => console.log(x),\n *   error: noop,\n *   complete: () => console.log('[complete] Not called')\n * });\n *\n * timer(150).subscribe(() => sub.unsubscribe());\n *\n * // results:\n * // '[next] Called'\n * // 0\n * // '[finalize] Called'\n * ```\n *\n * @param {function} callback Function to be called when source terminates.\n * @return A function that returns an Observable that mirrors the source, but\n * will call the specified function on termination.\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // TODO: This try/finally was only added for `useDeprecatedSynchronousErrorHandling`.\n    // REMOVE THIS WHEN THAT HOT GARBAGE IS REMOVED IN V8.\n    try {\n      source.subscribe(subscriber);\n    } finally {\n      subscriber.add(callback);\n    }\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n *\n * Take the first 5 seconds of an infinite 1-second interval Observable\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of `next` values to emit.\n * @return A function that returns an Observable that emits only the first\n * `count` values emitted by the source Observable, or all of the values from\n * the source if the source emits fewer than `count` values.\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? // If we are taking no values, that's empty.\n      () => EMPTY\n    : operate((source, subscriber) => {\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Increment the number of values we have seen,\n            // then check it against the allowed count to see\n            // if we are still letting values through.\n            if (++seen <= count) {\n              subscriber.next(value);\n              // If we have met or passed our allowed count,\n              // we need to complete. We have to do <= here,\n              // because re-entrant code will increment `seen` twice.\n              if (count <= seen) {\n                subscriber.complete();\n              }\n            }\n          })\n        );\n      });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n *\n * If no clicks happen in 5 seconds, then emit 'no clicks'\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, defaultIfEmpty } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param defaultValue The default value used if the source\n * Observable is empty.\n * @return A function that returns an Observable that emits either the\n * specified `defaultValue` if the source Observable emits no items, or the\n * values emitted by the source Observable.\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => {\n          if (!hasValue) {\n            subscriber.next(defaultValue!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n *\n * Throw an error if the document wasn't clicked within 1 second\n *\n * ```ts\n * import { fromEvent, takeUntil, timer, throwIfEmpty } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(() => new Error('The document was not clicked within 1 second'))\n * )\n * .subscribe({\n *   next() {\n *    console.log('The document was clicked');\n *   },\n *   error(err) {\n *     console.error(err.message);\n *   }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n * @return A function that returns an Observable that throws an error if the\n * source Observable completed without emitting.\n */\nexport function throwIfEmpty<T>(errorFactory: () => any = defaultErrorFactory): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))\n      )\n    );\n  });\n}\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function first<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function first<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function first<T, S extends T, D>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue: D\n): OperatorFunction<T, S | D>;\nexport function first<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. Throws an error if\n * `defaultValue` was not provided and a matching element is not found.\n *\n * ## Examples\n *\n * Emit only the first click that happens on the DOM\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * This is how `first()` is different from {@link take}(1) which completes instead.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {D} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function first<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubjectLike } from '../types';\nimport { operate } from '../util/lift';\n\nexport interface ShareConfig<T> {\n  /**\n   * The factory used to create the subject that will connect the source observable to\n   * multicast consumers.\n   */\n  connector?: () => SubjectLike<T>;\n  /**\n   * If true, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"retried\" in the event of an error.\n   * If false, when an error comes from the source it will push the error into the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\n   * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnError?: boolean | ((error: any) => Observable<any>);\n  /**\n   * If true, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"repeated\" after it is done.\n   * If false, when the source completes, it will push the completion through the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\n   * or resubscriptions will resubscribe to that same subject.\n   * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnComplete?: boolean | (() => Observable<any>);\n  /**\n   * If true, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\n   * again.\n   * If false, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\n   * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnRefCountZero?: boolean | (() => Observable<any>);\n}\n\nexport function share<T>(): MonoTypeOperatorFunction<T>;\n\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\n *\n * ![](share.png)\n *\n * ## Example\n *\n * Generate new multicast Observable from the `source` Observable value\n *\n * ```ts\n * import { interval, tap, map, take, share } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   tap(x => console.log('Processing: ', x)),\n *   map(x => x * x),\n *   take(6),\n *   share()\n * );\n *\n * source.subscribe(x => console.log('subscription 1: ', x));\n * source.subscribe(x => console.log('subscription 2: ', x));\n *\n * // Logs:\n * // Processing: 0\n * // subscription 1: 0\n * // subscription 2: 0\n * // Processing: 1\n * // subscription 1: 1\n * // subscription 2: 1\n * // Processing: 2\n * // subscription 1: 4\n * // subscription 2: 4\n * // Processing: 3\n * // subscription 1: 9\n * // subscription 2: 9\n * // Processing: 4\n * // subscription 1: 16\n * // subscription 2: 16\n * // Processing: 5\n * // subscription 1: 25\n * // subscription 2: 25\n * ```\n *\n * ## Example with notifier factory: Delayed reset\n *\n * ```ts\n * import { interval, take, share, timer } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   take(3),\n *   share({\n *     resetOnRefCountZero: () => timer(1000)\n *   })\n * );\n *\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\n *\n * // Logs:\n * // subscription 1:  0\n * // (subscription 1 unsubscribes here)\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\n * // subscription 2:  1\n * // subscription 2:  2\n * // (subscription 2 unsubscribes here)\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\n * // subscription 3:  0\n * // subscription 3:  1\n * // subscription 3:  2\n * ```\n *\n * @see {@link shareReplay}\n *\n * @return A function that returns an Observable that mirrors the source.\n */\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n  // It's necessary to use a wrapper here, as the _operator_ must be\n  // referentially transparent. Otherwise, it cannot be used in calls to the\n  // static `pipe` function - to create a partial pipeline.\n  //\n  // The _operator function_ - the function returned by the _operator_ - will\n  // not be referentially transparent - as it shares its source - but the\n  // _operator function_ is called when the complete pipeline is composed via a\n  // call to a source observable's `pipe` method - not when the static `pipe`\n  // function is called.\n  return (wrapperSource) => {\n    let connection: SafeSubscriber<T> | undefined;\n    let resetConnection: Subscription | undefined;\n    let subject: SubjectLike<T> | undefined;\n    let refCount = 0;\n    let hasCompleted = false;\n    let hasErrored = false;\n\n    const cancelReset = () => {\n      resetConnection?.unsubscribe();\n      resetConnection = undefined;\n    };\n    // Used to reset the internal state to a \"cold\"\n    // state, as though it had never been subscribed to.\n    const reset = () => {\n      cancelReset();\n      connection = subject = undefined;\n      hasCompleted = hasErrored = false;\n    };\n    const resetAndUnsubscribe = () => {\n      // We need to capture the connection before\n      // we reset (if we need to reset).\n      const conn = connection;\n      reset();\n      conn?.unsubscribe();\n    };\n\n    return operate<T, T>((source, subscriber) => {\n      refCount++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n\n      // Create the subject if we don't have one yet. Grab a local reference to\n      // it as well, which avoids non-null assertions when using it and, if we\n      // connect to it now, then error/complete need a reference after it was\n      // reset.\n      const dest = (subject = subject ?? connector());\n\n      // Add the finalization directly to the subscriber - instead of returning it -\n      // so that the handling of the subscriber's unsubscription will be wired\n      // up _before_ the subscription to the source occurs. This is done so that\n      // the assignment to the source connection's `closed` property will be seen\n      // by synchronous firehose sources.\n      subscriber.add(() => {\n        refCount--;\n\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\n        // configuration.\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n\n      // The following line adds the subscription to the subscriber passed.\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\n      dest.subscribe(subscriber);\n\n      if (\n        !connection &&\n        // Check this shareReplay is still activate - it can be reset to 0\n        // and be \"unsubscribed\" _before_ it actually subscribes.\n        // If we were to subscribe then, it'd leak and get stuck.\n        refCount > 0\n      ) {\n        // We need to create a subscriber here - rather than pass an observer and\n        // assign the returned subscription to connection - because it's possible\n        // for reentrant subscriptions to the shared observable to occur and in\n        // those situations we want connection to be already-assigned so that we\n        // don't create another connection to the source.\n        connection = new SafeSubscriber({\n          next: (value) => dest.next(value),\n          error: (err) => {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: () => {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          },\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\n\nfunction handleReset<T extends unknown[] = never[]>(\n  reset: () => void,\n  on: boolean | ((...args: T) => Observable<any>),\n  ...args: T\n): Subscription | undefined {\n  if (on === true) {\n    reset();\n    return;\n  }\n\n  if (on === false) {\n    return;\n  }\n\n  const onSubscriber = new SafeSubscriber({\n    next: () => {\n      onSubscriber.unsubscribe();\n      reset();\n    },\n  });\n\n  return on(...args).subscribe(onSubscriber);\n}\n","import { concat } from '../observable/concat';\nimport { OperatorFunction, SchedulerLike, ValueFromArray } from '../types';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function startWith<T>(value: null): OperatorFunction<T, T | null>;\nexport function startWith<T>(value: undefined): OperatorFunction<T, T | undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function startWith<T, A extends readonly unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\nexport function startWith<T, A extends readonly unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that, at the moment of subscription, will synchronously emit all\n * values provided to this operator, then subscribe to the source and mirror all of its emissions\n * to subscribers.\n *\n * This is a useful way to know when subscription has occurred on an existing observable.\n *\n * <span class=\"informal\">First emits its arguments in order, and then any\n * emissions from the source.</span>\n *\n * ![](startWith.png)\n *\n * ## Examples\n *\n * Emit a value when a timer starts.\n *\n * ```ts\n * import { timer, map, startWith } from 'rxjs';\n *\n * timer(1000)\n *   .pipe(\n *     map(() => 'timer emit'),\n *     startWith('timer start')\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // results:\n * // 'timer start'\n * // 'timer emit'\n * ```\n *\n * @param values Items you want the modified Observable to emit first.\n * @return A function that returns an Observable that synchronously emits\n * provided values before subscribing to the source Observable.\n *\n * @see {@link endWith}\n * @see {@link finalize}\n * @see {@link concat}\n */\nexport function startWith<T, D>(...values: D[]): OperatorFunction<T, T | D> {\n  const scheduler = popScheduler(values);\n  return operate((source, subscriber) => {\n    // Here we can't pass `undefined` as a scheduler, because if we did, the\n    // code inside of `concat` would be confused by the `undefined`, and treat it\n    // like an invalid observable. So we have to split it two different ways.\n    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n *\n * Tick every second until the first click happens\n *\n * ```ts\n * import { interval, fromEvent, takeUntil } from 'rxjs';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return A function that returns an Observable that emits the values from the\n * source Observable until `notifier` emits its first value.\n */\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: true): MonoTypeOperatorFunction<T>;\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: false): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * ![](takeWhile.png)\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * ## Example\n *\n * Emit click events only while the clientX property is greater than 200\n *\n * ```ts\n * import { fromEvent, takeWhile } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @param {boolean} inclusive When set to `true` the value that caused\n * `predicate` to return `false` will also be emitted.\n * @return A function that returns an Observable that emits values from the\n * source Observable so long as each value satisfies the condition defined by\n * the `predicate`, then completes.\n */\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive = false): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const result = predicate(value, index++);\n        (result || inclusive) && subscriber.next(value);\n        !result && subscriber.complete();\n      })\n    );\n  });\n}\n","import { MonoTypeOperatorFunction, Observer } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\n\nexport interface TapObserver<T> extends Observer<T> {\n  subscribe: () => void;\n  unsubscribe: () => void;\n  finalize: () => void;\n}\n\nexport function tap<T>(observer?: Partial<TapObserver<T>>): MonoTypeOperatorFunction<T>;\nexport function tap<T>(next: (value: T) => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\nexport function tap<T>(\n  next?: ((value: T) => void) | null,\n  error?: ((error: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Used to perform side-effects for notifications from the source observable\n *\n * <span class=\"informal\">Used when you want to affect outside state with a notification without altering the notification</span>\n *\n * ![](tap.png)\n *\n * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects\n * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will\n * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to\n * help you remove side-effects from other operations.\n *\n * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function\n * reference, or a partial observer, then pass that notification down the stream.\n *\n * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler\n * provided to `tap` will be emitted as an error from the returned observable.\n *\n * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.\n *\n * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere\n * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous\n * operation.\n *\n * ## Examples\n *\n * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,\n * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number\n * was, so we have added a `tap(console.log)`.\n *\n * ```ts\n * import { of, tap, map } from 'rxjs';\n *\n * of(Math.random()).pipe(\n *   tap(console.log),\n *   map(n => n > 0.5 ? 'big' : 'small')\n * ).subscribe(console.log);\n * ```\n *\n * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only\n * want to emit numbers 3 or less we get from another source. We can force our observable to error\n * using `tap`.\n *\n * ```ts\n * import { of, tap } from 'rxjs';\n *\n * const source = of(1, 2, 3, 4, 5);\n *\n * source.pipe(\n *   tap(n => {\n *     if (n > 3) {\n *       throw new TypeError(`Value ${ n } is greater than 3`);\n *     }\n *   })\n * )\n * .subscribe({ next: console.log, error: err => console.log(err.message) });\n * ```\n *\n * We want to know when an observable completes before moving on to the next observable. The system\n * below will emit a random series of `'X'` characters from 3 different observables in sequence. The\n * only way we know when one observable completes and moves to the next one, in this case, is because\n * we have added a `tap` with the side effect of logging to console.\n *\n * ```ts\n * import { of, concatMap, interval, take, map, tap } from 'rxjs';\n *\n * of(1, 2, 3).pipe(\n *   concatMap(n => interval(1000).pipe(\n *     take(Math.round(Math.random() * 10)),\n *     map(() => 'X'),\n *     tap({ complete: () => console.log(`Done with ${ n }`) })\n *   ))\n * )\n * .subscribe(console.log);\n * ```\n *\n * @see {@link finalize}\n * @see {@link Observable#subscribe}\n *\n * @param observerOrNext A next handler or partial observer\n * @param error An error handler\n * @param complete A completion handler\n * @return A function that returns an Observable identical to the source, but\n * runs the specified Observer or callback(s) for each item.\n */\nexport function tap<T>(\n  observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void) | null,\n  error?: ((e: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T> {\n  // We have to check to see not only if next is a function,\n  // but if error or complete were passed. This is because someone\n  // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.\n  const tapObserver =\n    isFunction(observerOrNext) || error || complete\n      ? // tslint:disable-next-line: no-object-literal-type-assertion\n        ({ next: observerOrNext as Exclude<typeof observerOrNext, Partial<TapObserver<T>>>, error, complete } as Partial<TapObserver<T>>)\n      : observerOrNext;\n\n  return tapObserver\n    ? operate((source, subscriber) => {\n        tapObserver.subscribe?.();\n        let isUnsub = true;\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              tapObserver.next?.(value);\n              subscriber.next(value);\n            },\n            () => {\n              isUnsub = false;\n              tapObserver.complete?.();\n              subscriber.complete();\n            },\n            (err) => {\n              isUnsub = false;\n              tapObserver.error?.(err);\n              subscriber.error(err);\n            },\n            () => {\n              if (isUnsub) {\n                tapObserver.unsubscribe?.();\n              }\n              tapObserver.finalize?.();\n            }\n          )\n        );\n      })\n    : // Tap was called with no valid tap observer or handler\n      // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)\n      // so we're going to just mirror the source.\n      identity;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Defined, Maps} from '@scion/toolkit/util';\nimport {BehaviorSubject, firstValueFrom, noop} from 'rxjs';\nimport {filter} from 'rxjs/operators';\n\n/**\n * The bean manager allows getting references to singleton objects, so-called beans.\n *\n * #### Bean\n * A bean can be any object or even a primitive like a `boolean`. A bean is registered under some symbol in the bean manager. In most\n * cases, the class of the bean is used as the symbol. You can then look up the bean under its registration symbol. A symbol is either\n * a class type, an abstract class type, or a `Symbol`.\n *\n * #### Bean Scope\n * Beans are application-scoped, sometimes also referred to as singleton objects.\n *\n * #### Bean Construction\n * By default, the bean manager constructs beans lazily when looked up for the first time. Subsequent lookups then get the same bean instance.\n * When registering a bean, however, you can instruct the bean manager to construct the bean eagerly at startup. Eager beans are constructed after\n * all initializers complete.\n *\n * #### Registering Beans\n * A bean is registered in the bean manager under some class type, abstract class type or `Symbol`. In most cases, the symbol is also the type of the bean\n * instance but does not have to be. You can then look up the bean from the bean manager using that symbol.\n *\n * When registering a bean, you must tell the bean manager how to construct the bean. Different strategies are supported, as listed below.\n *\n * |Strategy|Description|Example|\n * |-|-|-|\n * |useClass             |if to create an instance of a class                                   |```Beans.register(Logger, {useClass: ConsoleLogger});```|\n * |useClass (shorthand) |Shorthand syntax if class and lookup symbol are identical             |```Beans.register(ConsoleLogger);```|\n * |useValue             |if to use a static value as bean                                      |```Beans.register(LoggingConfig, {useValue: config});```|\n * |useFactory           |if to construct the bean with a factory function                      |```Beans.register(Logger, {useFactory: () => new ConsoleLogger()});```|\n * |useExisting          |if to create an alias for another bean registered in the bean manager |```Beans.register(Logger, {useExisting: ConsoleLogger});```|\n *\n * #### Registering multiple Beans on the same Symbol\n * Multiple beans can be registered under the same symbol by setting the multi flag to `true`. When looking them up, they are returned in an array in registration order.\n *\n * ```ts\n * Beans.register(MessageInterceptor, {useClass: MessageLoggerInterceptor, multi: true});\n * ```\n * #### Looking up Beans\n * Beans are looked up using the symbol under which they were registered. The bean manager providers different methods to look up beans, as listed below.\n *\n * |Method|Description|\n * |-|-|\n * |`Beans.get` |Returns the bean registered under the given symbol. If no or multiple beans are registered under the passed symbol, an error is thrown. |\n * |`Beans.opt` |Returns the bean registered under the given symbol, if any, or returns `undefined` otherwise. |\n * |`Beans.all` |Returns all beans registered under the given symbol. Returns an empty array if no bean is found. |\n *\n * #### Replacing Beans\n * A bean can be replaced by registering another bean under a bean's symbol. In turn, the replaced bean is disposed and unregistered.\n *\n * #### Decorating Beans\n * The bean manager allows decorating a bean to intercept invocations to its methods and properties. Multiple decorators can decorate a single bean. Decoration\n * takes place in decorator registration order.\n *\n * Decorators are registered in the bean manager using the `Beans.registerDecorator` method under the symbol of the bean to be decorated.\n * As with the registration of a bean, you must tell the bean manager how to construct the decorator. For more information, see Bean Construction Strategies.\n * Decorators must be registered before starting the bean manager.\n *\n * A decorator must implement the decorate method of the BeanDecorator interface and return the proxied bean. To proxy a bean, you can create a JavaScript proxy,\n * or create an anonymous class delegating to the actual bean.\n *\n * #### Initializers\n * Initializers help to run initialization tasks during startup. Initializers can specify a runlevel in which to execute. Initializers bound to lower\n * runlevels execute before initializers of higher runlevels. Initializers of the same runlevel may execute in parallel.\n *\n * Initializers are registered in the bean manager using the `Beans.registerInitializer` method, passing a function or an initializer object, and optionally a runlevel.\n * If not specifying a runlevel, the initializer is executed in runlevel <code>0</code>, or in the default runlevel as specified when starting the bean manager.\n *\n * @category BeanManager\n */\nexport class BeanManager {\n\n  private _beanRegistry = new Map<Type<any> | AbstractType<any> | symbol, Set<BeanInfo>>();\n  private _decoratorRegistry = new Map<Type<any> | AbstractType<any> | symbol, BeanDecorator<any>[]>();\n  private _initializers: InitializerInfo[] = [];\n\n  private _sequence = 0;\n  private _runlevel$ = new BehaviorSubject<number>(-1);\n  private _eagerBeansConstructed = false;\n  private _started = false;\n\n  /**\n   * Registers a bean under the given symbol.\n   *\n   * If not providing instructions, the given symbol is used as the constructor function to construct the bean.\n   *\n   * By default, bean construction is lazy, meaning that the bean is constructed when looked up for the first time.\n   * If another bean is registered under the same symbol, that other bean is disposed and replaced with the given bean.\n   * To register multiple beans on the same symbol, register it with the flag `multi` set to `true`.\n   *\n   * Beans can be registered, replaced or removed even after starting the bean manager.\n   *\n   * @param  symbol - Symbol under which to register the bean.\n   * @param  instructions - Control bean construction; see {@link BeanInstanceConstructInstructions} for more detail.\n   * @return handle to unregister the bean.\n   */\n  public register<T>(symbol: Type<T | any> | AbstractType<T | any> | symbol, instructions?: BeanInstanceConstructInstructions<T>): Registration {\n    if (!symbol) {\n      throw Error('[BeanRegisterError] Missing bean lookup symbol.');\n    }\n\n    if (!instructions || !containsBeansConstructStrategy(instructions)) {\n      instructions = {...instructions, useClass: symbol as Type<T>};\n    }\n    validateBeanConstructInstructions(symbol, instructions);\n\n    // Check that either 'multi' or 'non-multi' beans are registered on the same symbol.\n    const multi = Defined.orElse(instructions.multi, false);\n    if (multi && this._beanRegistry.has(symbol) && Array.from(this._beanRegistry.get(symbol)!).some(metaData => !metaData.multi)) {\n      throw Error('[BeanRegisterError] Trying to register a bean as \\'multi-bean\\' on a symbol that has already registered a \\'non-multi-bean\\'. This is probably not what was intended.');\n    }\n    if (!multi && this._beanRegistry.has(symbol) && Array.from(this._beanRegistry.get(symbol)!).some(metaData => metaData.multi)) {\n      throw Error('[BeanRegisterError] Trying to register a bean on a symbol that has already registered a \\'multi-bean\\'. This is probably not what was intended.');\n    }\n\n    // Destroy an already registered bean under the same symbol, if any, unless multi is set to `true`.\n    if (!multi && this._beanRegistry.has(symbol)) {\n      this.disposeBean(this._beanRegistry.get(symbol)!.values().next().value);\n    }\n\n    const beanInfo: BeanInfo<T> = {\n      symbol: symbol,\n      beanConstructFn: createBeanConstructFunction(instructions),\n      eager: Defined.orElse(instructions.eager || instructions.useValue !== undefined, false),\n      multi: multi,\n      instructions: instructions,\n      constructing: false,\n    };\n\n    if (multi) {\n      const beans = this._beanRegistry.get(symbol) || new Set<BeanInfo>();\n      this._beanRegistry.set(symbol, beans.add(beanInfo));\n    }\n    else {\n      this._beanRegistry.set(symbol, new Set<BeanInfo>([beanInfo]));\n    }\n\n    if (beanInfo.eager && this._eagerBeansConstructed) {\n      this.getOrConstructBeanInstance(beanInfo);\n    }\n\n    return {unregister: (): void => this.disposeBean(beanInfo)};\n  }\n\n  /**\n   * Registers a bean under the given symbol, but only if no other bean is registered under that symbol yet.\n   *\n   * For detailed information about how to register a bean, see {@link register}.\n   *\n   * @param  symbol - Symbol under which to register the bean.\n   * @param  instructions - Control bean construction; see {@link BeanInstanceConstructInstructions} for more detail.\n   * @return handle to unregister the bean.\n   */\n  public registerIfAbsent<T>(symbol: Type<T | any> | AbstractType<T | any> | symbol, instructions?: BeanInstanceConstructInstructions<T>): Registration {\n    if (!symbol) {\n      throw Error('[BeanRegisterError] Missing bean lookup symbol.');\n    }\n\n    if (!this._beanRegistry.has(symbol)) {\n      return this.register(symbol, instructions);\n    }\n    return {unregister: noop};\n  }\n\n  /**\n   * Registers a decorator to proxy a bean.\n   *\n   * The decorator is invoked when the bean is constructed. Multiple decorators can be registered to decorate a bean.\n   * They are invoked in the order as registered.\n   *\n   * Decorators must be registered before starting the bean manager.\n   *\n   * @param symbol - Identifies the bean(s) which to decorate. If multiple beans are registered under that symbol, they all are decorated.\n   * @param decorator - Specifies the decorator.\n   */\n  public registerDecorator<T extends BeanDecorator<any>>(symbol: Type<any> | AbstractType<any> | symbol, decorator: {useValue: T} | {useClass?: Type<T>} | {useFactory?: () => T}): void {\n    if (this._started) {\n      throw Error('[BeanManagerLifecycleError] Decorators can only be registered before starting the bean manager.');\n    }\n\n    if (!symbol) {\n      throw Error('[BeanDecoratorRegisterError] A decorator requires a symbol.');\n    }\n\n    validateBeanConstructInstructions(symbol, decorator);\n    const constructFn = createBeanConstructFunction(decorator)();\n    Maps.addListValue(this._decoratorRegistry, symbol, constructFn);\n  }\n\n  /**\n   * Registers an initializer that is executed when the bean manager starts. The bean manager is fully started when all initializers are completed.\n   *\n   * Initializers can specify a runlevel in which to execute. Initializers bound to lower runlevels execute before initializers of higher runlevels.\n   * Initializers of the same runlevel may execute in parallel. Runlevels must be >= 0;\n   *\n   * Initializers must be registered before starting the bean manager.\n   */\n  public registerInitializer(initializer: InitializerFn | {useFunction?: InitializerFn; useClass?: Type<Initializer>; useExisting?: Type<Initializer> | AbstractType<Initializer> | symbol; runlevel?: number}): void {\n    if (this._started) {\n      throw Error('[BeanManagerLifecycleError] Initializers can only be registered before starting the bean manager.');\n    }\n\n    const initializerInfo: InitializerInfo = ((): InitializerInfo => {\n      if (typeof initializer === 'function') {\n        return {fn: initializer};\n      }\n      else if (initializer.runlevel !== undefined && initializer.runlevel < 0) {\n        throw Error(`[InitializerRegisterError] The runlevel of an initializer must be >= 0, but was ${initializer.runlevel}.`);\n      }\n      else if (initializer.useFunction) {\n        return {fn: initializer.useFunction, runlevel: initializer.runlevel};\n      }\n      else if (initializer.useClass) {\n        const useClass = initializer.useClass;\n        return {fn: (): Promise<void> => new useClass().init(), runlevel: initializer.runlevel};\n      }\n      else if (initializer.useExisting) {\n        const useExisting = initializer.useExisting;\n        return {fn: (): Promise<void> => Beans.get(useExisting).init(), runlevel: initializer.runlevel};\n      }\n      throw Error('[NullInitializerError] No initializer specified.');\n    })();\n\n    this._initializers.push(initializerInfo);\n  }\n\n  /**\n   * Returns the bean registered under the given symbol.\n   *\n   * By default, if no or multiple beans are registered under the given symbol, an error is thrown.\n   *\n   * @param  symbol - Symbol to look up the bean.\n   * @param  orElse - Controls what to do if no bean is found under the given symbol. If not set and if no bean is found, the bean manager throws an error.\n   * @throws if not finding a bean, or if multiple beans are found under the given symbol.\n   */\n  public get<T>(symbol: Type<T> | AbstractType<T> | Type<any> | AbstractType<any> | symbol, orElse?: {orElseGet?: T; orElseSupply?: () => T}): T {\n    const beans = this.all(symbol);\n    switch (beans.length) {\n      case 0: {\n        if (orElse?.orElseGet !== undefined) {\n          return orElse.orElseGet;\n        }\n        if (orElse?.orElseSupply) {\n          return orElse.orElseSupply();\n        }\n\n        throw Error(`[NullBeanError] No bean registered under the symbol '${getSymbolName(symbol)}'.`);\n      }\n      case 1: {\n        return beans[0];\n      }\n      default: {\n        throw Error(`[MultiBeanError] Multiple beans registered under the symbol '${getSymbolName(symbol)}'.`);\n      }\n    }\n  }\n\n  /**\n   * Returns the bean registered under the given symbol, if any, or returns `undefined` otherwise.\n   *\n   * @param  symbol - Symbol to look up the bean.\n   * @throws if multiple beans are found under the given symbol.\n   */\n  public opt<T>(symbol: Type<T> | AbstractType<T> | Type<any> | AbstractType<any> | symbol): T | undefined {\n    return this.get(symbol, {orElseSupply: (): undefined => undefined});\n  }\n\n  /**\n   * Returns all beans registered under the given symbol. Returns an empty array if no bean is found.\n   *\n   * @param symbol - Symbol to look up the beans.\n   */\n  public all<T>(symbol: Type<T> | AbstractType<T> | Type<any> | AbstractType<any> | symbol): T[] {\n    const beanInfos = Array.from(this._beanRegistry.get(symbol) || new Set<BeanInfo>());\n    if (!beanInfos || !beanInfos.length) {\n      return [];\n    }\n    if (beanInfos.some(beanInfo => beanInfo.constructing)) {\n      throw Error(`[BeanConstructError] Circular bean construction cycle detected [bean={${getSymbolName(symbol)}}].`);\n    }\n\n    return beanInfos.map(beanInfo => this.getOrConstructBeanInstance(beanInfo));\n  }\n\n  /**\n   * Starts the bean manager by running initializers and constructing eager beans. By default, constructs eager beans after\n   * all initializers completed.\n   *\n   * Initializers with a lower runlevel are executed before initializers with a higher runlevel. After all initializers of the\n   * same runlevel have completed, initializers of the next higher runlevel are executed, and so on. Initializers of the same\n   * runlevel may run in parallel.\n   *\n   * @param  config - Control initialization of the bean manager.\n   * @return A Promise that resolves when all initializers completed.\n   */\n  public async start(config?: BeanManagerConfig): Promise<void> {\n    if (this._started) {\n      throw Error('[BeanManagerLifecycleError] Bean manager already started.');\n    }\n\n    const initializerDefaultRunlevel = config?.initializerDefaultRunlevel ?? 0;\n    const eagerBeanConstructRunlevel = config?.eagerBeanConstructRunlevel ?? ((): number => {\n      if (this._initializers.length === 0) {\n        return initializerDefaultRunlevel + 1;\n      }\n      return Math.max(...this._initializers.map(initializer => initializer.runlevel ?? initializerDefaultRunlevel)) + 1;\n    })();\n\n    // Register initializer to construct eager beans.\n    this.registerInitializer({\n      useFunction: async () => {\n        this.constructEagerBeans();\n        this._eagerBeansConstructed = true;\n      },\n      runlevel: eagerBeanConstructRunlevel,\n    });\n\n    // Run initializers.\n    await this.runInitializers(initializerDefaultRunlevel);\n\n    this._started = true;\n  }\n\n  /**\n   * Destroys all beans managed by the bean manager.\n   *\n   * After calling this method, beans, initializers and decorators unregistered.\n   *\n   * Calling this method has no effect if the bean manager is not started, or failed to start.\n   */\n  public destroy(): void {\n    this.getBeanInfos()\n      .sort(compareByDestroyOrder)\n      .forEach(bean => this.disposeBean(bean));\n\n    this._beanRegistry.clear();\n    this._decoratorRegistry.clear();\n    this._initializers.length = 0;\n    this._runlevel$.next(-1);\n    this._eagerBeansConstructed = false;\n    this._started = false;\n  }\n\n  private disposeBean(beanInfo: BeanInfo): void {\n    const destroyable = beanInfo.instructions.useClass || beanInfo.instructions.useFactory;\n    if (destroyable && beanInfo.instance && typeof (beanInfo.instance as PreDestroy).preDestroy === 'function') {\n      try {\n        beanInfo.instance.preDestroy();\n      }\n      catch (error) {\n        console?.error('Bean threw an error in `preDestroy`', error);\n      }\n    }\n\n    beanInfo.instance = undefined;\n    beanInfo.constructing = false;\n    Maps.removeSetValue(this._beanRegistry, beanInfo.symbol, beanInfo);\n  }\n\n  /**\n   * Returns a Promise that resolves when the bean manager enters the specified runlevel.\n   * The Promise resolves immediately when the bean manager has already entered or completed that runlevel.\n   */\n  public async whenRunlevel(runlevel: number): Promise<void> {\n    return firstValueFrom(this._runlevel$\n      .pipe(filter(currentRunlevel => currentRunlevel >= runlevel)))\n      .then(() => Promise.resolve());\n  }\n\n  private getBeanInfos(): BeanInfo[] {\n    return Array.from(this._beanRegistry.values()).reduce((acc, beanInfos) => acc.concat(Array.from(beanInfos)), [] as BeanInfo[]);\n  }\n\n  /**\n   * Runs registered initializers, where initializers with a lower runlevel are executed before initializers with a higher runlevel.\n   * After all initializers of the same runlevel have completed, initializers of the next higher runlevel are executed, and so on.\n   * Initializers of the same runlevel may run in parallel.\n   */\n  private async runInitializers(defaultInitializerRunlevel: number): Promise<void> {\n    const initializersGroupedByRunlevel = this._initializers.reduce((grouped, initializer) => Maps.addListValue(grouped, initializer.runlevel ?? defaultInitializerRunlevel, initializer.fn), new Map<number, InitializerFn[]>());\n    const runlevels = Array\n      .from(initializersGroupedByRunlevel.keys())\n      .sort((a, b) => (a - b)); // sort numerically, not alphabetically\n\n    for (const runlevel of runlevels) {\n      this._runlevel$.next(runlevel);\n      try {\n        await Promise.all(initializersGroupedByRunlevel.get(runlevel)!.map(initializerFn => initializerFn()));\n      }\n      catch (error) {\n        throw Error(`[InitializerError] Initializer rejected with an error: ${error} [runlevel=${runlevel}]`);\n      }\n    }\n  }\n\n  /**\n   * Constructs beans with an eager construction.\n   */\n  private constructEagerBeans(): void {\n    this.getBeanInfos()\n      .filter(beanInfo => beanInfo.eager)\n      .forEach(beanInfo => this.getOrConstructBeanInstance(beanInfo));\n  }\n\n  /**\n   * Returns the bean instance if already constructed, or constructs the bean otherwise.\n   */\n  private getOrConstructBeanInstance<T>(beanInfo: BeanInfo): T {\n    // Check if the bean is already constructed.\n    if (beanInfo.instance) {\n      return beanInfo.instance;\n    }\n\n    // Construct the bean and decorate it.\n    beanInfo.constructing = true;\n    try {\n      const bean: T = beanInfo.beanConstructFn();\n      const decorators = this._decoratorRegistry.get(beanInfo.symbol) || [];\n\n      beanInfo.instance = [...decorators].reverse().reduce((decoratedBean, decorator) => decorator.decorate(decoratedBean), bean);\n      beanInfo.constructInstant = ++this._sequence;\n\n      return beanInfo.instance;\n    }\n    finally {\n      beanInfo.constructing = false;\n    }\n  }\n}\n\n/**\n * Provides access to beans registered in the bean manager.\n *\n * @category BeanManager\n */\nexport const Beans = new BeanManager();\n\n/**\n * Compares beans according to their destroy order. If the order is the same, the construction time of the beans is compared, in reverse construction order.\n *\n * @ignore\n */\nfunction compareByDestroyOrder(bean1: BeanInfo, bean2: BeanInfo): number {\n  if ((bean1.instructions.destroyOrder ?? 0) < (bean2.instructions.destroyOrder ?? 0)) {\n    return -1;\n  }\n  if ((bean1.instructions.destroyOrder ?? 0) > (bean2.instructions.destroyOrder ?? 0)) {\n    return +1;\n  }\n  return (bean2.constructInstant ?? 0) - (bean1.constructInstant ?? 0); // reverse construction order\n}\n\n/** @ignore */\nfunction createBeanConstructFunction<T>(instructions: BeanInstanceConstructInstructions<T>): () => T | null {\n  if (instructions.useValue !== undefined) {\n    const useValue = instructions.useValue;\n    return (): T | null => useValue;\n  }\n  else if (instructions.useClass) {\n    const useClassFn = instructions.useClass;\n    return (): T => new useClassFn();\n  }\n  else if (instructions.useFactory) {\n    const useFactoryFn = instructions.useFactory;\n    return (): T => useFactoryFn();\n  }\n  else if (instructions.useExisting) {\n    const useExisting = instructions.useExisting;\n    return (): T => Beans.get(useExisting);\n  }\n  throw Error(`[BeanConstructError] Missing bean construction strategy`);\n}\n\n/**\n * Validates passed instructions to construct the bean to be valid.\n *\n * @ignore\n */\nfunction validateBeanConstructInstructions(symbol: Type<any> | AbstractType<any> | symbol, instructions: BeanInstanceConstructInstructions): void {\n  switch (Object.keys(instructions).filter(instruction => instruction.startsWith('use')).length) {\n    case 0:\n      throw Error(`[BeanRegisterError] Missing bean construction strategy. Expected one of 'useValue', 'useClass', 'useFactory' or 'useExisting' [bean=${symbol.toString()}, instructions=${JSON.stringify(instructions)}]`);\n    case 1:\n      break;\n    default:\n      throw Error(`[BeanRegisterError] Multiple bean construction strategies specified. Expected one of 'useValue', 'useClass', 'useFactory' or 'useExisting' [bean=${symbol.toString()}, instructions=${JSON.stringify(instructions)}]`);\n  }\n\n  if (Object.keys(instructions).includes('useValue') && instructions.useValue === undefined) {\n    throw Error(`[BeanRegisterError] Passing \\`undefined\\` as bean value is not supported [bean=${symbol.toString()}].`);\n  }\n}\n\n/** @ignore */\nfunction containsBeansConstructStrategy(instructions: BeanInstanceConstructInstructions): boolean {\n  return Object.keys(instructions).some(property => property.startsWith('use'));\n}\n\n/**\n * Lifecycle hook will be executed before destroying this bean.\n *\n * @category BeanManager\n */\nexport interface PreDestroy {\n\n  /**\n   * Method invoked before destroying this bean, e.g., when unregistering it, or when shutting down the bean manager.\n   */\n  preDestroy(): void;\n}\n\n/**\n * Metadata about a bean.\n *\n * @ignore\n */\ninterface BeanInfo<T = any> {\n  symbol: Type<T | any> | AbstractType<T | any> | symbol;\n  instance?: T;\n  constructing: boolean;\n  beanConstructFn: () => T | null;\n  constructInstant?: number;\n  eager: boolean;\n  multi: boolean;\n  instructions: BeanInstanceConstructInstructions;\n}\n\n/**\n * @ignore\n */\ninterface InitializerInfo {\n  fn: InitializerFn;\n  runlevel?: number;\n}\n\n/**\n * Describes how a bean instance is created.\n *\n * @category BeanManager\n */\nexport interface BeanInstanceConstructInstructions<T = any> {\n  /**\n   * Set if to use a static value as bean.\n   */\n  useValue?: T | null;\n  /**\n   * Set if to create an instance of a class.\n   */\n  useClass?: Type<T>;\n  /**\n   * Set if to construct the instance with a factory function.\n   */\n  useFactory?: () => T;\n  /**\n   * Set if to create an alias for another bean.\n   */\n  useExisting?: Type<any> | AbstractType<any> | symbol;\n  /**\n   * Set if to construct the bean eagerly. By default, bean construction is lazy when the bean is looked up for the first time.\n   */\n  eager?: boolean;\n  /**\n   * Set if to provide multiple beans for a single symbol.\n   */\n  multi?: boolean;\n  /**\n   * Control when to destroy the bean when destroying the bean manager.\n   * Beans with a lower destroy order are destroyed before beans with a higher destroy order. Beans of the same destroy order\n   * are destroyed in reverse construction order.\n   */\n  destroyOrder?: number;\n}\n\n/**\n * Allows executing initialization tasks (synchronous or asynchronous) when starting the bean manager. The bean manager is fully started when all initializers are completed.\n *\n * Initializers can specify a runlevel in which to execute. Initializers bound to lower runlevels execute before initializers of higher runlevels.\n * Initializers of the same runlevel may execute in parallel.\n *\n * @see {@link BeanManager.registerInitializer Beans.registerInitializer}\n * @category BeanManager\n */\nexport interface Initializer {\n  /**\n   * Executes some work during bean manager startup.\n   *\n   * @return a Promise that resolves when this initializer completes its initialization.\n   */\n  init(): Promise<void>;\n}\n\n/**\n * Allows executing initialization tasks (synchronous or asynchronous) when starting the bean manager. The bean manager is fully started when all initializers are completed.\n *\n * Initializers can specify a runlevel in which to execute. Initializers bound to lower runlevels execute before initializers of higher runlevels.\n * Initializers of the same runlevel may execute in parallel.\n *\n * The initializer function must return a Promise that resolves when completed its initialization.\n *\n * @see {@link BeanManager.registerInitializer Beans.registerInitializer}\n * @category BeanManager\n */\nexport declare type InitializerFn = () => Promise<void>;\n\n/**\n * Allows intercepting bean method or property invocations.\n * When the bean is constructed, it is passed to the decorator in order to be proxied.\n *\n * @see {@link BeanManager.registerDecorator Beans.registerDecorator}\n * @category BeanManager\n */\nexport interface BeanDecorator<T> {\n  /**\n   * Method invoked when the bean is instantiated.\n   *\n   * @param  bean - The actual bean instance; use it to delegate invoations to the actual bean.\n   * @return proxied bean\n   */\n  decorate(bean: T): T;\n}\n\n/**\n * Represents a symbol of an abstract class.\n *\n * @category BeanManager\n */\nexport interface AbstractType<T> extends Function {\n  prototype: T;\n}\n\n/**\n * Represents a symbol of a class.\n *\n * @category BeanManager\n */\nexport interface Type<T> extends Function {\n  new(...args: any[]): T;\n}\n\n/**\n * @ignore\n */\nfunction getSymbolName(symbol: Type<any> | AbstractType<any> | symbol): string {\n  return (typeof symbol === 'function' ? symbol.name : symbol.toString());\n}\n\n/**\n * Handle to undo a registration.\n */\nexport interface Registration {\n  unregister: () => void;\n}\n\n/**\n * Control initialization of the bean manager.\n *\n * @category BeanManager\n */\nexport interface BeanManagerConfig {\n  /**\n   * Defines the runlevel in which to construct eager beans.\n   * If not set, eager beans are constructed after all registered initializers completed.\n   */\n  eagerBeanConstructRunlevel?: number;\n  /**\n   * Defines the runlevel in which initializers, that do not specify a runlevel, should be executed.\n   * If not set, initializers not specifying a runlevel are bound to the runlevel <code>0</code>.\n   */\n  initializerDefaultRunlevel?: number;\n}\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\n/**\n * Allows generating pseudo-random identifiers.\n */\nexport class UUID {\n\n  private constructor() {\n  }\n\n  /**\n   * Generates a 'pseudo-random' identifier.\n   */\n  public static randomUUID(): string {\n    let now = Date.now();\n    if (typeof window !== 'undefined' && typeof window.performance !== 'undefined' && typeof window.performance.now === 'function') {\n      now += performance.now(); // use high-precision timer if available\n    }\n\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, char => {\n      const random = (now + Math.random() * 16) % 16 | 0;\n      now = Math.floor(now / 16);\n      return (char === 'x' ? random : (random & 0x3 | 0x8)).toString(16);\n    });\n  }\n}\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\nimport {catchError, defaultIfEmpty, distinctUntilChanged, map, mergeMap, share, switchMap, take} from 'rxjs/operators';\nimport {combineLatest, concat, EMPTY, from, identity, MonoTypeOperatorFunction, noop, Observable, Observer, of, OperatorFunction, pipe, SchedulerLike, Subscriber, Subscription, TeardownLogic} from 'rxjs';\nimport {Arrays, Observables} from '@scion/toolkit/util';\n\n/**\n * Filters items in the source array and emits an array with items satisfying given predicate.\n *\n * - If passing `undefined` as predicate, the filter matches all items.\n * - If passing an asynchronous predicate:\n *   - Waits for all predicates to emit at least once or to complete.\n *     TIP: If you want to emit as soon as a predicate emits, use the `startWith(false)` operator in combination with\n *     the `skip` operator. Consequently, there will be a separate emission per item, in the order in which predicates\n *     emit.\n *\n *     ```ts\n *     source$\n *       .pipe(\n *         filterArray(item => matchesItem$(item).pipe(startWith(false))), // make the predicate immediately emit `false`\n *         skip(1), // skip initial emission caused by `startWith(false)`.\n *       )\n *       .subscribe(items => {});\n *     ```\n *   - Continues filtering the source Observable even if some predicate complete without first emission. Such items are not included in the emission.\n *   - Continues filtering the source Observable even if some predicate error. Such items are not included in the emission and the error is not propagated.\n */\nexport function filterArray<T, S extends T>(predicate?: (item: T) => item is S): OperatorFunction<T[], S[]>;\nexport function filterArray<T>(predicate?: (item: T) => Observable<boolean> | Promise<boolean> | boolean): MonoTypeOperatorFunction<T[]>;\nexport function filterArray<T>(predicate?: (item: T) => Observable<boolean> | Promise<boolean> | boolean): MonoTypeOperatorFunction<T[]> {\n  if (!predicate) {\n    return identity;\n  }\n\n  return switchMap((items: T[]): Observable<T[]> => {\n    if (!items.length) {\n      return of([]);\n    }\n\n    // Filter items if all predicates return a boolean value.\n    const matches = items.map(predicate);\n    if (matches.every(match => typeof match === 'boolean')) {\n      return of(items.filter((item, i) => matches[i]));\n    }\n\n    /*\n     * Notes about `combineLatest` operator:\n     * - Passing an empty array will result in an Observable that completes immediately.\n     * - Waits for all Observables to emit at least once.\n     * - If some Observable does not emit a value but completes, resulting Observable will complete at the same moment without emitting anything.\n     * - If some Observable does not emit any value and never completes, `combineLatest` will also never emit and never complete.\n     * - If any Observable errors, `combineLatest` will error immediately as well, and all other Observables will be unsubscribed.\n     */\n    return combineLatest(matches.map(match => Observables.coerce(match).pipe(defaultIfEmpty(false), catchError(() => of(false)))))\n      .pipe(\n        distinctUntilChanged((previous, current) => Arrays.isEqual(previous, current)),\n        map(matches => items.filter((item, i) => matches[i])),\n      );\n  });\n}\n\n/**\n * Maps each element in the source array to its extracted property.\n *\n * Like rxjs 'pluck' but based on an array with a function to extract the property.\n *\n * @deprecated since version 10.0.0-beta.3. Use {@link mapArray} instead.\n */\nexport function pluckArray<I, P>(extractor: (item: I) => P): OperatorFunction<I[], P[]> {\n  return map((items: I[]): P[] => items.map(item => extractor(item)));\n}\n\n/**\n * Maps each element in the source array to its mapped value.\n */\nexport function mapArray<I, P>(projectFn: (item: I) => P): OperatorFunction<I[], P[]> {\n  return map((items: I[]): P[] => items.map(item => projectFn(item)));\n}\n\n/**\n * Sorts items in the source array and emits an array with those items sorted.\n */\nexport function sortArray<T>(comparator: (item1: T, item2: T) => number): MonoTypeOperatorFunction<T[]> {\n  return map((items: T[]): T[] => [...items].sort(comparator));\n}\n\n/**\n * Combines the Observables contained in the source array by applying {@link combineLatest}, emitting an array with the latest\n * value of each Observable of the source array. Combines only the Observables of the most recently emitted array.\n *\n * <span class=informal>Each time the source emits an array of Observables, combines its Observables by subscribing to each\n * of them, cancelling any subscription of a previous source emission.</span>\n */\nexport function combineArray<T>(): OperatorFunction<Array<Observable<T[]>>, T[]> {\n  return pipe(\n    switchMap((items: Array<Observable<T[]>>) => items.length ? combineLatest(items) : of([])),\n    map((items: Array<T[]>) => new Array<T>().concat(...items)),\n  );\n}\n\n/**\n * Removes duplicates of elements in the source array.\n *\n * <span class=informal>Each time the source emits, maps the array to a new array with duplicates removed.</span>\n */\nexport function distinctArray<T>(keySelector: (item: T) => any = identity): MonoTypeOperatorFunction<T[]> {\n  return pipe(map((items: T[]): T[] => Arrays.distinct(items, keySelector)));\n}\n\n/**\n * Buffers the source Observable values until `closingNotifier$` notifier resolves, emits or completes.\n *\n * Once closed the buffer, emits its buffered values as a separate emission per buffered value, in the\n * order as collected. After that, this operator mirrors the source Observable, i.e., emits values as they\n * arrive.\n *\n * Unlike {@link bufferWhen} RxJS operator, the buffer is not re-opened once closed.\n *\n * @param closingNotifier$ Closes the buffer when the passed Promise resolves, or when the passed Observable\n *                         emits or completes.\n */\nexport function bufferUntil<T>(closingNotifier$: Observable<any> | Promise<any>): MonoTypeOperatorFunction<T> {\n  const guard$ = from(closingNotifier$)\n    .pipe(\n      take(1),\n      mergeMap(() => EMPTY),\n      share({resetOnComplete: false, resetOnError: false, resetOnRefCountZero: false}),\n    );\n  return mergeMap((item: T) => concat(guard$, of(item)));\n}\n\n/**\n * Executes a tap-function for the first percolating value.\n */\nexport function tapFirst<T>(tapFn: (value?: T) => void, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T> {\n  return map(((value: T, index: number): T => {\n    if (index === 0) {\n      scheduler ? scheduler.schedule(tapFn) : tapFn(value);\n    }\n    return value;\n  }));\n}\n\n/**\n * Mirrors the source Observable, but runs downstream operators (operators below the `observeInside` operator) and subscription handlers\n * (next, error, complete) inside the given execution context.\n *\n * This operator is particularly useful in Angular applications to run downstream operators inside or outside the Angular zone,\n * as following: `observeInside(continueFn => ngzone.run(continueFn))`.\n *\n * This operator is similar to RxJS's `observeOn` operator, but instead of a scheduler, it accepts an executor. An executor is a function to\n * create an execution context in which downstream operators are then executed. The function is called with a single argument, a function\n * to continue the execution chain.\n *\n * #### Example showing in which Angular zone operators run:\n * ```\n * // Code running outside Angular\n *\n * interval(1000) // Observable creation outside Angular\n *   .pipe(\n *     tap(() => ...), // outside Angular\n *     tap(() => ...), // outside Angular\n *     observeInside(continueFn => zone.run(continueFn)),\n *     tap(() => ...), // inside Angular\n *   )\n *   .subscribe(); // inside Angular\n * ```\n *\n * @param   executionFn - Function for setting up a context in which to continue the execution chain.\n * @return  An Observable mirroring the source, but running downstream operators in a context.\n */\nexport function observeInside<T>(executionFn: ExecutionFn): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>): Observable<T> => {\n    return new Observable((observer: Observer<T>): TeardownLogic => {\n      const subscription = source.subscribe({\n        next: next => executionFn(() => observer.next(next)),\n        error: error => executionFn(() => observer.error(error)),\n        complete: () => executionFn(() => observer.complete()),\n      });\n\n      return () => subscription.unsubscribe();\n    });\n  };\n}\n\n/**\n * Mirrors the source Observable, but uses the given execution context to subscribe/unsubscribe to the source. It further runs all operators of the\n * execution chain (operators above and below the `subscribeInside` operator) as well as subscription handlers (next, error, complete) in the given\n * context.\n *\n * Unlike `observeInside` operator, the `subscribeInside` also acts upstream. By using the {@link observeInside} operator after the\n * {@link subscribeInside}, you can change the execution context for downstream operators.\n *\n * This operator is particularly useful in Angular applications to subscribe to the source inside or outside the Angular zone, as following:\n * `subscribeInside(continueFn => ngzone.run(continueFn))`.\n *\n * This operator is similar to RxJS's `subscribeOn` operator, but instead of a scheduler, it accepts an executor. An executor is a function to\n * create an execution context in which upstream and downstream operators are then executed. The function is called with a single argument,\n * a function to continue the execution chain.\n *\n * #### Example showing in which Angular zone operators run:\n * ```\n * // Code running outside Angular\n *\n * interval(1000) // Observable creation inside Angular\n *   .pipe(\n *     tap(() => ...), // inside Angular\n *     tap(() => ...), // inside Angular\n *     subscribeInside(continueFn => zone.run(continueFn)),\n *     tap(() => ...), // inside Angular\n *   )\n *   .subscribe(); // inside Angular\n * ```\n *\n * @param   executionFn - Function for setting up a context in which to continue the execution chain.\n * @return  An Observable mirroring the source, but running upstream and downstream operators in a context.\n */\nexport function subscribeInside<T>(executionFn: ExecutionFn): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>): Observable<T> => {\n    return new Observable((observer: Observer<T>): TeardownLogic => {\n      let subscription: Subscription;\n\n      executionFn(() => {\n        subscription = source.subscribe(new class extends Subscriber<T> {\n\n          constructor() {\n            super(observer);\n          }\n\n          protected override _next(value: T): void {\n            executionFn(() => super._next(value));\n          }\n\n          protected override _error(err: any): void {\n            executionFn(() => super._error(err));\n          }\n\n          protected override _complete(): void {\n            executionFn(() => super._complete());\n          }\n\n          public override unsubscribe(): void {\n            executionFn(() => this.closed ? noop() : super.unsubscribe());\n          }\n        });\n      });\n\n      return () => {\n        executionFn(() => subscription?.unsubscribe());\n      };\n    });\n  };\n}\n\n/**\n * Function to continue the operator chain.\n *\n * @see observeInside\n * @see subscribeInside\n */\nexport type ContinueExecutionFn = () => void;\n\n/**\n * Function for setting up a context in which to continue the execution chain.\n *\n * @see observeInside\n * @see subscribeInside\n */\nexport type ExecutionFn = (fn: ContinueExecutionFn) => void;\n","/*\n * Copyright (c) 2018-2019 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Observable, Observer, TeardownLogic} from 'rxjs';\n\n/**\n * Allows observing the dimension of an element. Upon subscription, it emits the element's dimension, and then continuously\n * emits when the dimension of the element changes. It never completes.\n *\n * The Observable uses the native `ResizeObserver` to detect size changes of the passed element.\n *\n * @param  target - HTMLElement to observe its dimension.\n * @return Observable that emits dimension changes of the passed element.\n */\nexport function fromDimension$(target: HTMLElement): Observable<Dimension> {\n  return new Observable((observer: Observer<Dimension>): TeardownLogic => {\n    const resizeObserver = new ResizeObserver(() => observer.next(captureElementDimension(target)));\n    resizeObserver.observe(target); // emits the current dimension directly upon subscription\n\n    return (): void => {\n      resizeObserver.disconnect();\n    };\n  });\n}\n\n/**\n * Captures the dimension of the given element.\n */\nexport function captureElementDimension(element: HTMLElement): Dimension {\n  return {\n    clientWidth: element.clientWidth,\n    offsetWidth: element.offsetWidth,\n    clientHeight: element.clientHeight,\n    offsetHeight: element.offsetHeight,\n    element,\n  };\n}\n\n/**\n * Represents the dimension of an element.\n */\nexport interface Dimension {\n  offsetWidth: number;\n  offsetHeight: number;\n  clientWidth: number;\n  clientHeight: number;\n  element: HTMLElement;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\n/**\n * Manifest of an application.\n *\n * The manifest is a special file that contains information about a micro application. A micro application declares\n * its intentions and capabilities in its manifest file. The manifest needs to be registered in the host application.\n *\n * @category Platform\n */\nexport interface Manifest {\n  /**\n   * The name of the application, e.g. displayed in the DevTools.\n   */\n  name: string;\n  /**\n   * URL to the application root. The URL can be fully qualified, or a path relative to the origin under\n   * which serving the manifest file. If not specified, the origin of the manifest file acts as the base\n   * URL. The platform uses the base URL to resolve microfrontends such as activator endpoints.\n   * For a Single Page Application that uses hash-based routing, you typically specify the hash symbol (`#`)\n   * as the base URL.\n   */\n  baseUrl?: string;\n  /**\n   * Functionality which this application intends to use.\n   */\n  intentions?: Intention[];\n  /**\n   * Functionality which this application provides that qualified apps can call via intent.\n   */\n  capabilities?: Capability[];\n}\n\n/**\n * Represents a dictionary of key-value pairs to qualify an intention, intent or capability.\n *\n * See {@link Intention}, {@link Capability} or {@link Intent} for the usage of wildcards\n * in qualifier properties.\n *\n * @category Platform\n */\nexport interface Qualifier {\n  [key: string]: string | number | boolean;\n}\n\n/**\n * Represents an application registered in the platform.\n *\n * @category Platform\n */\nexport interface Application {\n  /**\n   * Unique symbolic name of the application.\n   */\n  symbolicName: string;\n  /**\n   * Name of the application as specified in the manifest.\n   */\n  name: string;\n  /**\n   * URL to the application root.\n   */\n  baseUrl: string;\n  /**\n   * Specifies the origin where message from this application must originate from. Messages of a different origin will be rejected.\n   */\n  messageOrigin: string;\n  /**\n   * URL to the manifest of this application.\n   */\n  manifestUrl: string;\n  /**\n   * Maximum time (in milliseconds) that the host waits until the manifest for this application is loaded.\n   *\n   * This is the effective timeout, i.e, either the application-specific timeout as defined in {@link ApplicationConfig.manifestLoadTimeout},\n   * or the global timeout as defined in {@link MicrofrontendPlatformConfig.manifestLoadTimeout}, otherwise `undefined`.\n   */\n  manifestLoadTimeout?: number;\n  /**\n   * Maximum time (in milliseconds) that the host waits for this application to signal readiness.\n   *\n   * This is the effective timeout, i.e, either the application-specific timeout as defined in {@link ApplicationConfig.activatorLoadTimeout},\n   * or the global timeout as defined in {@link MicrofrontendPlatformConfig.activatorLoadTimeout}, otherwise `undefined`.\n   */\n  activatorLoadTimeout?: number;\n  /**\n   * Indicates whether or not capability scope check is disabled for this application.\n   */\n  scopeCheckDisabled: boolean;\n  /**\n   * Indicates whether or not this application can issue intents for which it has not declared a respective intention.\n   */\n  intentionCheckDisabled: boolean;\n  /**\n   * Indicates whether or not 'Intention Registration API' is disabled for this application.\n   */\n  intentionRegisterApiDisabled: boolean;\n  /**\n   * Version of the SCION Microfrontend Platform used by this application.\n   */\n  platformVersion: Promise<string>;\n}\n\n/**\n * The term capability refers to the Intention API of the SCION Microfrontend Platform.\n *\n * A capability represents some functionality of a micro application that is available to qualified micro applications through the Intention API.\n * A micro application declares its capabilities in its manifest. Qualified micro applications can browse capabilities similar to a catalog, or\n * interact with capabilities via intent.\n *\n * A capability is formulated in an abstract way consisting of a type and optionally a qualifier. The type categorizes a capability in terms of its\n * functional semantics. A capability may also define a qualifier to differentiate different capabilities of the same type.\n *\n * A capability can have private or public visibility. If private, which is by default, the capability is not visible to other micro\n * applications; thus, it can only be invoked or browsed by the providing micro application itself.\n *\n * A capability can specify parameters which the intent issuer can/must pass along with the intent. Parameters are part of the contract between\n * the intent publisher and the capability provider. They do not affect the intent routing, unlike the qualifier.\n *\n * Metadata can be associated with a capability in its properties section. For example, if providing a microfrontend, the URL to the\n * microfrontend can be added as property, or if the capability contributes an item to a menu, its label to be displayed.\n *\n * @category Platform\n * @category Intention API\n */\nexport interface Capability {\n  /**\n   * Categorizes the capability in terms of its functional semantics (e.g., `microfrontend` if providing a microfrontend).\n   * It can be an arbitrary `string` literal and has no meaning to the platform.\n   */\n  type: string;\n  /**\n   * The qualifier is a dictionary of arbitrary key-value pairs to differentiate capabilities of the same `type` and is like\n   * an abstract description of the capability. It should include enough information to uniquely identify the capability.\n   *\n   * Intents must exactly match the qualifier of the capability, if any. The capability qualifier allows using wildcards\n   * (such as `*` or `?`) to match multiple intents simultaneously.\n   *\n   * - **Asterisk wildcard character (`*`):**\n   *   Intents must contain such a property, but any value is allowed (except `null` or `undefined`). Use it like this: `{property: '*'}`\n   * - **Optional wildcard character (?):**\\\n   *   Intents can contain such a property. Use it like this: `{property: '?'}`.\n   */\n  qualifier?: Qualifier;\n  /**\n   * Specifies parameters which the intent issuer must pass along with the intent.\n   * Parameters are part of the contract between the intent publisher and the capability provider.\n   * They do not affect the intent routing, unlike the qualifier.\n   *\n   * @deprecated This API will be removed in a future release. Instead, declare parameters via {@link Capability.params} property.\n   */\n  requiredParams?: string[];\n  /**\n   * Specifies parameters which the intent issuer optionally can pass along with the intent.\n   * Parameters are part of the contract between the intent publisher and the capability provider.\n   * They do not affect the intent routing, unlike the qualifier.\n   *\n   * @deprecated This API will be removed in a future release. Instead, declare parameters via {@link Capability.params} property.\n   */\n  optionalParams?: string[];\n  /**\n   * Specifies parameters which the intent issuer can/must pass along with the intent.\n   *\n   * Parameters are part of the contract between the intent publisher and the capability provider.\n   * They do not affect the intent routing, unlike the qualifier.\n   */\n  params?: ParamDefinition[];\n  /**\n   * Controls if this capability is visible to other micro applications. If private, which is by default, the capability is not visible\n   * to other micro applications; thus, it can only be invoked or looked up by the providing micro application.\n   */\n  private?: boolean;\n  /**\n   * A short description to explain the capability.\n   */\n  description?: string;\n  /**\n   * Arbitrary metadata to be associated with the capability.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n  /**\n   * Metadata about the capability (read-only, exclusively managed by the platform).\n   * @ignore\n   */\n  metadata?: {\n    /**\n     * Unique identity of this capability.\n     */\n    id: string;\n    /**\n     * Symbolic name of the application which provides this capability.\n     */\n    appSymbolicName: string;\n  };\n}\n\n/**\n * The term intention refers to the Intention API of the SCION Microfrontend Platform.\n *\n * An intention refers to one or more capabilities that a micro application wants to interact with.\n *\n * Intentions are declared in the applications manifest and are formulated in an abstract way, consisting of a type\n * and optionally a qualifier. The qualifier is used to differentiate capabilities of the same type.\n *\n * @category Platform\n * @category Intention API\n */\nexport interface Intention {\n  /**\n   * The type of capability to interact with.\n   */\n  type: string;\n  /**\n   * Qualifies the capability which to interact with.\n   *\n   * The qualifier is a dictionary of arbitrary key-value pairs to differentiate capabilities of the same `type`.\n   *\n   * The intention must exactly match the qualifier of the capability, if any. The intention qualifier allows using\n   * wildcards (such as `*` or `?`) to match multiple capabilities simultaneously.\n   *\n   * In the intention, the following wildcards are supported:\n   * - **Asterisk wildcard character (`*`):**\\\n   *   Matches capabilities with such a qualifier property no matter of its value (except `null` or `undefined`).\n   *   Use it like this: `{property: '*'}`.\n   * - **Optional wildcard character (?):**\\\n   *   Matches capabilities regardless of having or not having such a property. Use it like this: `{property: '?'}`.\n   * - **Partial wildcard (`**`):**\n   *   Matches capabilities even if having additional properties. Use it like this: `{'*': '*'}`.\n   */\n  qualifier?: Qualifier;\n  /**\n   * Metadata about this intention (read-only, exclusively managed by the platform).\n   * @ignore\n   */\n  metadata?: {\n    /**\n     * Unique identity of this intent declaration.\n     */\n    id: string;\n    /**\n     * Symbolic name of the application which declares this intention.\n     */\n    appSymbolicName: string;\n  };\n}\n\n/**\n * Built in capability types.\n */\nexport enum PlatformCapabilityTypes {\n  /**\n   * Type for registering an activator capability.\n   *\n   * @see ActivatorCapability\n   */\n  Activator = 'activator',\n  /**\n   * Type for registering a microfrontend capability.\n   *\n   * @see MicrofrontendCapability\n   */\n  Microfrontend = 'microfrontend',\n}\n\n/**\n * An activator allows a micro application to initialize and connect to the platform upon host application's startup,\n * i.e., when the user loads the web application into the browser.\n *\n * In the broadest sense, an activator is a kind of microfrontend, i.e. an HTML page that runs in an iframe. In contrast\n * to regular microfrontends, however, at platform startup, the platform loads activator microfrontends into hidden iframes\n * for the entire platform lifecycle, thus, providing a stateful session to the micro application on the client-side.\n *\n * Some typical use cases for activators are receiving messages and intents, preloading data, or flexibly providing capabilities.\n *\n * A micro application registers an activator as public _activator_ capability in its manifest, as follows:\n *\n * ```json\n * \"capabilities\": [\n *   {\n *     \"type\": \"activator\",\n *     \"private\": false,\n *     \"properties\": {\n *       \"path\": \"path/to/the/activator\"\n *     }\n *   }\n * ]\n * ```\n *\n * #### Activation Context\n * An activator's microfrontend runs inside an activation context. The context provides access\n * to the activator capability, allowing to read properties declared on the activator capability.\n *\n * You can obtain the activation context using the {@link ContextService} as following.\n *\n * ```ts\n * // Looks up the activation context.\n * const ctx: ActivationContext = await Beans.get(ContextService).lookup(ACTIVATION_CONTEXT);\n * ```\n *\n * #### Multiple Activators\n * A micro application can register multiple activators. Note, that each activator boots the micro\n * application on its own and runs in a separate browsing context. The platform nominates one activator\n * of each micro application as its primary activator. The nomination has no relevance to the platform but\n * can help code decide whether or not to install singleton functionality.\n *\n * You can test if running in the primary activation context as following.\n * ```ts\n * // Looks up the activation context.\n * const ctx = await Beans.get(ContextService).lookup<ActivationContext>(ACTIVATION_CONTEXT);\n * // Checks if running in the context of the primary activator.\n * const isPrimary: boolean = ctx.primary;\n * ```\n *\n * #### Sharing State\n * Since an activator runs in a separate browsing context, microfrontends cannot directly access its state.\n * Instead, an activator could put data, for example, into session storage, so that microfrontends of its micro\n * application can access it. Alternatively, an activator could install a message listener, allowing microfrontends\n * to request data via client-side messaging.\n *\n * @category Platform\n */\nexport interface ActivatorCapability extends Capability {\n  type: PlatformCapabilityTypes.Activator;\n  private: false;\n  properties: {\n    /**\n     * Path where the platform can load the activator microfrontend. The path is relative to the base URL\n     * of the micro application, as specified in the application manifest.\n     */\n    path: string;\n    /**\n     * Starting an activator may take some time. In order not to miss any messages or intents, you can instruct the platform host to\n     * wait to enter started state until you signal the activator to be ready. For this purpose, you can define a set of topics where\n     * to publish a ready message to signal readiness. If you specify multiple topics, the activator enters ready state after you have\n     * published a ready message to all these topics. A ready message is an event; thus, a message without payload.\n     *\n     * If not specifying a readiness topic, the platform host does not wait for this activator to become ready. However, if you specify a\n     * readiness topic, make sure that your activator has a fast startup time and signals readiness as early as possible not to delay\n     * the startup of the platform host.\n     */\n    readinessTopics?: string | string[];\n  };\n}\n\n/**\n * Represents a microfrontend that can be loaded into a <sci-router-outlet> using the {@link OutletRouter}.\n */\nexport interface MicrofrontendCapability extends Capability {\n  type: PlatformCapabilityTypes.Microfrontend;\n  properties: {\n    /**\n     * Specifies the path of the microfrontend.\n     *\n     * The path is relative to the base URL, as specified in the application manifest. If the\n     * application does not declare a base URL, it is relative to the origin of the manifest file.\n     *\n     * The path allows the use of navigational symbols and named parameters to reference qualifier and parameter values.\n     * A named parameter begins with a colon (`:`) followed by the qualifier or parameter name, and is allowed in path segments,\n     * query parameters, matrix parameters and the fragment part. Named query and matrix parameters without a replacement are removed,\n     * e.g., if referencing an optional parameter.\n     *\n     * #### Usage of named parameters in the path:\n     * ```json\n     * {\n     *   \"type\": \"microfrontend\",\n     *   \"qualifier\": {\n     *     \"entity\": \"product\"\n     *   },\n     *   \"params\": [\n     *     {\"name\": \"id\", \"required\": true}\n     *   ]\n     *   \"properties\": {\n     *     \"path\": \"product/:id\",\n     *   }\n     * }\n     * ```\n     *\n     * #### Path parameter example:\n     * segment/:param1/segment/:param2\n     *\n     * #### Matrix parameter example:\n     * segment/segment;matrixParam1=:param1;matrixParam2=:param2\n     *\n     * #### Query parameter example:\n     * segment/segment?queryParam1=:param1&queryParam2=:param2\n     */\n    path: string;\n    /**\n     * Specifies the preferred outlet to load this microfrontend into.\n     * Note that this preference is only a hint that will be ignored if the navigator\n     * specifies an outlet for navigation.\n     *\n     * The precedence is as follows:\n     * - Outlet as specified by navigator via {@link NavigationOptions#outlet}.\n     * - Preferred outlet as specified in the microfrontend capability.\n     * - Current outlet if navigating in the context of an outlet.\n     * - {@link PRIMARY_OUTLET primary} outlet.\n     */\n    outlet?: string;\n  };\n}\n\n/**\n * Describes a parameter to be passed along with an intent.\n */\nexport interface ParamDefinition {\n  /**\n   * Specifies the name of the parameter.\n   */\n  name: string;\n  /**\n   * Describes the parameter and its usage in more detail.\n   */\n  description?: string;\n  /**\n   * Specifies whether the parameter must be passed along with the intent.\n   */\n  required: boolean;\n  /**\n   * Allows deprecating the parameter.\n   *\n   * It is good practice to explain the deprecation, provide the date of removal, and how to migrate.\n   * If renaming the parameter, you can set the `useInstead` property to specify which parameter to use\n   * instead. At runtime, this will map the parameter to the specified replacement, allowing for\n   * straightforward migration on the provider side.\n   */\n  deprecated?: true | {message?: string; useInstead?: string};\n\n  /**\n   * Allows the declaration of additional metadata that can be interpreted in an interceptor, for example.\n   */\n  [property: string]: any;\n}\n\n/**\n * Symbol to determine if this app instance is running as the platform host.\n *\n * ```ts\n * const isPlatformHost: boolean = Beans.get(IS_PLATFORM_HOST);\n * ```\n *\n * @category Platform\n */\nexport const IS_PLATFORM_HOST = Symbol('IS_PLATFORM_HOST');\n\n/**\n * Multi-Symbol to look up registered application configs from the bean manager.\n *\n * @internal\n */\nexport const APP_CONFIG = Symbol('APP_CONFIG');\n\n/**\n * Symbol to get the application's symbolic name from the bean manager.\n */\nexport const APP_IDENTITY = Symbol('APP_IDENTITY');\n\n/**\n * Symbol to get the version of the SCION Microfrontend Platform.\n *\n * @internal\n */\nexport const VERSION = Symbol('VERSION');\n\n/**\n * Symbol to get the topmost window in the window hierarchy from the bean manager.\n *\n * Alias for `window.top` that can be overridden in tests, e.g., to simulate\n * the client to connect to a remote host.\n *\n * @internal\n */\nexport const WINDOW_TOP = Symbol('WINDOW_TOP');\n\n/**\n * Key for obtaining the current activation context using {@link ContextService}.\n *\n * The activation context is only available to microfrontends loaded by an activator.\n *\n * @see {@link ActivationContext}\n * @see {@link ContextService}\n * @category Platform\n */\nexport const ACTIVATION_CONTEXT = 'ACTIVATION_CONTEXT';\n\n/**\n * Information about the activator that loaded a microfrontend.\n *\n * This context is available to a microfrontend if loaded by an application activator.\n * This object can be obtained from the {@link ContextService} using the name {@link ACTIVATION_CONTEXT}.\n *\n * ```ts\n * const ctx = await Beans.get(ContextService).lookup<ActivationContext>(ACTIVATION_CONTEXT);\n * ```\n *\n * @see {@link ACTIVATION_CONTEXT}\n * @see {@link ContextService}\n * @category Platform\n */\nexport interface ActivationContext {\n  /**\n   * Indicates whether running in the context of the primary activator.\n   * The platform nominates one activator of each app as primary activator.\n   */\n  primary: boolean;\n  /**\n   * Metadata about the activator that activated the microfrontend.\n   */\n  activator: ActivatorCapability;\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Capability, Qualifier} from './platform.model';\nimport {MonoTypeOperatorFunction, Observable, of, OperatorFunction, pipe, throwError} from 'rxjs';\nimport {filter, map, mergeMap, takeWhile} from 'rxjs/operators';\n\n/**\n * Represents a message with headers to transport additional information with a message.\n *\n * @category Messaging\n */\nexport interface Message {\n  /**\n   * Additional information attached to this message.\n   *\n   * Header values must be JSON serializable. If no headers are set, the `Map` is empty.\n   */\n  headers: Map<string, any>;\n  /**\n   * Indicates whether this message is retained on the broker for late subscribers.\n   */\n  retain?: boolean;\n}\n\n/**\n * Represents an intent sent by an application.\n *\n * The intent is transported to applications that provide a fulfilling capability visible to the sending application.\n *\n * @category Messaging\n */\nexport interface IntentMessage<BODY = any> extends Message {\n  /**\n   * Intent that represents this message.\n   */\n  intent: Intent;\n  /**\n   * Optional data passed along with the intent.\n   */\n  body?: BODY;\n  /**\n   * Capability that fulfills the intent.\n   */\n  capability: Capability;\n}\n\n/**\n * The term intention refers to the Intention API of the SCION Microfrontend Platform.\n *\n * The intent is the message that a micro application sends to interact with functionality that is available in the form of a capability.\n *\n * The platform transports the intent to the micro applications that provide the requested capability. A micro application can issue an\n * intent only if having declared an intention in its manifest. Otherwise, the platform rejects the intent.\n *\n * An intent is formulated in an abstract way, having assigned a type, and optionally a qualifier. This information is used for resolving\n * the capability; thus, it can be thought of as a form of capability addressing. See the definition of a capability for more information.\n *\n * @category Messaging\n * @category Intention API\n */\nexport interface Intent {\n  /**\n   * Type of functionality to intend.\n   */\n  type: string;\n  /**\n   * The qualifier is an abstract description of the intent and is expressed in the form of a dictionary.\n   *\n   * When issuing an intent, the qualifier must be exact, i.e. not contain wildcards.\n   */\n  qualifier?: Qualifier;\n  /**\n   * Parameters allow additional data to be passed along with the intent.\n   *\n   * They are part of the contract between the intent publisher and the capability provider. The capability provider\n   * can declare mandatory and optional parameters. No additional parameters may be included.\n   *\n   * Parameters have no effect on the intent routing, unlike the qualifier. If mandatory parameters\n   * are missing or non-specified parameters are included, the intent is rejected.\n   */\n  params?: Map<string, any>;\n}\n\n/**\n * Represents a message published to a topic.\n *\n * The message is transported to all consumers subscribed to the topic.\n *\n * @category Messaging\n */\nexport interface TopicMessage<BODY = any> extends Message {\n  /**\n   * The topic where to publish this message to.\n   */\n  topic: string;\n  /**\n   * Optional message.\n   */\n  body?: BODY;\n  /**\n   * Contains the resolved values of the wildcard segments as specified in the topic.\n   * For example: If subscribed to the topic `person/:id` and a message is published to the topic `person/5`,\n   * the resolved id with the value `5` is contained in the params map.\n   */\n  params?: Map<string, string>;\n}\n\n/**\n * Declares headers set by the platform when sending a message.\n *\n * Clients are allowed to read platform-defined headers from a message.\n *\n * @category Messaging\n */\nexport enum MessageHeaders {\n  /**\n   * Identifies the sending client instance of a message.\n   * This header is set by the platform when publishing a message or intent.\n   */\n  ClientId = 'CLIENT_ID',\n  /**\n   * Identifies the sending application of a message.\n   * This header is set by the platform when publishing a message or intent.\n   */\n  AppSymbolicName = 'APP_SYMBOLIC_NAME',\n  /**\n   * Unique identity of the message.\n   * This header is set by the platform when publishing a message or intent.\n   */\n  MessageId = 'MESSAGE_ID',\n  /**\n   * Destination to which to send a response to this message.\n   * This header is set by the platform when sending a request.\n   */\n  ReplyTo = 'REPLY_TO',\n  /**\n   * The time the message was sent.\n   * This header is set by the platform when publishing a message or intent.\n   */\n  Timestamp = 'TIMESTAMP',\n  /**\n   * The version of the client.\n   */\n  Version = 'VERSION',\n  /**\n   * Use this header to set the request method to indicate the desired action to be performed for a given resource.\n   * @see RequestMethods\n   */\n  Method = 'METHOD',\n  /**\n   * Use this header to set the response status code to indicate whether a request has been successfully completed.\n   * See {@link ResponseStatusCodes} for available status codes. Other codes are also allowed.\n   *\n   * Status codes are primarily used in request-reply communication. In request-response communication, by default,\n   * the requestors Observable never completes. However, the replier can include the response status code in the replys\n   * headers, allowing to control the lifecycle of the requestors Observable.\n   *\n   * For example, the status code {@link ResponseStatusCodes.TERMINAL 250} allows completing the requestors Observable\n   * after emitted the reply, or the status code {@link ResponseStatusCodes.ERROR 500} to error the Observable.\n   *\n   * Note that the platform evaluates status codes only in request-response communication. They are ignored when observing\n   * topics or intents in pub/sub communication but can still be used; however, they must be handled by the application,\n   * e.g., by using the {@link throwOnErrorStatus} SCION RxJS operator.\n   *\n   * @see ResponseStatusCodes\n   */\n  Status = 'STATUS',\n  /**\n   * Unique identity of a message or intent subscriber.\n   *\n   * @internal\n   */\n  SubscriberId = 'SUBSCRIBER_ID',\n}\n\n/**\n * Defines a set of request methods to indicate the desired action to be performed for a given resource.\n *\n * @category Messaging\n */\nexport enum RequestMethods {\n  /**\n   * The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.\n   */\n  GET = 'GET',\n  /**\n   * The DELETE method deletes the specified resource.\n   */\n  DELETE = 'DELETE',\n  /**\n   * The PUT method replaces all current representations of the target resource with the request payload.\n   */\n  PUT = 'PUT',\n  /**\n   * The POST method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.\n   */\n  POST = 'POST',\n  /**\n   * The OBSERVE method is used to observe the specified resource.\n   */\n  OBSERVE = 'OBSERVE'\n}\n\n/**\n * Defines a set of response status codes to indicate whether a request has been successfully completed.\n *\n * @see throwOnErrorStatus\n * @see MessageClient.request$\n * @see IntentClient.request$\n *\n * @category Messaging\n */\nexport enum ResponseStatusCodes {\n  /**\n   * The request has succeeded.\n   */\n  OK = 200,\n  /**\n   * The request has succeeded. No further response to be expected.\n   *\n   * In request-reply communication, setting this status code will complete the requestor's Observable\n   * after emitted the reply. The reply is only emitted if not `undefined`.\n   */\n  TERMINAL = 250,\n  /**\n   * The receiver could not understand the request due to invalid syntax.\n   *\n   * In request-reply communication, setting this status code will error the requestor's Observable.\n   */\n  BAD_REQUEST = 400,\n  /**\n   * The receiver could not find the requested resource.\n   *\n   * In request-reply communication, setting this status code will error the requestor's Observable.\n   */\n  NOT_FOUND = 404,\n  /**\n   * The receiver encountered an internal error. Optionally, set the error as message payload.\n   *\n   * In request-reply communication, setting this status code will error the requestor's Observable.\n   */\n  ERROR = 500,\n}\n\n/**\n * Returns an Observable that mirrors the source Observable unless receiving a message with\n * a response status code greater than or equal to 400. Then, the stream will end with an\n * {@link RequestError error} and the source Observable unsubscribed.\n *\n * When receiving a message with the response status code {@link ResponseStatusCodes.TERMINAL},\n * the Observable emits this message and completes.\n *\n * If a message does not include a response status code, the message is emitted as is.\n *\n * Note that this operator is installed in {@link MessageClient.request$} and {@link IntentClient.request$}.\n *\n * @category Messaging\n */\nexport function throwOnErrorStatus<BODY>(): MonoTypeOperatorFunction<TopicMessage<BODY>> {\n  return pipe(\n    mergeMap((message: TopicMessage<BODY>): Observable<TopicMessage<BODY>> => {\n      const status = message.headers.get(MessageHeaders.Status) ?? ResponseStatusCodes.OK;\n      if (status < 400) {\n        return of(message); // 1xx: informational responses, 2xx: successful responses, 4xx: client errors, 5xx: server errors\n      }\n\n      if (typeof message.body === 'string') {\n        const messageBody: string = message.body;\n        return throwError(() => new RequestError(messageBody, status, message));\n      }\n\n      switch (status) {\n        case ResponseStatusCodes.BAD_REQUEST: {\n          return throwError(() => new RequestError('The receiver could not understand the request due to invalid syntax.', status, message));\n        }\n        case ResponseStatusCodes.NOT_FOUND: {\n          return throwError(() => new RequestError('The receiver could not find the requested resource.', status, message));\n        }\n        case ResponseStatusCodes.ERROR: {\n          return throwError(() => new RequestError('The receiver encountered an internal error.', status, message));\n        }\n        default: {\n          return throwError(() => new RequestError('Request error.', status, message));\n        }\n      }\n    }),\n    takeWhile((message: TopicMessage<BODY>) => {\n      return message.headers.get(MessageHeaders.Status) !== ResponseStatusCodes.TERMINAL;\n    }, true),\n    filter((message: TopicMessage<BODY>) => {\n      const isTerminalMessage = message.headers.get(MessageHeaders.Status) === ResponseStatusCodes.TERMINAL;\n      return (!isTerminalMessage || message.body !== undefined);\n    }),\n  );\n}\n\n/**\n * Maps each message to its body.\n *\n * @category Messaging\n */\nexport function mapToBody<T>(): OperatorFunction<TopicMessage<T> | IntentMessage<T>, T> {\n  return map(message => message.body!);\n}\n\n/**\n * Indicates that the request handler responded with an error response.\n */\nexport class RequestError extends Error {\n\n  constructor(error: string, public status: number, public msg: Message) {\n    super(error);\n    this.name = 'RequestError';\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Message} from './messaging.model';\nimport {IntentSelector} from './client/messaging/intent-client';\n\n/**\n * Declares the message transports.\n */\nexport enum MessagingTransport {\n  /**\n   * Transport used by clients to communicate with the broker.\n   */\n  ClientToBroker = 'sci://microfrontend-platform/client-to-broker',\n  /**\n   * Transport used by the broker to communicate with its clients.\n   */\n  BrokerToClient = 'sci://microfrontend-platform/broker-to-client',\n  /**\n   * Transport used by a microfrontend to communicate with its embedding outlet.\n   */\n  MicrofrontendToOutlet = 'sci://microfrontend-platform/microfrontend-to-outlet',\n}\n\n/**\n * Defines the channels to which messages can be sent.\n */\nexport enum MessagingChannel {\n  /**\n   * Channel for clients to subscribe to a topic destination.\n   */\n  TopicSubscribe = 'topic-subscribe',\n  /**\n   * Channel for clients to unsubscribe from a topic destination.\n   */\n  TopicUnsubscribe = 'topic-unsubscribe',\n  /**\n   * Channel for clients to subscribe to intents.\n   */\n  IntentSubscribe = 'intent-subscribe',\n  /**\n   * Channel for clients to unsubscribe from intents.\n   */\n  IntentUnsubscribe = 'intent-unsubscribe',\n  /**\n   * Channel for the host to transport topic message to subscribed clients.\n   */\n  Topic = 'topic',\n  /**\n   * Channel for the host to transport intent messages to subscribed clients.\n   */\n  Intent = 'intent',\n  /**\n   * Channel for clients to send a connect request.\n   */\n  ClientConnect = 'client-connect',\n  /**\n   * Channel for clients to send a disconnect request.\n   */\n  ClientDisconnect = 'client-disconnect'\n}\n\n/**\n * Envelope for all messages.\n */\nexport interface MessageEnvelope<MSG extends Message = Message> {\n  transport: MessagingTransport;\n  channel: MessagingChannel;\n  message: MSG;\n}\n\n/**\n * Declares internal platform topics.\n */\nexport namespace PlatformTopics {\n  /**\n   * Allows requesting the subscription count on a topic.\n   */\n  export const RequestSubscriberCount = 'REQUEST_SUBSCRIBER_COUNT';\n  /**\n   * When a client gains the focus it publishes a retained event to this topic.\n   */\n  export const FocusIn = 'FOCUS_IN';\n  /**\n   * Allows testing whether the requester has received focus or contains embedded web content that has received focus.\n   */\n  export const IsFocusWithin = 'IS_FOCUS_WITHIN';\n  /**\n   * Allows reading the platform properties from this retained topic.\n   */\n  export const PlatformProperties = 'PLATFORM_PROPERTIES';\n  /**\n   * Allows reading the registered applications from this retained topic.\n   */\n  export const Applications = 'APPLICATIONS';\n  /**\n   * Computes the topic where a client can publish its heartbeat.\n   */\n  export function heartbeat(clientId: string): string {\n    return `client/${clientId}/heartbeat`;\n  }\n}\n\n/**\n * Sent by the broker in response to a connect request from a client gateway.\n */\nexport interface ConnackMessage {\n  returnCode: 'accepted' | 'refused:bad-request' | 'refused:rejected' | 'refused:blocked';\n  returnMessage?: string;\n  /**\n   * Unique id assigned to the client by the broker. Is only set on success.\n   */\n  clientId?: string;\n  /**\n   * Specifies the interval (in seconds) at which the client must send a heartbeat to indicate to be connected to the host.\n   */\n  heartbeatInterval?: number;\n}\n\nexport interface SubscribeCommand extends Message {\n  /**\n   * Unique identify of the subscriber.\n   */\n  subscriberId: string;\n}\n\nexport interface TopicSubscribeCommand extends SubscribeCommand {\n  /**\n   * Topic to subscribe.\n   */\n  topic: string;\n}\n\nexport interface IntentSubscribeCommand extends SubscribeCommand {\n  /**\n   * Selects intents that match the specified selector and for which the application provides a fulfilling capability.\n   */\n  selector?: IntentSelector;\n}\n\nexport interface UnsubscribeCommand extends Message {\n  /**\n   * Unique identify of the subscriber.\n   */\n  subscriberId: string;\n}\n\nexport interface MessageDeliveryStatus {\n  ok: boolean;\n  details?: string;\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\n/**\n * Provides utilities for working with topics.\n *\n * @internal\n */\nexport namespace Topics {\n\n  /**\n   * Tests whether given topic contains wildcard segments.\n   */\n  export function containsWildcardSegments(topic: string): boolean {\n    return split(topic).some(isWildcardSegment);\n  }\n\n  /**\n   * Tests whether given segment is a wildcard segment.\n   */\n  export function isWildcardSegment(segment: string): boolean {\n    return segment.startsWith(':') && segment.length > 1;\n  }\n\n  /**\n   * Splits given topic into its segments.\n   */\n  export function split(topic: string | null | undefined): string[] {\n    return topic?.split('/').filter(Boolean) ?? [];\n  }\n\n  /**\n   * Returns unnamed wildcard permutations for given exact topic.\n   * These are 2^n variations, where n is the number of segments.\n   *\n   * Example:\n   * Topic: myhome/kitchen/temperature\n   *\n   * +-----------+-----------+-----------*-+\n   * | Segment 1 | Segment 2 | Segment 3   |\n   * +-----------+-----------+-*-----------+\n   * | myhome    | kitchen   | temperature |\n   * | myhome    | kitchen   | *           |\n   * | myhome    | *         | temperature |\n   * | myhome    | *         | *           |\n   * | *         | kitchen   | temperature |\n   * | *         | kitchen   | *           |\n   * | *         | *         | temperature |\n   * | *         | *         | *           |\n   * +-----------+-----------+-------------+\n   */\n  export function computeWildcardSegmentPermutations(topic: string | string[], wildcardCharacter: string): string[] {\n    const segments = typeof topic === 'string' ? Topics.split(topic) : topic;\n\n    if (segments.length === 1) {\n      return [segments[0], wildcardCharacter];\n    }\n\n    return computeWildcardSegmentPermutations(segments.slice(1), wildcardCharacter).reduce((permutations, permutation) => {\n      permutations.push(`${segments[0]}/${permutation}`);\n      permutations.push(`${wildcardCharacter}/${permutation}`);\n      return permutations;\n    }, new Array<string>());\n  }\n\n  /**\n   * Replaces named wildcard segments with given replacement.\n   *\n   * Example: \"myhome/:room/temperature\" => \"myhome/REPLACEMENT/temperature\"\n   *\n   */\n  export function replaceWildcardSegments(topic: string, replacement: string): string {\n    return topic.replace(/:[^/]+/g, replacement);\n  }\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {MonoTypeOperatorFunction, Observable, Subscription} from 'rxjs';\nimport {TopicMessage} from '../../messaging.model';\nimport {first, takeUntil} from 'rxjs/operators';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {PublishOptions, RequestOptions} from './publish-options';\n\n/**\n * Message client for sending and receiving messages between microfrontends across origins.\n *\n * This client implements the topic-based pub/sub (publish/subscribe) messaging model, allowing for one message to be delivered to\n * multiple subscribers using topic addressing.\n *\n * The communication is built on top of the native `postMessage` mechanism. The host app acts as message broker.\n *\n * ### Topic Addressing\n * A publisher publishes a message to a topic, which then is transported to consumers subscribed to the topic. Topics are case-sensitive\n * and consist of one or more segments, each separated by a forward slash. When publishing a message to a topic, the topic must be exact,\n * thus not contain wildcards. Messages published to a topic are transported to all consumers subscribed to the topic. Consumers, on the\n * other hand, can subscribe to multiple topics simultaneously by using wildcard segments in the topic.\n *\n * ### Retained Message\n * You can mark a message as \"retained\" for helping newly subscribed clients to get the last message published to a topic immediately upon\n * subscription. The broker stores one retained message per topic, i.e., a later sent retained message will replace a previously sent retained\n * message. To delete a retained message, send a retained message without payload to the topic.\n *\n * ### Retained Request\n * Unlike retained messages, retained requests are not replaced by later retained requests/messages and remain in the broker until the requestor unsubscribes.\n *\n * ### Request-Response Messaging\n * Sometimes it is useful to initiate a request-response communication to wait for a response. Unlike with fire-and-forget messaging, a temporary\n * inbox is created for the sender to receive replies. If there is no consumer subscribed on the topic, the platform throws an error.\n *\n * @see {@link TopicMessage}\n * @see {@link takeUntilUnsubscribe}\n *\n * @category Messaging\n */\nexport abstract class MessageClient {\n\n  /**\n   * Publishes a message to the given topic. The message is transported to all consumers subscribed to the topic.\n   *\n   * A message can be marked as \"retained\" by setting the {@link PublishOptions.retain} flag to `true`. It instructs the broker to store this message and\n   * deliver it to new subscribers, even if they subscribe after the message has been published. The broker stores one retained message per topic. To\n   * delete a retained message, send a retained message without payload to the topic. Deletion messages are not transported to subscribers.\n   *\n   * @param  topic - Specifies the topic to which the message should be sent.\n   *         Topics are case-sensitive and consist of one or more segments, each separated by a forward slash.\n   *         The topic is required and must be exact, thus not contain wildcards.\n   * @param  message - Specifies optional transfer data to be carried along with this message.\n   *         It can be any object which is serializable with the structured clone algorithm.\n   * @param  options - Controls how to publish the message and allows setting message headers.\n   * @return A Promise that resolves when dispatched the message, or that rejects if the message could not be dispatched.\n   */\n  public abstract publish<T = any>(topic: string, message?: T, options?: PublishOptions): Promise<void>;\n\n  /**\n   * Sends a request to the given topic and receives one or more replies.\n   *\n   * A request can be marked as \"retained\" by setting the {@link RequestOptions.retain} flag to `true`. It instructs the broker to store this request and\n   * deliver it to new subscribers, even if they subscribe after the request has been sent. Retained requests are not replaced by later retained requests/\n   * messages and remain in the broker until the requestor unsubscribes.\n   *\n   * If not marking the request as \"retained\", at least one subscriber must be subscribed to the topic. Otherwise, the request is rejected.\n   *\n   * @param  topic - Specifies the topic to which the request should be sent.\n   *         Topics are case-sensitive and consist of one or more segments, each separated by a forward slash.\n   *         The topic is required and must be exact, thus not contain wildcards.\n   * @param  request - Specifies optional transfer data to be carried along with the request.\n   *         It can be any object which is serializable with the structured clone algorithm.\n   * @param  options - Controls how to send the request and allows setting request headers.\n   * @return An Observable that emits when receiving a reply. It never completes unless the replier sets the status code {@link ResponseStatusCodes.TERMINAL}\n   *         in the {@link MessageHeaders.Status} message header. Then, the Observable completes immediately after emitted the reply.\n   *         The Observable errors if the request could not be dispatched. It will also error if the replier sets a status code greater than or equal to 400, e.g., {@link ResponseStatusCodes.ERROR}.\n   */\n  public abstract request$<T>(topic: string, request?: any, options?: RequestOptions): Observable<TopicMessage<T>>;\n\n  /**\n   * Receives messages published to the given topic.\n   *\n   * You can subscribe to multiple topics simultaneously by using wildcard segments in the topic. If a segment begins with a colon (`:`),\n   * then the segment acts as a placeholder for any segment value. Substituted segment values are then available via the params property\n   * of the received message.\n   *\n   * ```ts\n   * const topic: string = 'myhome/:room/temperature';\n   *\n   * Beans.get(MessageClient).observe$(topic).subscribe((message: TopicMessage) => {\n   *   console.log(message.params);\n   * });\n   * ```\n   *\n   * If the received message has the {@link MessageHeaders.ReplyTo} header field set, the publisher expects the receiver to send one or more\n   * replies to that {@link MessageHeaders.ReplyTo ReplyTo} topic. If streaming responses, you can use the {@link takeUntilUnsubscribe}\n   * operator to stop replying when the requestor unsubscribes.\n   *\n   * ```ts\n   * const topic: string = 'myhome/livingroom/temperature';\n   *\n   * Beans.get(MessageClient).observe$(topic).subscribe((request: TopicMessage) => {\n   *   const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n   *   sensor$\n   *     .pipe(takeUntilUnsubscribe(replyTo))\n   *     .subscribe(temperature => {\n   *       Beans.get(MessageClient).publish(replyTo, `${temperature}C`);\n   *     });\n   * });\n   * ```\n   *\n   * @param  topic - Specifies the topic which to observe.\n   *         Topics are case-sensitive and consist of one or more segments, each separated by a forward slash.\n   *         You can subscribe to the exact topic of a published message, or use wildcards to subscribe to multiple\n   *         topics simultaneously. If a segment begins with a colon (`:`), then the segment acts as a placeholder for any\n   *         string value. Substituted segment values are available in the {@link TopicMessage.params} on the received message.\n   * @return An Observable that emits messages sent to the given topic. It never completes.\n   */\n  public abstract observe$<T>(topic: string): Observable<TopicMessage<T>>;\n\n  /**\n   * Convenience API for handling messages.\n   *\n   * Unlike `observe$`, messages are passed to a callback function rather than emitted from an Observable. Response(s) can be returned directly\n   * from the callback. It supports error propagation and request termination. Using this method over `observe$` significantly reduces the code\n   * required to respond to requests.\n   *\n   * For each message received, the specified callback function is called. When used in request-response communication,\n   * the callback function can return the response either directly or in the form of a Promise or Observable. Returning a Promise\n   * allows the response to be computed asynchronously, and an Observable allows to return one or more responses, e.g., for\n   * streaming data.\n   * If the callback function returns no value (void), returns `undefined`, or returns a Promise that resolves to `undefined`, communication is terminated\n   * immediately without a response. If the callback returns an Observable, all its emissions are transported to the requestor and communication is not\n   * terminated until the Observable completes. Termination of communication always completes the requestor's Observable.\n   * If the callback throws an error, or the returned Promise or Observable errors, the error is\n   * transported to the requestor, erroring the requestor's Observable.\n   *\n   * @param  topic - Specifies the topic which to observe.\n   *         For more information, see the API description of {@link observe$}.\n   * @param  callback - Specifies the callback to be called for each message. When used in request-response communication,\n   *         the callback function can return the response either directly or in the form of a Promise or Observable. If returning\n   *         a response in fire-and-forget communication, it is ignored. Throwing an error in the callback does not unregister the callback.\n   * @return Subscription to unregister the callback. Calling {@link rxjs!Subscription.unsubscribe Subscription.unsubscribe} will complete the Observable of all\n   *         requestors, if any.\n   */\n  public abstract onMessage<IN = any, OUT = any>(topic: string, callback: (message: TopicMessage<IN>) => Observable<OUT> | Promise<OUT> | OUT | void): Subscription;\n\n  /**\n   * Allows observing the number of subscriptions on a topic. The Observable never completes.\n   *\n   * @param  topic - Specifies the topic to observe. The topic must be exact, thus not contain wildcards.\n   * @return An Observable that, when subscribed, emits the current number of subscribers on it. It never completes and\n   *         emits continuously when the number of subscribers changes.\n   */\n  public abstract subscriberCount$(topic: string): Observable<number>;\n}\n\n/**\n * Returns an Observable that mirrors the source Observable as long as there is at least one subscriber subscribed to the\n * given topic. When the subscription count on the given topic drops to zero, the returned Observable completes. If there\n * is no topic subscription present at the time when subscribing to the Observable, then it completes immediately.\n *\n * This operator is similar to the RxJS {@link rxjs!takeUntil takeUntil} operator, but accepts a topic instead of a notifier Observable.\n *\n * @category Messaging\n */\nexport function takeUntilUnsubscribe<T>(topic: string): MonoTypeOperatorFunction<T> {\n  return takeUntil(Beans.get(MessageClient).subscriberCount$(topic).pipe(first(count => count === 0)));\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Arrays} from '@scion/toolkit/util';\nimport {Topics} from './topics.util';\n\n/**\n * Allows testing whether an exact topic matches a pattern topic. The pattern topic may contain wildcard segments.\n *\n * Topics are case-sensitive and consist of one or more segments, each separated by a forward slash.\n */\nexport class TopicMatcher {\n\n  private readonly _patternSegments: string[];\n\n  /**\n   * Constructs a matcher that will match given topics against this pattern.\n   *\n   * @param pattern - Pattern to match topics. The pattern is a topic, not a regular expression; thus, it must consist of one or more segments,\n   *                  each separated by a forward slash. The pattern supports wildcard segments beginning with a colon (`:`). Wildcard segments\n   *                  act as a placeholder for any segment value.\n   */\n  constructor(pattern: string) {\n    this._patternSegments = Topics.split(pattern);\n    if (!this._patternSegments.length) {\n      throw Error('[TopicMatcherError] Invalid pattern syntax. The pattern must consist of one or more topic segments, each separated by a forward slash.');\n    }\n  }\n\n  /**\n   * Attempts to match the given topic against the pattern which was passed to the constructor.\n   *\n   * If the match succeeds, then {@link MatcherResult.matches} evaluates to `true`. If the pattern contains wildcard segments,\n   * the matched segments can be read using the property {@link TopicMessage.params} property.\n   *\n   * @param topic - The topic to match against the configured pattern; must be an exact topic, thus not contain wildcard segments.\n   * @return The result of the topic matcher test.\n   */\n  public match(topic: string): MatcherResult {\n    const inputTopicSegments = Topics.split(topic);\n    const patternSegments = this._patternSegments;\n\n    if (!inputTopicSegments.length) {\n      throw Error('[TopicMatcherError] Invalid topic. The topic must consist of one or more segments, each separated by a forward slash.');\n    }\n    if (inputTopicSegments.some(Topics.isWildcardSegment)) {\n      throw Error('[TopicMatcherError] Invalid topic. Wildcard segments not allowed in an exact topic.');\n    }\n    if (patternSegments.length !== inputTopicSegments.length) {\n      return {matches: false};\n    }\n    if (Arrays.isEqual(inputTopicSegments, patternSegments, {exactOrder: true})) {\n      return {matches: true, params: new Map()};\n    }\n    if (!patternSegments.some(Topics.isWildcardSegment)) {\n      return {matches: false};\n    }\n    if (!patternSegments.every((patternSegment, i) => patternSegment === inputTopicSegments[i] || Topics.isWildcardSegment(patternSegment))) {\n      return {matches: false};\n    }\n\n    return {\n      matches: true,\n      params: patternSegments.reduce((params, segment, i) => {\n        if (Topics.isWildcardSegment(segment)) {\n          return params.set(segment.substring(1), inputTopicSegments[i]);\n        }\n        return params;\n      }, new Map()),\n    };\n  }\n}\n\n/**\n * Represents the result of a topic matcher test.\n */\nexport interface MatcherResult {\n  /**\n   * Indicates if the topic matches the pattern topic.\n   */\n  matches: boolean;\n  /**\n   * Contains the actual values for the wildcard segments as defined in the pattern topic; is only set if the match is successful.\n   */\n  params?: Map<string, string>;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {MonoTypeOperatorFunction, OperatorFunction, pipe} from 'rxjs';\nimport {filter, map} from 'rxjs/operators';\nimport {MessageEnvelope, MessagingChannel, MessagingTransport} from './messaging.model';\nimport {Message, TopicMessage} from './messaging.model';\nimport {TopicMatcher} from './topic-matcher.util';\nimport {Arrays} from '@scion/toolkit/util';\n\n/** @ignore */\nexport function filterByTransport(transport: MessagingTransport): OperatorFunction<MessageEvent, MessageEvent<MessageEnvelope>> {\n  return filter((event: MessageEvent): event is MessageEvent<MessageEnvelope> => {\n    const envelope: MessageEnvelope | undefined = event.data;\n    return envelope?.transport === transport && !!envelope.channel && !!envelope.message?.headers;\n  });\n}\n\n/** @ignore */\nexport function filterByChannel<T extends Message>(...channel: MessagingChannel[]): OperatorFunction<MessageEvent<MessageEnvelope>, MessageEvent<MessageEnvelope<T>>> {\n  const channels = new Set(Arrays.coerce(channel));\n  return filter((event: MessageEvent<MessageEnvelope>): event is MessageEvent<MessageEnvelope<T>> => {\n    return channels.has(event.data.channel);\n  });\n}\n\n/** @ignore */\nexport function filterByTopicChannel<T>(topic: string): OperatorFunction<MessageEvent<MessageEnvelope>, MessageEvent<MessageEnvelope<TopicMessage<T>>>> {\n  return pipe(\n    filterByChannel<TopicMessage<T>>(MessagingChannel.Topic),\n    filter((event: MessageEvent<MessageEnvelope<TopicMessage<T>>>): boolean => {\n      const messageTopic = event.data.message.topic;\n      return !!messageTopic && new TopicMatcher(topic).match(messageTopic).matches;\n    }),\n  );\n}\n\n/** @ignore */\nexport function filterByOrigin(origin: string): MonoTypeOperatorFunction<MessageEvent> {\n  return filter((event: MessageEvent): boolean => {\n    return event.origin === origin;\n  });\n}\n\n/** @ignore */\nexport function filterByWindow(window: Window): MonoTypeOperatorFunction<MessageEvent> {\n  return filter((event: MessageEvent): boolean => {\n    return event.source === window;\n  });\n}\n\n/** @ignore */\nexport function filterByMessageHeader<T extends Message>(header: {name: string; value: any}): MonoTypeOperatorFunction<MessageEvent<MessageEnvelope<T>>> {\n  return filter((event: MessageEvent<MessageEnvelope<T>>): boolean => {\n    const messageHeaders = event.data.message.headers;\n    return messageHeaders.has(header.name) && messageHeaders.get(header.name) === header.value;\n  });\n}\n\n/** @ignore */\nexport function pluckMessage<T extends Message>(): OperatorFunction<MessageEvent<MessageEnvelope<T>>, T> {\n  return map((messageEvent: MessageEvent<MessageEnvelope<T>>): T => {\n    return messageEvent.data.message;\n  });\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {APP_IDENTITY, VERSION} from './platform.model';\n\n/**\n * Logger used by the platform to log to the console.\n *\n * Replace this bean to capture the log output.\n *\n * @category Platform\n */\nexport abstract class Logger {\n\n  /**\n   * Logs with severity debug.\n   */\n  public abstract debug(message?: any, ...args: any[]): void;\n\n  /**\n   * Logs with severity info.\n   */\n  public abstract info(message?: any, ...args: any[]): void;\n\n  /**\n   * Logs with severity warn.\n   */\n  public abstract warn(message?: any, ...args: any[]): void;\n\n  /**\n   * Logs with severity error.\n   */\n  public abstract error(message?: any, ...args: any[]): void;\n}\n\n/**\n * Logger used by the platform to log to the console.\n *\n * Replace this bean to capture the log output.\n *\n * @internal\n */\nexport class ConsoleLogger implements Logger {\n\n  public debug(message?: any, ...args: any[]): void {\n    this.log('debug', message, args);\n  }\n\n  public info(message?: any, ...args: any[]): void {\n    this.log('info', message, args);\n  }\n\n  public warn(message?: any, ...args: any[]): void {\n    this.log('warn', message, args);\n  }\n\n  public error(message?: any, ...args: any[]): void {\n    this.log('error', message, args);\n  }\n\n  private log(severity: 'debug' | 'info' | 'warn' | 'error', message: any, args: any[]): void {\n    const loggingContext: LoggingContext = args[0] instanceof LoggingContext ? args.shift() : {appSymbolicName: Beans.get(APP_IDENTITY), version: Beans.get(VERSION)};\n    const prefix = new Array<string>()\n      .concat(loggingContext.version ? `[@scion/microfrontend-platform@${loggingContext.version}]` : '[@scion/microfrontend-platform]')\n      .concat(`[${loggingContext.appSymbolicName}]`)\n      .join('');\n\n    if (console && typeof console[severity] === 'function') {\n      const consoleFn = console[severity];\n      args?.length ? consoleFn(`${prefix} ${message}`, ...args) : consoleFn(`${prefix} ${message}`);\n    }\n  }\n}\n\n/**\n * Logger that does nothing.\n *\n * @ignore\n */\nexport const NULL_LOGGER = new class extends Logger {\n\n  public debug(message?: any, ...args: any[]): void {\n    // NOOP\n  }\n\n  public info(message?: any, ...args: any[]): void {\n    // NOOP\n  }\n\n  public warn(message?: any, ...args: any[]): void {\n    // NOOP\n  }\n\n  public error(message?: any, ...args: any[]): void {\n    // NOOP\n  }\n};\n\n/**\n * Contextual information to add to the log message.\n *\n * Pass an instance of this class as the first argument to the logger when logging a message.\n */\nexport class LoggingContext {\n\n  constructor(public appSymbolicName: string, public version?: string) {\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\n/**\n * Lifecycle states of the microfrontend platform.\n *\n * @category Platform\n */\nexport enum PlatformState {\n  /**\n   * Indicates that the platform is about to start.\n   */\n  Starting = 1,\n  /**\n   * Indicates that the platform started.\n   */\n  Started = 2,\n  /**\n   * Indicates that the platform is about to stop.\n   */\n  Stopping = 3,\n  /**\n   * Indicates that the platform is not yet started.\n   */\n  Stopped = 4,\n}\n\n/**\n * Runlevels are used to control in which startup phase to execute initializers when starting the platform.\n *\n * The platform reports that it has started after all initializers have completed successfully.\n */\nexport enum Runlevel {\n  /**\n   * In runlevel 0, the platform host fetches manifests of registered micro applications.\n   */\n  Zero = 0,\n  /**\n   * In runlevel 1, the platform constructs eager beans.\n   */\n  One = 1,\n  /**\n   * From runlevel 2 and above, messaging is enabled. This is the default runlevel at which initializers execute if not specifying any runlevel.\n   */\n  Two = 2,\n  /**\n   * In runlevel 3, the platform host installs activator microfrontends.\n   */\n  Three = 3,\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {AsyncSubject, EMPTY, firstValueFrom, fromEvent, interval, lastValueFrom, merge, MonoTypeOperatorFunction, NEVER, noop, Observable, Observer, of, ReplaySubject, Subject, TeardownLogic, throwError, timeout, timer} from 'rxjs';\nimport {ConnackMessage, MessageDeliveryStatus, MessageEnvelope, MessagingChannel, MessagingTransport, PlatformTopics, SubscribeCommand, UnsubscribeCommand} from '../../messaging.model';\nimport {finalize, map, mergeMap, take, takeUntil, tap} from 'rxjs/operators';\nimport {filterByChannel, filterByMessageHeader, filterByOrigin, filterByTopicChannel, filterByTransport, filterByWindow, pluckMessage} from '../../operators';\nimport {UUID} from '@scion/toolkit/uuid';\nimport {IntentMessage, Message, MessageHeaders, TopicMessage} from '../../messaging.model';\nimport {Logger, NULL_LOGGER} from '../../logger';\nimport {Dictionaries} from '@scion/toolkit/util';\nimport {Beans, Initializer, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {APP_IDENTITY, IS_PLATFORM_HOST, VERSION, WINDOW_TOP} from '../../platform.model';\nimport {PlatformState} from '../../platform-state';\nimport {ConnectOptions} from '../connect-options';\nimport {MicrofrontendPlatformRef} from '../../microfrontend-platform-ref';\nimport {MessageClient} from '../../client/messaging/message-client';\nimport {runSafe} from '../../safe-runner';\nimport {stringifyError} from '../../error.util';\n\n/**\n * The gateway is responsible for dispatching messages between the client and the broker.\n *\n * To initiate a connection, the gateway sends a CONNECT message to the current and all parent windows. When the broker window\n * receives the CONNECT message, the broker responds with a CONNACK message. If no CONNACK message is received within the discovery\n * timeout, the gateway errors. When the gateway is being disposed, it sends a DISCONNECT message to the broker.\n *\n * @ignore\n */\nexport abstract class BrokerGateway {\n\n  /**\n   * Returns whether this gateway is connected to the message broker. It never throws a broker discovery timeout error.\n   */\n  public abstract isConnected(): Promise<boolean>;\n\n  /**\n   * Posts a message to the message broker. If not connected to the broker yet, waits posting the message\n   * until established the connection to the broker.\n   *\n   * @return a Promise that resolves when successfully posted the message to the broker, or that rejects otherwise.\n   */\n  public abstract postMessage(channel: MessagingChannel, message: Message): Promise<void>;\n\n  /**\n   * Posts a message to the message broker and receives replies. The Observable never completes.\n   */\n  public abstract requestReply$<T = any>(channel: MessagingChannel, message: IntentMessage | TopicMessage): Observable<TopicMessage<T>>;\n\n  /**\n   * Subscribes to described destination, unless the platform has been stopped at the time of subscription.\n   */\n  public abstract subscribe$<T extends Message>(subscriptionDescriptor: SubscriptionDescriptor): Observable<T>;\n\n  /**\n   * An Observable that emits when a message from the message broker is received.\n   */\n  public abstract get message$(): Observable<MessageEvent<MessageEnvelope>>;\n}\n\n/**\n * Broker gateway that does nothing.\n *\n * Use this gateway in tests to not connect to the platform host.\n *\n * @ignore\n */\nexport class NullBrokerGateway implements BrokerGateway {\n\n  constructor() {\n    console.log('[NullBrokerGateway] Using \\'NullBrokerGateway\\'. Messages cannot be sent or received.');\n  }\n\n  public isConnected(): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n\n  public get message$(): Observable<MessageEvent<MessageEnvelope>> {\n    return NEVER;\n  }\n\n  public async postMessage(channel: MessagingChannel, message: Message): Promise<void> {\n    return Promise.resolve();\n  }\n\n  public requestReply$<T = any>(channel: MessagingChannel, message: IntentMessage | TopicMessage): Observable<TopicMessage<T>> {\n    return NEVER;\n  }\n\n  public subscribe$<T extends Message>(subscriptionDescriptor: SubscriptionDescriptor): Observable<T> {\n    return NEVER;\n  }\n}\n\n/**\n * @ignore\n */\nexport class BrokerGateway implements BrokerGateway, PreDestroy, Initializer {\n\n  /*\n   * This Observable is primarily used as a notifier for the `takeUntil` operator to complete Observable subscriptions when the platform is shutting down.\n   * Since some subscriptions trigger subsequent broker interactions, e.g., unsubscribing from a topic subscription, the notifier must \"replay\" its state\n   * to avoid waiting for broker responses, which would never arrive and otherwise cause timeout errors.\n   */\n  private _platformStopping$ = new ReplaySubject<void>(1);\n  private _appSymbolicName: string;\n  private _brokerDiscoverTimeout: number;\n  private _messageDeliveryTimeout: number;\n  private _session: Session | null = null;\n  private _session$ = new AsyncSubject<Session>();\n\n  public readonly message$ = new Subject<MessageEvent<MessageEnvelope>>();\n\n  constructor(connectOptions?: ConnectOptions) {\n    this._appSymbolicName = Beans.get<string>(APP_IDENTITY);\n    this._brokerDiscoverTimeout = connectOptions?.brokerDiscoverTimeout ?? 10_000;\n    this._messageDeliveryTimeout = connectOptions?.messageDeliveryTimeout ?? 10_000;\n  }\n\n  public async init(): Promise<void> {\n    try {\n      const session = await this.connectToBroker();\n      this.installBrokerMessageListener(session);\n      this.installHeartbeatPublisher(session);\n      this._session = session;\n      this._session$.next(session);\n      this._session$.complete();\n    }\n    catch (error) {\n      this._session$.error(error);\n      throw error;\n    }\n  }\n\n  public isConnected(): Promise<boolean> {\n    return lastValueFrom(this._session$).then(() => true).catch(() => false);\n  }\n\n  public get session(): Session | null {\n    return this._session;\n  }\n\n  public async postMessage(channel: MessagingChannel, message: Message): Promise<void> {\n    if (isPlatformStopped()) {\n      throw GatewayErrors.PLATFORM_STOPPED_ERROR;\n    }\n\n    // If not connected to the broker, wait until connected. If connected, continue execution immediately\n    // without spawning a microtask. Otherwise, messages cannot be published during platform shutdown.\n    const session = this._session || await lastValueFrom(this._session$);\n\n    const messageId = UUID.randomUUID();\n    const envelope: MessageEnvelope = {\n      transport: MessagingTransport.ClientToBroker,\n      channel: channel,\n      message: message,\n    };\n    envelope.message.headers\n      .set(MessageHeaders.MessageId, messageId)\n      .set(MessageHeaders.Timestamp, Date.now())\n      .set(MessageHeaders.AppSymbolicName, this._appSymbolicName)\n      .set(MessageHeaders.ClientId, session.clientId);\n\n    // Install Promise that resolves once the broker has acknowledged the message, or that rejects otherwise.\n    const postError$ = new Subject<never>();\n    const whenPosted = new Promise<void>((resolve, reject) => {\n      merge(this.message$, postError$)\n        .pipe(\n          filterByTopicChannel<MessageDeliveryStatus>(messageId),\n          take(1),\n          pluckMessage(),\n          timeout({first: this._messageDeliveryTimeout, with: () => throwError(() => GatewayErrors.MESSAGE_DISPATCH_ERROR(this._messageDeliveryTimeout, envelope))}),\n          mergeMap(statusMessage => statusMessage.body!.ok ? EMPTY : throwError(() => Error(statusMessage.body!.details))),\n          takeUntil(this._platformStopping$),\n        )\n        .subscribe({\n          error: reject,\n          complete: resolve,\n        });\n    });\n\n    try {\n      session.broker.window.postMessage(envelope, session.broker.origin);\n    }\n    catch (error) {\n      postError$.error(error);\n    }\n\n    await whenPosted;\n  }\n\n  public requestReply$<T = any>(channel: MessagingChannel, request: IntentMessage | TopicMessage): Observable<TopicMessage<T>> {\n    return new Observable((observer: Observer<TopicMessage>): TeardownLogic => {\n      if (isPlatformStopped()) {\n        observer.error(GatewayErrors.PLATFORM_STOPPED_ERROR);\n        return noop;\n      }\n\n      const replyTo = UUID.randomUUID();\n      const subscriberId = UUID.randomUUID();\n      const unsubscribe$ = new Subject<void>();\n      const requestError$ = new Subject<never>();\n\n      request.headers\n        .set(MessageHeaders.ReplyTo, replyTo) // message header for the replier where to send replies to\n        .set(MessageHeaders.SubscriberId, subscriberId); // message header to subscribe for replies\n\n      // Receive replies sent to the reply topic.\n      merge(this.message$, requestError$)\n        .pipe(\n          filterByChannel<TopicMessage<T>>(MessagingChannel.Topic),\n          filterByMessageHeader({name: MessageHeaders.SubscriberId, value: subscriberId}),\n          pluckMessage(),\n          takeUntil(merge(this._platformStopping$, unsubscribe$)),\n          finalize(() => this.unsubscribe({unsubscribeChannel: MessagingChannel.TopicUnsubscribe, subscriberId, logContext: `[subscriberId=${subscriberId}, topic=${replyTo}]`})),\n        )\n        .subscribe({\n          next: reply => observer.next(reply),\n          error: error => observer.error(error),\n          complete: noop, // As per the API, the Observable never completes.\n        });\n\n      // Post the request to the broker.\n      this.postMessage(channel, request)\n        .catch(error => requestError$.error(error));\n\n      return (): void => unsubscribe$.next();\n    });\n  }\n\n  public subscribe$<T extends Message>(subscriptionDescriptor: SubscriptionDescriptor): Observable<T> {\n    const {messageChannel, subscribeChannel, unsubscribeChannel, newSubscribeCommand} = subscriptionDescriptor;\n\n    return new Observable((observer: Observer<T>): TeardownLogic => {\n      if (isPlatformStopped()) {\n        observer.error(GatewayErrors.PLATFORM_STOPPED_ERROR);\n        return noop;\n      }\n\n      const subscriberId = UUID.randomUUID();\n      const unsubscribe$ = new Subject<void>();\n      const subscribeError$ = new Subject<never>();\n\n      // Receive messages of given subscription.\n      merge(this.message$, subscribeError$)\n        .pipe(\n          filterByChannel<T>(messageChannel),\n          filterByMessageHeader({name: MessageHeaders.SubscriberId, value: subscriberId}),\n          pluckMessage(),\n          takeUntil(merge(this._platformStopping$, unsubscribe$)),\n          finalize(() => this.unsubscribe({unsubscribeChannel, subscriberId, logContext: JSON.stringify(newSubscribeCommand(subscriberId))})),\n        )\n        .subscribe({\n          next: message => observer.next(message),\n          error: error => observer.error(error),\n          complete: noop, // As per the API, the Observable never completes.\n        });\n\n      // Post the subscription to the broker.\n      this.postMessage(subscribeChannel, newSubscribeCommand(subscriberId))\n        .catch(error => subscribeError$.error(error));\n\n      return (): void => unsubscribe$.next();\n    });\n  }\n\n  /**\n   * Unsubscribes from described destination. Does nothing if the platform is stopped.\n   */\n  private async unsubscribe(descriptor: {unsubscribeChannel: MessagingChannel; subscriberId: string; logContext: string}): Promise<void> {\n    if (isPlatformStopped()) {\n      return;\n    }\n\n    const {unsubscribeChannel, subscriberId, logContext} = descriptor;\n    const unsubscribeCommand: UnsubscribeCommand = {subscriberId, headers: new Map()};\n    try {\n      await this.postMessage(unsubscribeChannel, unsubscribeCommand);\n    }\n    catch (error) {\n      Beans.get(Logger, {orElseGet: NULL_LOGGER}).error(`[UnsubscribeError] Failed to unsubscribe from destination: '${logContext}'. Caused by: ${error}`);  // Fall back using NULL_LOGGER, e.g., when the platform is stopping.\n    }\n  }\n\n  /**\n   * Subscribes to messages sent to this client.\n   * Messages are dispatched to {@link message$}.\n   */\n  private installBrokerMessageListener(session: Session): void {\n    fromEvent<MessageEvent>(window, 'message')\n      .pipe(\n        filterByWindow(session.broker.window),\n        filterByOrigin(session.broker.origin),\n        filterByTransport(MessagingTransport.BrokerToClient),\n        fixMapObjects(),\n        takeUntil(this._platformStopping$),\n      )\n      .subscribe(this.message$);\n  }\n\n  /**\n   * Installs a scheduler that periodically sends a heartbeat to indicate that this client is connected to the host.\n   *\n   * Note that no heartbeat scheduler is installed if running in the context of the host application.\n   */\n  private installHeartbeatPublisher(session: Session): void {\n    if (Beans.get(IS_PLATFORM_HOST)) {\n      return; // The host app client does not send a heartbeat.\n    }\n    interval(session.heartbeatInterval)\n      .pipe(takeUntil(this._platformStopping$))\n      .subscribe(() => runSafe(() => {\n        Beans.get(MessageClient).publish(PlatformTopics.heartbeat(session.clientId)).then();\n      }));\n  }\n\n  /**\n   * Connects this client to the broker by sending a CONNECT message to the current and all parent windows.\n   *\n   * When the broker receives the CONNECT message and trusts this client, the broker responds with a CONNACK message,\n   * or rejects the connect attempt otherwise.\n   *\n   * @return A Promise that, when connected, resolves to information about the connected client and broker, or that rejects if the connect attempt\n   * failed, either because the broker could not be found or because the application is not allowed to connect.\n   */\n  public connectToBroker(): Promise<Session> {\n    const replyTo = UUID.randomUUID();\n    const connectPromise = firstValueFrom(fromEvent<MessageEvent>(window, 'message')\n      .pipe(\n        filterByTransport(MessagingTransport.BrokerToClient),\n        filterByTopicChannel<ConnackMessage>(replyTo),\n        mergeMap((messageEvent: MessageEvent<MessageEnvelope<TopicMessage<ConnackMessage>>>) => {\n          const response: ConnackMessage | undefined = messageEvent.data.message.body;\n          if (response?.returnCode !== 'accepted') {\n            return throwError(() => Error(`${response?.returnMessage ?? 'UNEXPECTED: Empty broker discovery response'} [code: '${response?.returnCode ?? 'n/a'}']`));\n          }\n          return of<Session>({\n            clientId: response.clientId!,\n            heartbeatInterval: response.heartbeatInterval!,\n            broker: {\n              window: messageEvent.source as Window,\n              origin: messageEvent.origin,\n            },\n          });\n        }),\n        timeout({first: this._brokerDiscoverTimeout, with: () => throwError(() => GatewayErrors.BROKER_DISCOVER_ERROR(this._brokerDiscoverTimeout))}),\n        tap({error: error => Beans.get(Logger, {orElseGet: NULL_LOGGER}).error(stringifyError(error))}), // Fall back using NULL_LOGGER, e.g., when the platform is stopping.\n        takeUntil(this._platformStopping$),\n      ));\n\n    const connectMessage: MessageEnvelope = {\n      transport: MessagingTransport.ClientToBroker,\n      channel: MessagingChannel.ClientConnect,\n      message: {\n        headers: new Map()\n          .set(MessageHeaders.MessageId, UUID.randomUUID())\n          .set(MessageHeaders.Timestamp, Date.now())\n          .set(MessageHeaders.AppSymbolicName, this._appSymbolicName)\n          .set(MessageHeaders.ReplyTo, replyTo)\n          .set(MessageHeaders.Version, Beans.get(VERSION)),\n      },\n    };\n\n    if (Beans.get(IS_PLATFORM_HOST)) {\n      window.postMessage(connectMessage, window.origin);\n    }\n    else if (window === Beans.get(WINDOW_TOP)) {\n      // If loading the client into the topmost window it may be integrated into a rich client, with the host running in a different browser window (remote host).\n      // The rich client then bridges messages between the windows of the client and the remote host. Since the rich client may not be able to bridge messages\n      // right away when the client loads, the client repeatedly sends a connect request until acknowledged by the remote host.\n      const windowHierarchy = this.collectWindowHierarchy();\n      timer(0, 25)\n        .pipe(takeUntil(connectPromise.catch(() => null)))\n        .subscribe(() => {\n          windowHierarchy.forEach(window => window.postMessage(connectMessage, '*'));\n        });\n    }\n    else {\n      this.collectWindowHierarchy().forEach(window => window.postMessage(connectMessage, '*'));\n    }\n\n    return connectPromise;\n  }\n\n  /**\n   * Disconnects this client from the broker by sending a DISCONNECT message.\n   * Has no effect if not connected to the broker. If this operation fails, the error is logged as\n   * a warning, but not thrown.\n   */\n  private disconnectFromBroker(): void {\n    if (!this._session) {\n      return;\n    }\n\n    const disconnectMessage: MessageEnvelope = {\n      transport: MessagingTransport.ClientToBroker,\n      channel: MessagingChannel.ClientDisconnect,\n      message: {\n        headers: new Map()\n          .set(MessageHeaders.MessageId, UUID.randomUUID())\n          .set(MessageHeaders.Timestamp, Date.now())\n          .set(MessageHeaders.AppSymbolicName, this._appSymbolicName)\n          .set(MessageHeaders.ClientId, this._session.clientId),\n      },\n    };\n\n    try {\n      this._session.broker.window.postMessage(disconnectMessage, this._session.broker.origin);\n    }\n    catch (error) {\n      Beans.get(Logger, {orElseGet: NULL_LOGGER}).warn(`[ClientDisconnectError] Failed to disconnect from the broker. Caused by: ${error}`);\n    }\n  }\n\n  /**\n   * Returns an array of the current `Window` hierarchy.\n   * Windows are sorted in top-down order, i.e., parent windows precede child windows.\n   */\n  private collectWindowHierarchy(): Window[] {\n    const candidates: Window[] = [];\n\n    for (let candidate = window as Window; candidate !== Beans.get(WINDOW_TOP); candidate = candidate.parent) {\n      candidates.unshift(candidate);\n    }\n\n    candidates.unshift(Beans.get<Window>(WINDOW_TOP));\n    return candidates;\n  }\n\n  /**\n   * Method invoked when the platform enters state {@link PlatformState.Stopping}.\n   *\n   * Since this gateway is registered in the bean manager with the maximum destruction order `{destroyOrder: Number.MAX_SAFE_INTEGER}`,\n   * the platform will destroy this bean after destroying other beans, which is important so that other beans can send messages\n   * when the platform shuts down.\n   */\n  public preDestroy(): void {\n    this.disconnectFromBroker();\n    this._platformStopping$.next();\n  }\n}\n\n/**\n * Replaces `Map` objects contained in the message with a `Map` object of the current JavaScript realm.\n *\n * Data sent from one JavaScript realm to another is serialized with the structured clone algorithm.\n * Although the algorithm supports the `Map` data type, a deserialized map object cannot be checked to be instance of `Map`.\n * This is most likely because the serialization takes place in a different realm.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n * @see http://man.hubwiz.com/docset/JavaScript.docset/Contents/Resources/Documents/developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm.html\n * @internal\n */\nfunction fixMapObjects<T extends Message>(): MonoTypeOperatorFunction<MessageEvent<MessageEnvelope<T>>> {\n  return map((event: MessageEvent<MessageEnvelope<T>>): MessageEvent<MessageEnvelope<T>> => {\n    const envelope: MessageEnvelope = event.data;\n    envelope.message.headers = new Map(envelope.message.headers || []);\n\n    if (envelope.channel === MessagingChannel.Intent) {\n      const intentMessage = envelope.message as IntentMessage;\n      intentMessage.intent.params = new Map(intentMessage.intent.params || []);\n    }\n    if (envelope.channel === MessagingChannel.Topic) {\n      const topicMessage = envelope.message as TopicMessage;\n      topicMessage.params = new Map(topicMessage.params || []);\n    }\n    return event;\n  });\n}\n\n/**\n * Creates a string representation of the given {@link MessageEnvelope}.\n */\nfunction stringifyEnvelope(envelope: MessageEnvelope): string {\n  return JSON.stringify(envelope, (key, value) => (value instanceof Map) ? Dictionaries.coerce(value) : value);\n}\n\nfunction isPlatformStopped(): boolean {\n  const platformState = Beans.opt(MicrofrontendPlatformRef);\n  if (!platformState) {\n    return true; // platform is destroyed\n  }\n  return platformState.state >= PlatformState.Stopped;\n}\n\n/**\n * Session created after successful connection with the broker.\n *\n * @ignore\n */\ninterface Session {\n  clientId: string;\n  heartbeatInterval: number;\n  broker: {\n    origin: string;\n    window: Window;\n  };\n}\n\n/** @ignore*/\nnamespace GatewayErrors {\n\n  export const PLATFORM_STOPPED_ERROR = Error('[GatewayError] Platform is stopped. Messages cannot be published or received.');\n\n  export function MESSAGE_DISPATCH_ERROR(timeout: number, message: MessageEnvelope): Error {\n    return Error(`[GatewayError] No acknowledgement received within ${timeout}ms for a message sent to the broker. [msg=${stringifyEnvelope(message)}]`);\n  }\n\n  export function BROKER_DISCOVER_ERROR(timeout: number): Error {\n    return Error(`[GatewayError] Message broker not discovered within ${timeout}ms. Messages cannot be published or received.`);\n  }\n}\n\n/**\n * Describes how to subscribe for messages.\n *\n * @ignore\n */\nexport interface SubscriptionDescriptor {\n  /**\n   * Channel for receiving subscribed messages.\n   */\n  messageChannel: MessagingChannel;\n  /**\n   * Channel to send the subscribe request.\n   */\n  subscribeChannel: MessagingChannel;\n  /**\n   * Channel to send the unsubscribe request.\n   */\n  unsubscribeChannel: MessagingChannel;\n  /**\n   * Callback that is invoked to create the subscription command that will be sent over the subscription channel.\n   */\n  newSubscribeCommand: (subscriberId: string) => SubscribeCommand;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {PlatformState} from './platform-state';\nimport {Observable} from 'rxjs';\n\n/**\n * Provides access to {@link MicrofrontendPlatform}.\n *\n * Use this bean from within a class which is itself referenced in the {@link MicrofrontendPlatform}, in order to avoid ES2015 import cycles.\n *\n * @ignore\n */\nexport abstract class MicrofrontendPlatformRef {\n\n  /**\n   * @see {@link MicrofrontendPlatform#whenState}\n   */\n  public abstract whenState(state: PlatformState): Promise<void>;\n\n  /**\n   * @see {@link MicrofrontendPlatform#state}\n   */\n  public abstract state: PlatformState;\n\n  /**\n   * @see {@link MicrofrontendPlatform#state$}\n   */\n  public abstract state$: Observable<PlatformState>;\n\n  /**\n   * @see {@link MicrofrontendPlatform#destroy}\n   */\n  public abstract destroy(): void;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Logger} from './logger';\nimport {Beans} from '@scion/toolkit/bean-manager';\n\n/**\n * Runs the given function. Errors are caught and logged.\n *\n * If producing a Promise, returns that Promise, but with a catch handler installed.\n *\n * @ignore\n */\nexport function runSafe<T = void>(runnable: () => T): T {\n  let result: T;\n  try {\n    result = runnable();\n  }\n  catch (error) {\n    Beans.opt(Logger)?.error('[UnexpectedError] An unexpected error occurred.', error);\n    return undefined!;\n  }\n\n  if (result instanceof Promise) {\n    return result.catch(error => {\n      Beans.opt(Logger)?.error('[UnexpectedError] An unexpected error occurred.', error);\n      return undefined;\n    }) as any;\n  }\n  return result;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\n/**\n * Returns the error message if given an error object, or the `toString` representation otherwise.\n */\nexport function stringifyError(error: string | Error | unknown): string {\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return `${error}`;\n}\n","import { Observable } from '../Observable';\nimport { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike } from '../types';\nimport { timer } from './timer';\n\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.</span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n *\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param {number} [period=0] The interval size in milliseconds (by default)\n * or the time unit determined by the scheduler's clock.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a sequential number each time\n * interval.\n */\nexport function interval(period = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number> {\n  if (period < 0) {\n    // We cannot schedule an interval in the past.\n    period = 0;\n  }\n\n  return timer(period, period, scheduler);\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {MessageClient} from './client/messaging/message-client';\nimport {PlatformTopics} from './messaging.model';\nimport {map} from 'rxjs/operators';\nimport {Dictionary, Maps} from '@scion/toolkit/util';\nimport {firstValueFrom} from 'rxjs';\nimport {mapToBody} from './messaging.model';\nimport {Beans, Initializer} from '@scion/toolkit/bean-manager';\nimport {BrokerGateway, NullBrokerGateway} from './client/messaging/broker-gateway';\n\n/**\n * Allows looking up properties defined in the platform host.\n *\n * @category Platform\n */\nexport class PlatformPropertyService implements Initializer {\n\n  private _properties = new Map<string, any>();\n\n  public async init(): Promise<void> {\n    const messagingDisabled = Beans.get(BrokerGateway) instanceof NullBrokerGateway;\n    if (messagingDisabled) {\n      return;\n    }\n\n    // Wait until obtained platform properties so that they can be accessed synchronously by the application via `PlatformPropertyService#properties`.\n    const properties$ = Beans.get(MessageClient).observe$<Dictionary>(PlatformTopics.PlatformProperties);\n    this._properties = await firstValueFrom(properties$.pipe(mapToBody(), map(properties => Maps.coerce(properties))));\n  }\n\n  /**\n   * Indicates whether a property with the specified key exists or not.\n   */\n  public contains(key: string): boolean {\n    return this._properties.has(key);\n  }\n\n  /**\n   * Returns the property of the given key, or `defaultValue` if the property does not exist.\n   *\n   * Throws an error if `defaultValue` is not specified and the property does not exist.\n   */\n  public get<T>(key: string, defaultValue?: T): T {\n    if (this._properties.has(key)) {\n      return this._properties.get(key);\n    }\n    if (defaultValue !== undefined) {\n      return defaultValue;\n    }\n    throw Error(`[PropertyNotFoundError] No property of given name found [prop=${key}]`);\n  }\n\n  /**\n   * Returns the properties map.\n   */\n  public properties(): ReadonlyMap<string, any> {\n    return this._properties;\n  }\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Observable, Subscription} from 'rxjs';\nimport {Intent, IntentMessage, TopicMessage} from '../../messaging.model';\nimport {Qualifier} from '../../platform.model';\nimport {PublishOptions, RequestOptions} from './publish-options';\n\n/**\n * Allows sending and receiving intents between microfrontends across origins.\n * This client is part of the Intention API of the SCION Microfrontend Platform.\n *\n * Intent-based messaging enables controlled collaboration between micro applications, a mechanism known from Android development\n * where an application can start an activity via an intent (such as sending an email).\n *\n * Like topic-based communication, intent-based communication implements the pub/sub (publish/subscribe) messaging pattern, but is,\n * in contrast, more restrictive when sending messages. Sending messages is also referred to as issuing intents. It requires the sending\n * application to declare an intention in its manifest. Intents are received only by applications that provide a fulfilling capability.\n * If no application provides a fulfilling capability, the platform rejects the intent.\n *\n * The communication is built on top of the native `postMessage` mechanism. The host app acts as message broker.\n *\n * #### Intent Addressing\n * In intent-based communication, the destination are capabilities, formulated in an abstract way, consisting of a a type, and optionally\n * a qualifier. The type categorizes a capability in terms of its functional semantics. A capability may also define a qualifier to\n * differentiate the different capabilities of the same type. The type is a string literal and the qualifier a dictionary of key-value pairs.\n *\n * ### Retained Intents\n * You can mark an intent as \"retained\" for helping newly subscribed clients to get the last intent published for a capability immediately upon\n * subscription. The broker stores one retained intent per capability, i.e., a later sent retained intent will replace a previously sent retained\n * intent. To delete a retained intent, send a retained intent without payload to the same destination.\n *\n * ### Retained Request\n * Unlike retained intents, retained requests are not replaced by later retained requests/intents and remain in the broker until the requestor unsubscribes.\n *\n * ### Request-Response Messaging\n * Sometimes it is useful to initiate a request-response communication to wait for a response. Unlike with fire-and-forget intents, a temporary\n * inbox is created for the intent issuer to receive replies.\n *\n * @see {@link IntentMessage}\n * @see {@link Intent}\n * @see {@link MessageHeaders}\n *\n * @category Messaging\n * @category Intention API\n */\nexport abstract class IntentClient {\n\n  /**\n   * Sends an intent.\n   *\n   * A micro application can send intents for intentions declared in its manifest. The platform transports the intent to micro applications\n   * that provide a fulfilling capability. Along with the intent, the application can pass transfer data, either as payload, message headers\n   * or parameters. Passed data must be serializable with the Structured Clone Algorithm.\n   *\n   * A micro application is implicitly qualified to interact with capabilities that it provides; thus, it must not declare an intention.\n   *\n   * An intent can be marked as \"retained\" by setting the {@link PublishOptions.retain} flag to `true`. It instructs the broker to store this intent and\n   * deliver it to new subscribers, even if they subscribe after the intent has been published. The broker stores one retained intent per capability. To\n   * delete a retained intent, send a retained intent without payload. Deletion intents are not transported to subscribers.\n   *\n   * @param  intent - Describes the intent. The qualifier, if any, must be exact, thus not contain wildcards.\n   * @param  body - Specifies optional transfer data to be carried along with the intent.\n   *         It can be any object which is serializable with the structured clone algorithm.\n   * @param  options - Controls how to issue the intent and allows setting message headers.\n   * @return A Promise that resolves when dispatched the intent, or that rejects if the intent could not be dispatched,\n   *         e.g., if missing the intention declaration, or because no application is registered to handle the intent.\n   */\n  public abstract publish<T = any>(intent: Intent, body?: T, options?: PublishOptions): Promise<void>;\n\n  /**\n   * Sends an intent and receives one or more replies.\n   *\n   * A micro application can send intents for intentions declared in its manifest. The platform transports the intent to micro applications\n   * that provide a fulfilling capability. Along with the intent, the application can pass transfer data, either as payload, message headers\n   * or parameters. Passed data must be serializable with the Structured Clone Algorithm.\n   *\n   * A micro application is implicitly qualified to interact with capabilities that it provides; thus, it must not declare an intention.\n   *\n   * A request can be marked as \"retained\" by setting the {@link RequestOptions.retain} flag to `true`. It instructs the broker to store this request and\n   * deliver it to new subscribers, even if they subscribe after the request has been sent. Retained requests are not replaced by later retained requests/\n   * intents and remain in the broker until the requestor unsubscribes.\n   *\n   * If not marking the request as \"retained\", at least one subscriber must be subscribed to the intent. Otherwise, the request is rejected.\n   *\n   * @param  intent - Describes the intent. The qualifier, if any, must be exact, thus not contain wildcards.\n   * @param  body - Specifies optional transfer data to be carried along with the intent.\n   *         It can be any object which is serializable with the structured clone algorithm.\n   * @param  options - Controls how to send the request and allows setting request headers.\n   * @return An Observable that emits when receiving a reply. It never completes unless the replier sets the status code {@link ResponseStatusCodes.TERMINAL}\n   *         in the {@link MessageHeaders.Status} message header. Then, the Observable completes immediately after emitted the reply.\n   *         The Observable errors if the request could not be dispatched. It will also error if the replier sets a status code greater than or equal to 400, e.g., {@link ResponseStatusCodes.ERROR}.\n   */\n  public abstract request$<T>(intent: Intent, body?: any, options?: RequestOptions): Observable<TopicMessage<T>>;\n\n  /**\n   * Receives an intent when some micro application wants to collaborate with this micro application.\n   *\n   * Intents are typically subscribed to in an activator. Refer to {@link ActivatorCapability} for more information.\n   *\n   * The micro application receives only intents for which it provides a fulfilling capability.\n   * You can filter received intents by passing a selector. The selector supports the use of wildcards.\n   *\n   * If the received intent has the {@link MessageHeaders.ReplyTo} header field set, the publisher expects the receiver to send one or more\n   * replies to that {@link MessageHeaders.ReplyTo ReplyTo} topic. If streaming responses, you can use the {@link takeUntilUnsubscribe}\n   * operator to stop replying when the requestor unsubscribes.\n   *\n   * ```typescript\n   *  const selector: IntentSelector = {\n   *    type: 'temperature',\n   *    qualifier: {room: 'kitchen'},\n   *  };\n   *\n   *  Beans.get(IntentClient).observe$(selector).subscribe((request: IntentMessage) => {\n   *    const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n   *    sensor$\n   *      .pipe(takeUntilUnsubscribe(replyTo))\n   *      .subscribe(temperature => {\n   *        Beans.get(MessageClient).publish(replyTo, `${temperature}C`);\n   *      });\n   *  });\n   * ```\n   *\n   * @param  selector - Allows filtering intents. The qualifier allows using wildcards (such as `*` or `?`) to match multiple intents simultaneously.\\\n   *         Note that the passed filter is only a filter for intents the application is qualified for, i.e., provides a fulfilling capability visible\n   *         to the sender.\n   *         <p>\n   *         <ul>\n   *           <li>**Asterisk wildcard character (`*`):**\\\n   *             <ul>\n   *               <li>If used as qualifier property key, matches intents even if having additional properties. Use it like this: `{'*': '*'}`.</li>\n   *               <li>If used as qualifier property value, requires intents to contain that property, but with any value allowed (except for `null` or `undefined` values).</li>\n   *             </ul>\n   *           </li>\n   *           <li>**Optional wildcard character (`?`):**\\\n   *               Is allowed as qualifier property value only and matches intents regardless of having or not having that property.\n   *           </li>\n   *         </ul>\n   *\n   * @return An Observable that emits received intents. It never completes.\n   */\n  public abstract observe$<T>(selector?: IntentSelector): Observable<IntentMessage<T>>;\n\n  /**\n   * Convenience API for handling intents.\n   *\n   * Unlike `observe$`, intents are passed to a callback function rather than emitted from an Observable. Response(s) can be returned directly\n   * from the callback. It supports error propagation and request termination. Using this method over `observe$` significantly reduces the code\n   * required to respond to requests.\n   *\n   * For each intent received, the specified callback function is called. When used in request-response communication,\n   * the callback function can return the response either directly or in the form of a Promise or Observable. Returning a Promise\n   * allows the response to be computed asynchronously, and an Observable allows to return one or more responses, e.g., for\n   * streaming data.\n   * If the callback function returns no value (void), returns `undefined`, or returns a Promise that resolves to `undefined`, communication is terminated\n   * immediately without a response. If the callback returns an Observable, all its emissions are transported to the requestor and communication is not\n   * terminated until the Observable completes. Termination of communication always completes the requestor's Observable.\n   * If the callback throws an error, or the returned Promise or Observable errors, the error is\n   * transported to the requestor, erroring the requestor's Observable.\n   *\n   * @param  selector - Allows filtering intents.\n   *         For more information, see the API description of {@link observe$}.\n   * @param  callback - Specifies the callback to be called for each intent. When used in request-response communication,\n   *         the callback function can return the response either directly or in the form of a Promise or Observable. If returning\n   *         a response in fire-and-forget communication, it is ignored. Throwing an error in the callback does not unregister the callback.\n   * @return Subscription to unregister the callback. Calling {@link rxjs!Subscription.unsubscribe Subscription.unsubscribe} will complete the Observable of all\n   *         requestors, if any.\n   */\n  public abstract onIntent<IN = any, OUT = any>(selector: IntentSelector, callback: (intentMessage: IntentMessage<IN>) => Observable<OUT> | Promise<OUT> | OUT | void): Subscription;\n}\n\n/**\n * Allows filtering intents.\n */\nexport interface IntentSelector {\n  /**\n   * If specified, filters intents of the given type.\n   */\n  type?: string;\n  /**\n   * If specified, filters intents matching the given qualifier. You can use the asterisk wildcard (`*`)\n   * or optional wildcard character (`?`) to match multiple intents.\n   */\n  qualifier?: Qualifier;\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Capability, Intention} from '../../platform.model';\nimport {Intent} from '../../messaging.model';\nimport {Observable} from 'rxjs';\n\n/**\n * Central point for looking up or managing capabilities or intentions available in the platform.\n *\n * @ignore\n */\nexport abstract class ManifestRegistry {\n\n  /**\n   * Returns capabilities which are visible to the given application and match the given intent.\n   * The intent is not allowed to contain wildcards in its qualifier.\n   */\n  public abstract resolveCapabilitiesByIntent(intent: Intent, appSymbolicName: string): Capability[];\n\n  /**\n   * Tests whether the given app has declared an intention for the given intent, or is providing a capability matching the given intent.\n   */\n  public abstract hasIntention(intent: Intent, appSymbolicName: string): boolean;\n\n  /**\n   * Registers the given capability for the given application.\n   */\n  public abstract registerCapability(capability: Capability, appSymbolicName: string): Promise<string>;\n\n  /**\n   * Registers the given intention for the given application.\n   */\n  public abstract registerIntention(intention: Intention, appSymbolicName: string): string;\n\n  /**\n   * Notifies when a capability is registered with the platform.\n   */\n  public abstract readonly capabilityRegister$: Observable<Capability>;\n\n  /**\n   * Notifies when capabilities are unregistered from the platform.\n   */\n  public abstract readonly capabilityUnregister$: Observable<Capability[]>;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\n/** @ignore */\nconst ABSOLUTE_URL_REGEX = /^http[s]?:\\/\\//;\n\n/**\n * @ignore\n */\nexport namespace Urls {\n\n  /**\n   * Returns `true` if the given URL is an absolute URL or the 'about:blank' page.\n   */\n  export function isAbsoluteUrl(url: string): boolean {\n    return url === 'about:blank' || ABSOLUTE_URL_REGEX.test(url);\n  }\n\n  /**\n   * Constructs the {@link URL} for the given url and optional base, applying relative navigational symbols if contained in the url.\n   *\n   * Following rules apply:\n   * - base is required if providing a relative url\n   * - search and fragment parts of the base are ignored\n   * - relative navigational symbols are only applied if passing a base (native support)\n   *\n   * This function is similar to `new URL(url, base)` except that it works for bases that do not have a trailing slash.\n   * If you use `new URL(url, base)` without a trailing slash in the base, the last segment is discarded.\n   *\n   * // new URL('x/y', 'http://localhost:4200/a/b/').toString() -> \"http://localhost:4200/a/b/x/y\" // what we expect\n   * // new URL('x/y', 'http://localhost:4200/a/b').toString() -> \"http://localhost:4200/a/x/y\" // not what we expect\n   *\n   * We observed this behavior in Chromium and Firefox browsers.\n   */\n  export function newUrl(url: string, base?: string): URL {\n    if (base) {\n      const baseUrl = new URL(base);\n      if (baseUrl.pathname && !baseUrl.pathname.endsWith('/')) {\n        baseUrl.pathname += '/';\n      }\n      return new URL(url, baseUrl);\n    }\n\n    return new URL(url);\n  }\n\n  /**\n   * Adds a trailing slash to the given URL, if not already present.\n   */\n  export function ensureTrailingSlash(url: string): string {\n    if (!url.endsWith('/')) {\n      return url + '/';\n    }\n    return url;\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {ApplicationConfig} from './application-config';\nimport {HostConfig} from './host-config';\n\n/**\n * Configures the platform and defines the micro applications running in the platform.\n *\n * @category Platform\n */\nexport abstract class MicrofrontendPlatformConfig {\n  /**\n   * Lists the micro applications able to connect to the platform to interact with other micro applications.\n   */\n  public abstract readonly applications: ApplicationConfig[];\n  /**\n   * Configures the interaction of the host application with the platform.\n   *\n   * As with micro applications, you can provide a manifest for the host, allowing the host to contribute capabilities and declare intentions.\n   */\n  public abstract readonly host?: HostConfig;\n  /**\n   * Controls whether the Activator API is enabled.\n   *\n   * Activating the Activator API enables micro applications to contribute `activator` microfrontends. Activator microfrontends are loaded\n   * at platform startup for the entire lifecycle of the platform. An activator is a startup hook for micro applications to initialize\n   * or register message or intent handlers to provide functionality.\n   *\n   * By default, this API is enabled.\n   *\n   * @see {@link ActivatorCapability}\n   */\n  public abstract readonly activatorApiDisabled?: boolean;\n  /**\n   * Maximum time (in milliseconds) that the platform waits until the manifest of an application is loaded.\n   * You can set a different timeout per application via {@link ApplicationConfig.manifestLoadTimeout}.\n   * If not set, by default, the browser's HTTP fetch timeout applies.\n   *\n   * Consider setting this timeout if, for example, a web application firewall delays the responses of unavailable\n   * applications.\n   */\n  public abstract readonly manifestLoadTimeout?: number;\n  /**\n   * Maximum time (in milliseconds) for each application to signal readiness.\n   *\n   * If specified and activating an application takes longer, the host logs an error and continues startup.\n   * Has no effect for applications which provide no activator(s) or are not configured to signal readiness.\n   * You can set a different timeout per application via {@link ApplicationConfig.activatorLoadTimeout}.\n   *\n   * By default, no timeout is set, meaning that if an app fails to signal readiness, e.g., due to an error,\n   * that app would block the host startup process indefinitely. It is therefore recommended to specify a\n   * timeout accordingly.\n   */\n  public abstract readonly activatorLoadTimeout?: number;\n  /**\n   * Interval (in seconds) at which connected clients must send a heartbeat to indicate connectivity to the host.\n   *\n   * By default, if not set, a heartbeat interval of 60s is used.\n   */\n  public abstract readonly heartbeatInterval?: number;\n  /**\n   * Defines user-defined properties which can be read by micro applications via {@link PlatformPropertyService}.\n   */\n  public abstract readonly properties?: {\n    [key: string]: any;\n  };\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Application, Manifest} from '../platform.model';\nimport {Defined} from '@scion/toolkit/util';\nimport {Urls} from '../url.util';\nimport {MicrofrontendPlatformConfig} from './microfrontend-platform-config';\nimport {ManifestRegistry} from './manifest-registry/manifest-registry';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {Logger} from '../logger';\nimport {ApplicationConfig} from './application-config';\n\n/**\n * Registry with all registered applications.\n *\n * @ignore\n */\nexport class ApplicationRegistry {\n\n  private static readonly SYMBOLIC_NAME_REGEXP = /^[a-z0-9-]+$/;\n\n  private readonly _applications = new Map<string, Application>();\n\n  /**\n   * Registers the given application.\n   *\n   * Throws an error if the application's symbolic name is not unique or contains illegal characters.\n   */\n  public async registerApplication(applicationConfig: ApplicationConfig, manifest: Manifest): Promise<void> {\n    Defined.orElseThrow(applicationConfig.symbolicName, () => Error(`[ApplicationRegistrationError] Invalid application config. Missing required property \\'symbolicName\\'. [appConfig=\"${JSON.stringify(applicationConfig)}\", manifest=\"${JSON.stringify(manifest)}\"]`));\n    Defined.orElseThrow(applicationConfig.manifestUrl, () => Error(`[ApplicationRegistrationError] Invalid application config. Missing required property \\'manifestUrl\\'. [appConfig=\"${JSON.stringify(applicationConfig)}\", manifest=\"${JSON.stringify(manifest)}\"]`));\n\n    if (!ApplicationRegistry.SYMBOLIC_NAME_REGEXP.test(applicationConfig.symbolicName)) {\n      throw Error(`[ApplicationRegistrationError] Symbolic name must be lowercase and contain alphanumeric and dash characters [symbolicName='${applicationConfig.symbolicName}'].`);\n    }\n\n    const notUniqueSymbolicName = Array.from(this._applications.values()).some(application => application.symbolicName === applicationConfig.symbolicName);\n    if (notUniqueSymbolicName) {\n      throw Error(`[ApplicationRegistrationError] Symbolic name must be unique [symbolicName='${applicationConfig.symbolicName}'].`);\n    }\n\n    this._applications.set(applicationConfig.symbolicName, {\n      symbolicName: applicationConfig.symbolicName,\n      name: manifest.name ?? applicationConfig.symbolicName,\n      baseUrl: this.computeBaseUrl(applicationConfig, manifest),\n      manifestUrl: Urls.newUrl(applicationConfig.manifestUrl, Urls.isAbsoluteUrl(applicationConfig.manifestUrl) ? applicationConfig.manifestUrl : window.origin).toString(),\n      manifestLoadTimeout: applicationConfig.manifestLoadTimeout ?? Beans.get(MicrofrontendPlatformConfig).manifestLoadTimeout,\n      activatorLoadTimeout: applicationConfig.activatorLoadTimeout ?? Beans.get(MicrofrontendPlatformConfig).activatorLoadTimeout,\n      messageOrigin: applicationConfig.messageOrigin ?? Urls.newUrl(this.computeBaseUrl(applicationConfig, manifest)).origin,\n      scopeCheckDisabled: Defined.orElse(applicationConfig.scopeCheckDisabled, false),\n      intentionCheckDisabled: Defined.orElse(applicationConfig.intentionCheckDisabled, false),\n      intentionRegisterApiDisabled: Defined.orElse(applicationConfig.intentionRegisterApiDisabled, true),\n    });\n\n    for (const capability of manifest.capabilities ?? []) {\n      try {\n        await Beans.get(ManifestRegistry).registerCapability(capability, applicationConfig.symbolicName);\n      }\n      catch (error) {\n        Beans.get(Logger).error(`[CapabilityRegisterError] Failed to register capability for application '${applicationConfig.symbolicName}'.`, error);\n      }\n    }\n\n    manifest.intentions?.forEach(intention => {\n      try {\n        Beans.get(ManifestRegistry).registerIntention(intention, applicationConfig.symbolicName);\n      }\n      catch (error) {\n        Beans.get(Logger).error(`[IntentionRegisterError] Failed to register intention for application '${applicationConfig.symbolicName}'.`, error);\n      }\n    });\n  }\n\n  public getApplication(symbolicName: string): Application | undefined {\n    return this._applications.get(symbolicName);\n  }\n\n  public getApplications(): Application[] {\n    return Array.from(this._applications.values());\n  }\n\n  /**\n   * Returns whether or not capability 'scope check' is disabled for the given application.\n   */\n  public isScopeCheckDisabled(appSymbolicName: string): boolean {\n    return Defined.orElseThrow(this._applications.get(appSymbolicName), () => Error(`[NullApplicationError] No application registered under the symbolic name '${appSymbolicName}'.`)).scopeCheckDisabled;\n  }\n\n  /**\n   * Returns whether or not the 'Intention Registration API' is disabled for the given application.\n   */\n  public isIntentionRegisterApiDisabled(appSymbolicName: string): boolean {\n    return Defined.orElseThrow(this._applications.get(appSymbolicName), () => Error(`[NullApplicationError] No application registered under the symbolic name '${appSymbolicName}'.`)).intentionRegisterApiDisabled;\n  }\n\n  /**\n   * Returns whether or not 'intention check' is disabled for the given application.\n   */\n  public isIntentionCheckDisabled(appSymbolicName: string): boolean {\n    return Defined.orElseThrow(this._applications.get(appSymbolicName), () => Error(`[NullApplicationError] No application registered under the symbolic name '${appSymbolicName}'.`)).intentionCheckDisabled;\n  }\n\n  /**\n   * Computes the base URL as following:\n   *\n   * - if base URL is specified in the manifest, that URL is used (either as an absolute URL, or relative to the origin of 'manifestUrl')\n   * - if base URL is not specified in the manifest, the origin from 'manifestUrl' is used as the base URL, or the origin from the current window if the 'manifestUrl' is relative\n   * - if base URL has no trailing slash, adds a trailing slash\n   */\n  private computeBaseUrl(applicationConfig: ApplicationConfig, manifest: Manifest): string {\n    const manifestURL = Urls.isAbsoluteUrl(applicationConfig.manifestUrl) ? Urls.newUrl(applicationConfig.manifestUrl) : Urls.newUrl(applicationConfig.manifestUrl, window.origin);\n\n    if (!manifest.baseUrl) {\n      return Urls.ensureTrailingSlash(manifestURL.origin);\n    }\n\n    if (Urls.isAbsoluteUrl(manifest.baseUrl)) {\n      return Urls.ensureTrailingSlash(manifest.baseUrl);\n    }\n    else {\n      return Urls.ensureTrailingSlash(Urls.newUrl(manifest.baseUrl, manifestURL.origin).toString());\n    }\n  }\n}\n\n/**\n * Represents an application registered in the platform.\n *\n * The version is omitted because not known at the time of registration, but only when first connecting to the host, e.g., in an activator.\n */\nexport interface Application extends Omit<Application, 'platformVersion'> { // eslint-disable-line @typescript-eslint/no-empty-interface\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\n/**\n * Uses the native Web Fetch API to fetch a resource from the network.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n * @ignore\n */\nexport class HttpClient {\n\n  /**\n   * Allows fetching a resource from the network, returning a promise which is fulfilled once the response is available. The promise resolves\n   * to the Response object representing the response to your request. The promise does not reject on HTTP errors  instead it only rejects on\n   * network errors; then handlers must check for HTTP errors.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n   *\n   * @param  input - Defines the resource that you wish to fetch.\n   * @param  init - Options object containing any custom settings that you want to apply to the request.\n   * @return A Promise that resolves to a Response object.\n   */\n  public fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n    return fetch(input, init); // native call\n  }\n}\n","/*\n * Copyright (c) 2018-2021 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {BehaviorSubject, combineLatest, OperatorFunction, Subject} from 'rxjs';\nimport {distinctUntilChanged, map, takeUntil, takeWhile} from 'rxjs/operators';\n\n/**\n * Represents a monitor to track the progress of some work.\n *\n * A monitor can be split into child monitors, allowing the work to be broken down into smaller units,\n * with each child monitor contributing to the overall progress of the parent monitor.\n *\n * @ignore\n */\nexport class ProgressMonitor {\n\n  private _progress$ = new BehaviorSubject<number>(0);\n  private _done$ = new Subject<void>();\n  private _hasSubMonitors = false;\n\n  /**\n   * Reports the current progress of this monitor in percent.\n   *\n   * Upon subscription, emits the current progress, and then continuously as the progress advances.\n   * At 100%, the Observable completes.\n   */\n  public readonly progress$ = this._progress$.pipe(\n    distinctUntilChanged(),\n    map(progress => Math.round(progress * 10000) / 100),\n    takeWhile(progress => progress < 100, true),\n  );\n\n  /**\n   * Splits this monitor into separate child monitors for breaking down this monitor's work into smaller units.\n   *\n   * Each child monitor contributes to the overall progress of this monitor. The ratio allows child monitors to be\n   * weighted differently, for example, one child monitor can contribute twice as much as another to the overall progress.\n   * After all child monitors reported \"done\", this monitor will also enter \"done\".\n   */\n  public split(...ratio: number[]): ProgressMonitor[] {\n    if (this._hasSubMonitors) {\n      throw Error('[IllegalMonitorStateError] Monitor cannot be split multiple times.');\n    }\n    this._hasSubMonitors = true;\n\n    const subMonitors = ratio.map(() => new ProgressMonitor());\n    combineLatest(subMonitors.map(subMonitor => subMonitor._progress$))\n      .pipe(\n        computeProgress(ratio),\n        takeWhile(progress => progress < 1, true),\n        takeUntil(this._done$),\n      )\n      .subscribe(progress => {\n        this._progress$.next(progress);\n      });\n\n    return subMonitors;\n  }\n\n  /**\n   * Like {@link split}, but creates `n` child monitors with the same weight.\n   */\n  public splitEven(n: number): ProgressMonitor[] {\n    if (n <= 0) {\n      throw Error(`[IllegalMonitorArgumentError] Monitor split count must be greater than 0, but was ${n}.`);\n    }\n    return this.split(...new Array(n).fill(1));\n  }\n\n  /**\n   * Completes this monitor, setting its progress to '100%'.\n   * Has no effect if this monitor is already \"done\".\n   */\n  public done(): void {\n    this._progress$.next(1);\n    this._done$.next();\n  }\n}\n\nfunction computeProgress(ratio: number[]): OperatorFunction<number[], number> {\n  const ratioSum = ratio.reduce((sum, weight) => sum + weight, 0);\n  return map((subMonitorsProgress: number[]) => {\n    return ratio.reduce((totalProgress, subMonitorWeight, subMonitorIndex) => {\n      return totalProgress + subMonitorsProgress[subMonitorIndex] * (subMonitorWeight / ratioSum);\n    }, 0);\n  });\n}\n","/*\n * Copyright (c) 2018-2021 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {ProgressMonitor} from './progress-monitor';\n\n/**\n * Tracks the progress of loading application manifests.\n *\n * @ignore\n */\nexport abstract class ManifestLoadProgressMonitor extends ProgressMonitor {\n}\n\n/**\n * Tracks the progress of loading application activators.\n *\n * @ignore\n */\nexport abstract class ActivatorLoadProgressMonitor extends ProgressMonitor {\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Intention, Manifest, PlatformCapabilityTypes} from '../platform.model';\nimport {MicrofrontendPlatformConfig} from './microfrontend-platform-config';\nimport {Beans} from '@scion/toolkit/bean-manager';\n\n/**\n * Hook to intercept the host manifest before it is registered in the platform.\n *\n * If integrating the platform in a library, you may need to intercept the manifest of the host in order to introduce library-specific behavior.\n *\n * You can register the interceptor in the bean manager, as follows:\n *\n * ```ts\n * Beans.register(HostManifestInterceptor, {useClass: YourInterceptor, multi: true});\n * ```\n *\n * The interceptor may look as following:\n * ```ts\n *  class YourInterceptor implements HostManifestInterceptor {\n *\n *   public intercept(hostManifest: Manifest): void {\n *     hostManifest.intentions = [\n *       ...hostManifest.intentions || [],\n *       provideMicrofrontendIntention(),\n *     ];\n *     hostManifest.capabilities = [\n *       ...hostManifest.capabilities || [],\n *       provideMessageBoxCapability(),\n *     ];\n *   }\n * }\n *\n * function provideMicrofrontendIntention(): Intention {\n *    return {\n *      type: 'microfrontend',\n *      qualifier: {'*': '*'},\n *    };\n *  }\n *\n * function provideMessageBoxCapability(): Capability {\n *    return {\n *      type: 'messagebox',\n *      qualifier: {},\n *      private: false,\n *      description: 'Allows displaying a simple message to the user.',\n *    };\n *  }\n *\n * ```\n */\nexport abstract class HostManifestInterceptor {\n\n  /**\n   * Allows modifying the host manifest before it is registered in the platform, e.g., to register capabilities or intentions.\n   */\n  public abstract intercept(hostManifest: Manifest): void;\n}\n\n/**\n * Intercepts the host manifest, registering platform-specific intentions and capabilities.\n *\n * @internal\n */\nexport class HostManifestInterceptor implements HostManifestInterceptor {\n\n  public intercept(hostManifest: Manifest): void {\n    hostManifest.intentions = [\n      ...hostManifest.intentions || [],\n      ...provideActivatorIntentionIfEnabled(),\n    ];\n  }\n}\n\n/**\n * Provides a wildcard activator intention for the platform to read activator capabilities for installing activator microfrontends.\n */\nfunction provideActivatorIntentionIfEnabled(): Intention[] {\n  const activatorApiDisabled = Beans.get(MicrofrontendPlatformConfig).activatorApiDisabled ?? false;\n  if (activatorApiDisabled) {\n    return [];\n  }\n  return [{\n    type: PlatformCapabilityTypes.Activator,\n    qualifier: {'*': '*'},\n  }];\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {MicrofrontendPlatformConfig} from './microfrontend-platform-config';\nimport {ApplicationRegistry} from './application-registry';\nimport {HttpClient} from './http-client';\nimport {Logger} from '../logger';\nimport {Beans, Initializer} from '@scion/toolkit/bean-manager';\nimport {ProgressMonitor} from './progress-monitor/progress-monitor';\nimport {ManifestLoadProgressMonitor} from './progress-monitor/progress-monitors';\nimport {firstValueFrom, from, identity, Observable, throwError, timeout} from 'rxjs';\nimport {APP_IDENTITY, Manifest, APP_CONFIG} from '../platform.model';\nimport {HostManifestInterceptor} from './host-manifest-interceptor';\nimport {ApplicationConfig} from './application-config';\n\n/**\n * Collects manifests of registered applications.\n *\n * This collector is registered as {@link Initializer}. The platform waits to initialize until manifests are collected.\n * @ignore\n */\nexport class ManifestCollector implements Initializer {\n\n  public async init(): Promise<void> {\n    await Promise.all(this.fetchAndRegisterManifests());\n  }\n\n  private fetchAndRegisterManifests(): Promise<void>[] {\n    const appConfigs = Beans.all<ApplicationConfig>(APP_CONFIG);\n    const monitor = Beans.get(ManifestLoadProgressMonitor);\n    if (!appConfigs.length) {\n      monitor.done();\n      return [];\n    }\n\n    const subMonitors = monitor.splitEven(appConfigs.length);\n    return appConfigs.map((appConfig, index) => this.fetchAndRegisterManifest(appConfig, subMonitors[index]));\n  }\n\n  private async fetchAndRegisterManifest(appConfig: ApplicationConfig, monitor: ProgressMonitor): Promise<void> {\n    try {\n      if (!appConfig.symbolicName) {\n        Beans.get(Logger).error('[AppConfigError] Invalid application config. Missing required property \\'symbolicName\\'.', appConfig);\n        return;\n      }\n      if (!appConfig.manifestUrl) {\n        Beans.get(Logger).error(`[AppConfigError] Invalid application config passed for application '${appConfig.symbolicName}'. Missing required property 'manifestUrl'.`, appConfig);\n        return;\n      }\n\n      const fetchManifest$ = from(Beans.get(HttpClient).fetch(appConfig.manifestUrl));\n      const manifestFetchTimeout = appConfig.manifestLoadTimeout ?? Beans.get(MicrofrontendPlatformConfig).manifestLoadTimeout;\n      const onManifestFetchTimeout = (): Observable<never> => throwError(() => `Timeout of ${manifestFetchTimeout}ms elapsed.`);\n      const manifestFetchResponse = await firstValueFrom(fetchManifest$.pipe(manifestFetchTimeout ? timeout({first: manifestFetchTimeout, with: onManifestFetchTimeout}) : identity));\n\n      if (!manifestFetchResponse.ok) {\n        Beans.get(Logger).error(`[ManifestFetchError] Failed to fetch manifest for application '${appConfig.symbolicName}'. Maybe the application is currently unavailable. [httpStatusCode=${manifestFetchResponse.status}, httpStatusText=${manifestFetchResponse.statusText}]`, appConfig, manifestFetchResponse.status);\n        return;\n      }\n\n      const manifest: Manifest = await manifestFetchResponse.json();\n\n      // Let the host manifest be intercepted before registering it in the platform, for example by libraries integrating the SCION Microfrontend Platform, e.g., to allow the programmatic registration of capabilities or intentions.\n      if (appConfig.symbolicName === Beans.get<string>(APP_IDENTITY)) {\n        Beans.all(HostManifestInterceptor).forEach(interceptor => interceptor.intercept(manifest));\n      }\n\n      await Beans.get(ApplicationRegistry).registerApplication(appConfig, manifest);\n      Beans.get(Logger).info(`Registered application '${appConfig.symbolicName}' in the SCION Microfrontend Platform.`);\n    }\n    catch (error) {\n      // The Promise returned from fetch() wont reject on HTTP error status even if the response is an HTTP 404 or 500.\n      // It will only reject on network failure or if anything prevented the request from completing.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\n      Beans.get(Logger).error(`[ManifestFetchError] Failed to fetch manifest for application '${appConfig.symbolicName}'. Maybe the application is currently unavailable.`, error);\n    }\n    finally {\n      monitor.done();\n    }\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Observable} from 'rxjs';\nimport {Client} from './client';\n\n/**\n * Central point for managing client registrations.\n *\n * @ignore\n */\nexport abstract class ClientRegistry {\n\n  /**\n   * Emits when registered a client.\n   */\n  public abstract readonly register$: Observable<Client>;\n\n  /**\n   * Emits when unregistered a client.\n   */\n  public abstract readonly unregister$: Observable<Client>;\n\n  /**\n   * Registers given client.\n   *\n   * If another client is already registered under the same window,\n   * a warning is logged and the \"stale\" client removed.\n   */\n  public abstract registerClient(client: Client): void;\n\n  /**\n   * Unregisters given client.\n   */\n  public abstract unregisterClient(client: Client): void;\n\n  /**\n   * Returns the client associated with the given id, or `undefined` if not found.\n   */\n  public abstract getByClientId(clientId: string): Client | undefined;\n\n  /**\n   * Returns the client associated with the given {@link Window}, or `undefined` if not found.\n   */\n  public abstract getByWindow(window: Window): Client | undefined;\n\n  /**\n   * Returns the clients associated with the given application.\n   */\n  public abstract getByApplication(appSymbolicName: string): Client[];\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Client} from '../client-registry/client';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {ClientRegistry} from '../client-registry/client.registry';\nimport {takeUntil} from 'rxjs/operators';\nimport {runSafe} from '../../safe-runner';\nimport {Observable, Subject} from 'rxjs';\nimport {Arrays, Maps} from '@scion/toolkit/util';\n\n/**\n * Central point for managing message subscriptions.\n *\n * @ignore\n */\nexport class MessageSubscriptionRegistry<T extends MessageSubscription = MessageSubscription> implements PreDestroy {\n\n  private readonly _destroy$ = new Subject<void>();\n  private readonly _subscriptions = new Map<string, T>();\n  private readonly _subscriptionsByApp = new Map<string, Set<T>>();\n  private readonly _subscriptionsByClient = new Map<string, Set<T>>();\n\n  private readonly _register$ = new Subject<T>();\n  private readonly _unregister$ = new Subject<T[]>();\n\n  constructor() {\n    Beans.get(ClientRegistry).unregister$\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((client: Client) => runSafe(() => {\n        this.unregister({clientId: client.id});\n      }));\n  }\n\n  /**\n   * Registers given subscription.\n   */\n  public register(subscription: T): void {\n    this._subscriptions.set(subscription.subscriberId, subscription);\n    Maps.addSetValue(this._subscriptionsByApp, subscription.client.application.symbolicName, subscription);\n    Maps.addSetValue(this._subscriptionsByClient, subscription.client.id, subscription);\n    this.onRegister?.(subscription);\n    this._register$.next(subscription);\n  }\n\n  /**\n   * Unregisters matching subscriptions.\n   *\n   * @param filter - Control which subscriptions to remove by specifying filter criteria which are \"AND\"ed together.\n   */\n  public unregister(filter: {subscriberId?: string; clientId?: string}): void {\n    const subscriptions = this.subscriptions(filter);\n    subscriptions.forEach(subscription => {\n      this._subscriptions.delete(subscription.subscriberId);\n      Maps.removeSetValue(this._subscriptionsByApp, subscription.client.application.symbolicName, subscription);\n      Maps.removeSetValue(this._subscriptionsByClient, subscription.client.id, subscription);\n      this.onUnregister?.(subscription);\n      subscription.notifyUnsubscribe();\n    });\n    this._unregister$.next(subscriptions);\n  }\n\n  /**\n   * Returns subscriptions matching the passed filter.\n   *\n   * @param filter - Control which subscriptions to return by specifying filter criteria which are \"AND\"ed together.\n   *                 If not specified, returns all subscriptions.\n   */\n  public subscriptions(filter?: {subscriberId?: string; clientId?: string; appSymbolicName?: string}): T[] {\n    const filterById = filter?.subscriberId;\n    const filterByClient = filter?.clientId;\n    const filterByApp = filter?.appSymbolicName;\n\n    return Arrays.intersect(\n      filterById ? this.subscriptionById(filterById) : undefined,\n      filterByClient ? this.subscriptionsByClient(filterByClient) : undefined,\n      filterByApp ? this.subscriptionsByApp(filterByApp) : undefined,\n      (filterById || filterByApp || filterByClient) ? undefined : Array.from(this._subscriptions.values()),\n    );\n  }\n\n  /**\n   * Returns the subscription of given subscriber.\n   */\n  private subscriptionById(subscriberId: string): [T] | [] {\n    const subscription = this._subscriptions.get(subscriberId);\n    return subscription ? [subscription] : [];\n  }\n\n  /**\n   * Returns the subscriptions of given client.\n   */\n  private subscriptionsByClient(clientId: string): T[] {\n    const subscriptions = this._subscriptionsByClient.get(clientId);\n    return subscriptions ? Array.from(subscriptions) : [];\n  }\n\n  /**\n   * Returns the subscriptions of given application.\n   */\n  private subscriptionsByApp(appSymbolicName: string): T[] {\n    const subscriptions = this._subscriptionsByApp.get(appSymbolicName);\n    return subscriptions ? Array.from(subscriptions) : [];\n  }\n\n  /**\n   * Emits when registered a subscription via {@link MessageSubscriptionRegistry#register}.\n   */\n  public get register$(): Observable<T> {\n    return this._register$;\n  }\n\n  /**\n   * Emits when unregistered a subscription via {@link MessageSubscriptionRegistry#unregister}.\n   */\n  public get unregister$(): Observable<T[]> {\n    return this._unregister$;\n  }\n\n  /**\n   * Method invoked when registered a subscription, but before the change was emitted.\n   */\n  protected onRegister?(subscription: T): void;\n\n  /**\n   * Method invoked when unregistered a subscription, but before the change was emitted.\n   */\n  protected onUnregister?(subscription: T): void;\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n\n/**\n * Represents a subscription for a given subscriber.\n *\n * @ignore\n */\nexport class MessageSubscription {\n  /**\n   * Promise that resolves when the subscriber unsubscribes.\n   */\n  public readonly whenUnsubscribe = new Promise<void>(resolve => this.notifyUnsubscribe = resolve);\n\n  /**\n   * Notify when the subscriber unsubscribes.\n   */\n  public notifyUnsubscribe!: () => void;\n\n  constructor(public readonly subscriberId: string, public readonly client: Client) {\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {TopicMatcher} from '../../topic-matcher.util';\nimport {Client} from '../client-registry/client';\nimport {MessageSubscription, MessageSubscriptionRegistry} from './message-subscription.registry';\nimport {filter, Observable, Subject} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {Arrays, Maps} from '@scion/toolkit/util';\nimport {Topics} from '../../topics.util';\nimport {filterArray} from '@scion/toolkit/operators';\n\nconst ASTERISK = ':ANY';\n\n/**\n * Central point for managing topic subscriptions.\n *\n * @ignore\n */\nexport class TopicSubscriptionRegistry extends MessageSubscriptionRegistry<TopicSubscription> {\n\n  private readonly _subscriptionsByTopic = new Map<string, Set<TopicSubscription>>();\n\n  protected override onRegister(subscription: TopicSubscription): void {\n    const topic = Topics.replaceWildcardSegments(subscription.topic, ASTERISK);\n    Maps.addSetValue(this._subscriptionsByTopic, topic, subscription);\n  }\n\n  protected override onUnregister(subscription: TopicSubscription): void {\n    const topic = Topics.replaceWildcardSegments(subscription.topic, ASTERISK);\n    Maps.removeSetValue(this._subscriptionsByTopic, topic, subscription);\n  }\n\n  public override subscriptions(filter?: {subscriberId?: string; clientId?: string; appSymbolicName?: string; topic?: string}): TopicSubscription[] {\n    // Note that we need to identify matching subscriptions very quickly, otherwise the broker's throughput would decrease massively.\n    // Therefore, we must never iterate over all subscriptions, but resolve subscriptions by index.\n    const filterByTopic = filter?.topic;\n    const filterById = filter?.subscriberId;\n    const filterByClient = filter?.clientId;\n    const filterByApp = filter?.appSymbolicName;\n\n    return Arrays.intersect(\n      filterByTopic ? this.subscriptionsByTopic(filterByTopic) : undefined,\n      (filterById || filterByApp || filterByClient) ? super.subscriptions(filter) : undefined,\n      (filterById || filterByApp || filterByClient || filterByTopic) ? undefined : super.subscriptions(),\n    );\n  }\n\n  /**\n   * Returns the subscription of given topic.\n   */\n  private subscriptionsByTopic(topic: string): TopicSubscription[] {\n    const subscriptions = new Array<TopicSubscription>();\n    Topics.computeWildcardSegmentPermutations(topic, ASTERISK).forEach(permutation => {\n      subscriptions.push(...this._subscriptionsByTopic.get(permutation) || []);\n    });\n    return subscriptions;\n  }\n\n  /**\n   * Allows observing the number of subscriptions on a topic. It is not allowed to use wildcards in the topic to observe.\n   *\n   * @param  topic - Specifies the topic to observe.\n   * @return An Observable that, when subscribed, emits the current number of subscribers on it. It never completes and\n   *         emits continuously when the number of subscribers changes.\n   */\n  public subscriptionCount$(topic: string): Observable<number> {\n    if (Topics.containsWildcardSegments(topic)) {\n      throw Error(`[TopicObserveError] Observing the number of subscribers is only allowed on exact topics. Exact topics must not contain wildcard segments. [topic='${topic}']`);\n    }\n\n    return new Observable(observer => {\n      const unsubscribe$ = new Subject<void>();\n\n      // Emit current subscription count.\n      let count = this.subscriptions({topic}).length;\n      observer.next(count);\n\n      // Increment count when matching subscriptions are added.\n      this.register$\n        .pipe(\n          filter(subscription => subscription.matches(topic)),\n          takeUntil(unsubscribe$),\n        )\n        .subscribe(() => {\n          count++;\n          observer.next(count);\n        });\n\n      // Decrement count when matching subscriptions are removed.\n      this.unregister$\n        .pipe(\n          filterArray(subscription => subscription.matches(topic)),\n          filter(subscriptions => subscriptions.length > 0),\n          takeUntil(unsubscribe$),\n        )\n        .subscribe(subscriptions => {\n          count -= subscriptions.length;\n          observer.next(count);\n        });\n\n      return (): void => unsubscribe$.next();\n    });\n  }\n}\n\n/**\n * Represents a subscription on a topic. The topic may contain wildcard segments.\n *\n * @ignore\n */\nexport class TopicSubscription extends MessageSubscription {\n\n  constructor(public readonly topic: string, subscriberId: string, client: Client) {\n    super(subscriberId, client);\n  }\n\n  /**\n   * Tests whether the given topic matches this subscription.\n   */\n  public matches(topic: string): boolean {\n    return topic === this.topic || new TopicMatcher(this.topic).match(topic).matches;\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {IntentMessage, TopicMessage} from '../../messaging.model';\n\n/**\n * Allows intercepting messages before their publication.\n *\n * An interceptor can reject or modify messages. Multiple interceptors can be registered, forming a chain in which each interceptor\n * is called one by one in registration order.\n *\n * For each message, the platform invokes the intercept method of the first registered interceptor, passing the message and the next\n * handler as arguments. By calling the next handler in the intercept method, message dispatching is continued. If there is no more\n * interceptor in the chain, the message is transported to the receivers, if any. But, if throwing an error in the intercept method,\n * message dispatching is aborted, and the error transported back to the sender.\n *\n * #### Registering Interceptors\n * You register interceptors with the bean manager when the host application starts. Interceptors can be registered only in the host\n * application. They are invoked in registration order.\n *\n * ```ts\n * Beans.register(MessageInterceptor, {useClass: MessageLoggerInterceptor, multi: true});\n * ```\n *\n * #### Filtering Messages for Interception\n * The platform passes all messages to the interceptors, including platform messages vital for its operation.\n * You can use the TopicMatcher to filter messages, allowing you to test whether a topic matches a pattern. The pattern must be a topic,\n * not a regular expression; thus, it must consist of one or more segments, each separated by a forward slash. The pattern can contain\n * wildcard segments. Wildcard segments start with a colon (:), acting act as a placeholder for any segment value.\n *\n * ```ts\n * class ProductValidatorInterceptor implements MessageInterceptor {\n *\n *   private topicMatcher = new TopicMatcher('product/:id');\n *\n *   public intercept(message: TopicMessage, next: Handler<TopicMessage>): Promise<void> {\n *     // Pass messages sent to other topics.\n *     if (!this.topicMatcher.match(message.topic).matches) {\n *       return next.handle(message);\n *     }\n *\n *     // Validate the payload of the message.\n *     if (isValid(message.body)) {\n *       return next.handle(message);\n *     }\n *\n *     throw Error('Message failed schema validation');\n *   }\n * }\n * ```\n *\n * @category Messaging\n */\nexport abstract class MessageInterceptor implements Interceptor<TopicMessage, Handler<TopicMessage>> {\n\n  /**\n   * Intercepts a message before being published to its topic.\n   *\n   * Decide if to continue publishing by passing the message to the next handler, or to reject publishing by throwing an error,\n   * or to swallow the message by not calling the next handler at all. If rejecting publishing, the error is transported to the\n   * message publisher.\n   *\n   * Important: When passing the message to the next handler, either return its Promise or await it.\n   * Otherwise, errors of subsequent interceptors would not be reported to the sender.\n   *\n   * @param  message - the message to be published to its topic\n   * @param  next - the next handler in the chain; invoke its {@link Handler.handle} method to continue publishing.\n   * @throws throw an error to reject publishing; the error is transported to the message publisher.\n   */\n  public abstract intercept(message: TopicMessage, next: Handler<TopicMessage>): Promise<void>;\n}\n\n/**\n * Allows intercepting intents before their publication.\n *\n * An interceptor can reject or modify intents. Multiple interceptors can be registered, forming a chain in which each interceptor\n * is called one by one in registration order.\n *\n * For each intent, the platform invokes the intercept method of the first registered interceptor, passing the intent and the next\n * handler as arguments. By calling the next handler in the intercept method, intent dispatching is continued. If there is no more\n * interceptor in the chain, the intent is transported to the receivers, if any. But, if throwing an error in the intercept method,\n * intent dispatching is aborted, and the error transported back to the sender.\n *\n * #### Registering Interceptors\n * You register interceptors with the bean manager when the host application starts. Interceptors can be registered only in the host\n * application. They are invoked in registration order.\n *\n * ```ts\n * Beans.register(IntentInterceptor, {useClass: IntentLoggerInterceptor, multi: true});\n * ```\n *\n * #### Filtering intents for Interception\n * The platform passes all intents to the interceptors. The interceptor must filter intents of interest.\n *\n * @category Messaging\n */\nexport abstract class IntentInterceptor implements Interceptor<IntentMessage, Handler<IntentMessage>> {\n\n  /**\n   * Intercepts an intent before being published.\n   *\n   * Decide if to continue publishing by passing the intent to the next handler, or to reject publishing by throwing an error,\n   * or to swallow the intent by not calling the next handler at all. If rejecting publishing, the error is transported to\n   * the intent issuer.\n   *\n   * Important: When passing the message to the next handler, either return its Promise or await it.\n   * Otherwise, errors of subsequent interceptors would not be reported to the sender.\n   *\n   * @param  intent - the intent to be published\n   * @param  next - the next handler in the chain; invoke its {@link Handler.handle} method to continue publishing.\n   * @throws throw an error to reject publishing; the error is transported to the intent issuer.\n   */\n  public abstract intercept(intent: IntentMessage, next: Handler<IntentMessage>): Promise<void>;\n}\n\n/**\n * Chain to intercept messages before they are published. The chain is implemented according to the 'Chain of Responsibility' design pattern.\n *\n * A message travels along the chain of interceptors. If all interceptors let the message pass, it is published.\n *\n * @internal\n */\nexport interface PublishInterceptorChain<T> {\n\n  /**\n   * Passes a message along the chain of interceptors, if any, and publishes it.\n   *\n   * Each interceptor in the chain can reject publishing by throwing an error, ignore the message by not calling the next handler,\n   * or continue the chain by calling the next handler.\n   *\n   * @throws throws an error if an interceptor rejected publishing.\n   */\n  interceptAndPublish(message: T): Promise<void>;\n}\n\n/**\n * Assembles the given interceptors to a chain of handlers which are called one after another. The publisher is added as terminal handler.\n *\n * @param interceptors - interceptors to be assembled to a chain\n * @param publisher - terminal handler to publish messages\n * @internal\n */\nexport function chainInterceptors<T>(interceptors: Interceptor<T, Handler<T>>[], publisher: (message: T) => Promise<void>): PublishInterceptorChain<T> {\n  const terminalHandler = new class extends Handler<T> {\n    public handle(message: T): Promise<void> {\n      return publisher(message);\n    }\n  };\n\n  const handlerChain = interceptors.reduceRight((next, interceptor) => new class extends Handler<T> {\n    public handle(element: T): Promise<void> {\n      return interceptor.intercept(element, next);\n    }\n  }, terminalHandler);\n\n  return new class implements PublishInterceptorChain<T> {\n    public interceptAndPublish(element: T): Promise<void> {\n      return handlerChain.handle(element);\n    }\n  };\n}\n\n/**\n * Allows the interception of messages or intents before their publication.\n *\n * @see {@link MessageInterceptor}\n * @see {@link IntentInterceptor}\n */\nexport interface Interceptor<T, H extends Handler<T>> {\n\n  intercept(message: T, next: H): Promise<void>;\n}\n\n/**\n * Represents a handler in the chain of interceptors.\n *\n * @category Messaging\n */\nexport abstract class Handler<T> {\n  /**\n   * Invoke to continue the chain with the given message.\n   */\n  public abstract handle(message: T): Promise<void>;\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\n// See semantic versioning specification: https://semver.org/#semantic-versioning-specification-semver\nconst SEMVER_REGEX = /(?<major>\\d+)\\.(?<minor>\\d+)\\.(?<patch>\\d+)(-(?<prerelease>.+))?/;\n\n/*\n * Allows working with semantic versions (semver).\n *\n * ### Why not using `semver` NPM package (as of 2022-04)\n * We no longer depend on the NPM package `semver` as not yet been published as an ECMAScript module (ESM).\n * It is recommended to avoid dependencies on CommonJS modules as bundlers and minifiers may not be able to\n * optimize the application code, resulting in larger bundle size.\n *\n * For example, the Angular compiler would generate the following warning when using `semver`:\n * `Warning: ... depends on 'semver'. CommonJS or AMD dependencies can cause optimization bailouts.`\n *\n * ---\n *\n * The following rules for comparing two semantic versions are copied directly from the semantic versioning specification,\n * which can be found here: https://semver.org/#semantic-versioning-specification-semver\n *\n * ```\n * Precedence refers to how versions are compared to each other when ordered.\n *\n * 1. Precedence MUST be calculated by separating the version into major, minor, patch and pre-release identifiers\n *    in that order (Build metadata does not figure into precedence).\n *\n * 2. Precedence is determined by the first difference when comparing each of these identifiers from left to right as follows:\n *    Major, minor, and patch versions are always compared numerically.\n *    Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\n *\n * 3. When major, minor, and patch are equal, a pre-release version has lower precedence than a normal version:\n *    Example: 1.0.0-alpha < 1.0.0.\n *\n * 4. Precedence for two pre-release versions with the same major, minor, and patch version MUST be determined by comparing\n *    each dot separated identifier from left to right until a difference is found as follows:\n *\n *    1. Identifiers consisting of only digits are compared numerically.\n *    2. Identifiers with letters or hyphens are compared lexically in ASCII sort order.\n *    3. Numeric identifiers always have lower precedence than non-numeric identifiers.\n *    4. A larger set of pre-release fields has a higher precedence than a smaller set, if all of the preceding identifiers are equal.\n *\n *   Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\n * ```\n *\n * @internal\n */\nexport namespace semver {\n\n  /**\n   * Return the major version number.\n   */\n  export function major(version: string | undefined | null): number {\n    return parseVersion(version ?? '0.0.0').major;\n  }\n\n  /**\n   * Tests if `version1` is lower than `version2`.\n   *\n   * @return `true` if `version1` is lower than `version2`, or `false` otherwise.\n   *         The values `null` and `undefined` have lower precedence than a normal version.\n   * @throws throws if passed version is not a valid semantic version.\n   */\n  export function lt(version1: string | undefined | null, version2: string | undefined | null): boolean {\n    return compare(version1, version2) < 0;\n  }\n\n  /**\n   * Compares given two versions.\n   *\n   * @return -1: if `v1` is lower than `v2`\n   *          0: if both version are identical\n   *         +1: if `v1` is greater than `v2`\n   */\n  function compare(v1: string | undefined | null, v2: string | undefined | null): number {\n    if (!v1 && v2) {\n      return -1;\n    }\n    if (!v1 && !v2) {\n      return 0;\n    }\n    if (v1 && !v2) {\n      return +1;\n    }\n\n    const semVer1 = parseVersion(v1!);\n    const semVer2 = parseVersion(v2!);\n\n    // Compare major version\n    const majorCompare = Math.sign(semVer1.major - semVer2.major);\n    if (majorCompare !== 0) {\n      return majorCompare;\n    }\n\n    // Compare minor version\n    const minorCompare = Math.sign(semVer1.minor - semVer2.minor);\n    if (minorCompare !== 0) {\n      return minorCompare;\n    }\n\n    // Compare patch version\n    const patchCompare = Math.sign(semVer1.patch - semVer2.patch);\n    if (patchCompare !== 0) {\n      return patchCompare;\n    }\n\n    // Compare pre-release portion.\n    return comparePreRelease(semVer1, semVer2);\n  }\n\n  /**\n   * Compares the prerelease portion of two versions.\n   *\n   * @return -1: if `version1` is lower than `version2`\n   *          0: if both version are identical\n   *         +1: if `version1` is greater than `version2`\n   */\n  function comparePreRelease(v1: SemVer, v2: SemVer): number {\n    if (v1.preRelease && !v2.preRelease) {\n      return -1;\n    }\n    if (!v1.preRelease && !v2.preRelease) {\n      return 0;\n    }\n    if (!v1.preRelease && v2.preRelease) {\n      return 1;\n    }\n\n    for (let i = 0; i < Math.max(v1.preRelease!.length, v2.preRelease!.length); i++) {\n      const identifier1 = v1.preRelease![i];\n      const identifier2 = v2.preRelease![i];\n\n      if (identifier1 === undefined) {\n        return -1;\n      }\n      if (identifier2 === undefined) {\n        return +1;\n      }\n\n      if (typeof identifier1 === 'number' && typeof identifier2 === 'string') {\n        return -1;\n      }\n      if (typeof identifier1 === 'string' && typeof identifier2 === 'number') {\n        return +1;\n      }\n\n      if (identifier1 < identifier2) {\n        return -1;\n      }\n      if (identifier1 > identifier2) {\n        return +1;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Parses given version into a {@link SemVer} instance.\n   *\n   * @throws throws if passed version is not a valid semantic version.\n   */\n  function parseVersion(version: string): SemVer {\n    const match = version.match(SEMVER_REGEX);\n    if (!match) {\n      throw Error(`[SemVerError] Version '${version}' is not a valid semantic version (semver).`);\n    }\n\n    return {\n      major: +match.groups!['major']!,\n      minor: +match.groups!['minor']!,\n      patch: +match.groups!['patch']!,\n      preRelease: match.groups!['prerelease']?.split('.').map(identifier => {\n        const numericIdentifier = +identifier;\n        return Number.isNaN(numericIdentifier) ? identifier : numericIdentifier;\n      }),\n    };\n  }\n\n  /**\n   * Represents a parsed semantic version.\n   */\n  interface SemVer {\n    major: number;\n    minor: number;\n    patch: number;\n    preRelease?: Array<string | number>;\n  }\n}\n","/**\n * Specifies the interval (in milliseconds) at which connected clients must send a heartbeat to indicate connectivity to the host.\n *\n * By default, if not set, a heartbeat interval of 60s is used.\n */\nexport const CLIENT_HEARTBEAT_INTERVAL = Symbol('CLIENT_HEARTBEAT_INTERVAL');\n\n/**\n * Specifies the delay (in milliseconds) for unregistering a stale client.\n *\n * By default, if not set, stale clients are unregistered after 2 seconds.\n */\nexport const STALE_CLIENT_UNREGISTER_DELAY = Symbol('STALE_CLIENT_UNREGISTER_DELAY');\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Qualifier} from './platform.model';\n\n/**\n * Allows testing whether a qualifier matches a qualifier pattern.\n */\nexport class QualifierMatcher {\n\n  private readonly _pattern: Qualifier;\n  private readonly _patternKeys: string[];\n  private readonly _flags: Flags;\n\n  /**\n   * Constructs a matcher that will match given qualifiers against a pattern.\n   *\n   * @param pattern - Pattern to match qualifiers. If `null` or `undefined`, uses an empty qualifier pattern.\n   * @param flags   - Controls how to match qualifiers.\n   */\n  constructor(pattern: Qualifier | null | undefined, flags: Flags) {\n    this._pattern = pattern || {};\n    this._patternKeys = Object.keys(this._pattern);\n    this._flags = flags;\n  }\n\n  /**\n   * Attempts to match the given qualifier against the pattern which was passed to the constructor.\n   */\n  public matches(qualifier: Qualifier | null | undefined): boolean {\n    const testee = qualifier || {};\n    const testeeKeys = Object.keys(testee);\n    const {_patternKeys: patternKeys, _pattern: pattern, _flags: flags} = this;\n\n    // Test if the testee has no additional entries\n    if (!patternKeys.includes('*') && testeeKeys.some(key => !patternKeys.includes(key))) {\n      return false;\n    }\n\n    return patternKeys\n      .filter(key => key !== '*')\n      .every(key => {\n        if (pattern[key] === testee[key]) {\n          return true;\n        }\n        if (flags.evalOptional && pattern[key] === '?') {\n          return true;\n        }\n        if (flags.evalAsterisk && pattern[key] === '*' && testee[key] !== undefined && testee[key] !== null) {\n          return true;\n        }\n        return false;\n      });\n  }\n}\n\n/**\n * Asserts the given qualifier not to contain wildcards.\n *\n * For example, the qualifier of an intent must be exact. The qualifier of an intention, on the other hand, allows wildcards.\n *\n * @internal\n */\nexport function assertExactQualifier(qualifier: Qualifier | null | undefined): void {\n  if (!qualifier || Object.keys(qualifier).length === 0) {\n    return;\n  }\n\n  if (Object.entries(qualifier).some(([key, value]) => key === '*' || value === '*' || value === '?')) {\n    throw Error(`[IllegalQualifierError] Intent qualifier must not contain wildcards. [qualifier='${JSON.stringify(qualifier)}']`);\n  }\n}\n\n/**\n * Controls how to match qualifiers.\n */\nexport interface Flags {\n  /**\n   * Flag to enable wildcard matching. If `false`, the asterisk wildcard character (`*`) is interpreted as value.\n   */\n  evalAsterisk: boolean;\n  /**\n   * Flag to enable optional qualifier entry matching. If `false`, the question mark wildcard character (`?`) is interpreted as value.\n   */\n  evalOptional: boolean;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Client} from '../client-registry/client';\nimport {MessageSubscription, MessageSubscriptionRegistry} from './message-subscription.registry';\nimport {Intent} from '../../messaging.model';\nimport {IntentSelector} from '../../client/messaging/intent-client';\nimport {QualifierMatcher} from '../../qualifier-matcher';\n\n/**\n * Central point for managing intent subscriptions.\n *\n * @ignore\n */\nexport class IntentSubscriptionRegistry extends MessageSubscriptionRegistry<IntentSubscription> {\n\n  public override subscriptions(filter?: {subscriberId?: string; clientId?: string; appSymbolicName?: string; intent?: Intent}): IntentSubscription[] {\n    return super.subscriptions(filter).filter(subscription => filter?.intent ? subscription.matches(filter.intent) : true);\n  }\n}\n\n/**\n * Represents a subscription for intents matching the passed selector.\n *\n * @ignore\n */\nexport class IntentSubscription extends MessageSubscription {\n\n  constructor(public readonly selector: IntentSelector, subscriberId: string, client: Client) {\n    super(subscriberId, client);\n  }\n\n  /**\n   * Tests whether the given intent matches this subscription.\n   *\n   * Note that only a type and qualifier check is performed, but not whether the application is eligible\n   * to receive matching intents, i.e., provides a fulfilling capability.\n   */\n  public matches(intent: Intent): boolean {\n    if (this.selector.type && this.selector.type !== intent.type) {\n      return false;\n    }\n    if (this.selector.qualifier && !new QualifierMatcher(this.selector.qualifier, {evalAsterisk: true, evalOptional: true}).matches(intent.qualifier)) {\n      return false;\n    }\n    return true;\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Subscription, timer} from 'rxjs';\nimport {APP_IDENTITY, VERSION} from '../../platform.model';\nimport {semver} from '../semver';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {MessageClient} from '../../client/messaging/message-client';\nimport {PlatformTopics} from '../../messaging.model';\nimport {debounceTime, filter, startWith} from 'rxjs/operators';\nimport {MessageHeaders} from '../../messaging.model';\nimport {Logger, LoggingContext} from '../../logger';\nimport {ClientRegistry} from './client.registry';\nimport {CLIENT_HEARTBEAT_INTERVAL, STALE_CLIENT_UNREGISTER_DELAY} from './client.constants';\nimport {Client} from './client';\nimport {Application} from '../application-registry';\nimport {IntentSubscription, IntentSubscriptionRegistry} from '../message-broker/intent-subscription.registry';\nimport {UUID} from '@scion/toolkit/uuid';\n\nexport class Client implements Client {\n\n  public readonly version: string;\n  public readonly deprecations: {legacyIntentSubscriptionApi: boolean; legacyRequestResponseSubscriptionApi: boolean};\n  private _heartbeat: Subscription | undefined;\n  private _heartbeatInterval: number;\n  private _staleClientUnregisterTimer: Subscription | undefined;\n  private _staleClientUnregisterDelay: number;\n\n  constructor(public readonly id: string,\n              public readonly window: Window,\n              public readonly application: Application,\n              version: string) {\n    this.version = version ?? '0.0.0';\n    this._heartbeatInterval = Beans.get(CLIENT_HEARTBEAT_INTERVAL);\n    this._staleClientUnregisterDelay = Beans.get(STALE_CLIENT_UNREGISTER_DELAY);\n    this.installHeartbeatMonitor();\n    this.deprecations = {\n      legacyIntentSubscriptionApi: semver.lt(this.version, '1.0.0-rc.8'),\n      legacyRequestResponseSubscriptionApi: semver.lt(this.version, '1.0.0-rc.9'),\n    };\n    if (this.deprecations.legacyIntentSubscriptionApi) {\n      this.installLegacyClientIntentSubscription();\n      Beans.get(Logger).warn(`[DEPRECATION][FE93C94] Application \"${application.symbolicName}\" is using a legacy protocol for subscribing to intents. Please update @scion/microfrontend-platform to version '${Beans.get(VERSION)}'.`, new LoggingContext(application.symbolicName, this.version));\n    }\n    if (this.deprecations.legacyRequestResponseSubscriptionApi) {\n      Beans.get(Logger).warn(`[DEPRECATION][F6DC38E] Application \"${application.symbolicName}\" is using a legacy request-response communication protocol. Please update @scion/microfrontend-platform to version '${Beans.get(VERSION)}'.`, new LoggingContext(application.symbolicName, this.version));\n    }\n  }\n\n  /**\n   * Monitors the heartbeat of this client to detect when this client is no longer connected to the host.\n   * When not receiving any more heartbeat, this client will be marked as stale and queued for removal.\n   *\n   * A client may fail to disconnect from the broker for a number of reasons:\n   * - The client was disposed without notice, i.e., without receiving the browser's \"unload\" event.\n   * - The browser discarded the \"DISCONNECT\" message because the client window became stale.\n   *   Typically, the browser discards messages for windows that are already closed or if another page\n   *   has been loaded into the window, both indicating a high load on the client during unloading.\n   */\n  private installHeartbeatMonitor(): void {\n    // The host app client does not send a heartbeat.\n    if (this.application.symbolicName === Beans.get(APP_IDENTITY)) {\n      return;\n    }\n\n    // Only clients of version 1.0.0-rc.1 or greater send a heartbeat.\n    if (semver.lt(this.version, '1.0.0-rc.1')) {\n      Beans.get(Logger).warn(`[VersionMismatch] Since '@scion/microfrontend-platform@1.0.0-rc.1', connected clients must send a heartbeat to indicate liveness. Please upgrade @scion/microfrontend-platform of application '${this.application.symbolicName}' from version '${this.version}' to version '${Beans.get(VERSION)}'.`, new LoggingContext(this.application.symbolicName, this.version));\n      return;\n    }\n\n    this._heartbeat = Beans.get(MessageClient).observe$(PlatformTopics.heartbeat(this.id))\n      .pipe(\n        filter(message => message.headers.get(MessageHeaders.ClientId) === this.id),\n        startWith(undefined as void),\n        debounceTime(2 * this._heartbeatInterval),\n      )\n      .subscribe(() => {\n        this.logStaleClientWarning();\n        Beans.get(ClientRegistry).unregisterClient(this);\n      });\n  }\n\n  public markStaleAndQueueForRemoval(): void {\n    if (this._staleClientUnregisterTimer) {\n      return;\n    }\n\n    this._staleClientUnregisterTimer = timer(this._staleClientUnregisterDelay).subscribe(() => {\n      this.logStaleClientWarning();\n      Beans.get(ClientRegistry).unregisterClient(this);\n    });\n    this._heartbeat?.unsubscribe();\n  }\n\n  public get stale(): boolean {\n    return !!this._staleClientUnregisterTimer || window.closed;\n  }\n\n  public dispose(): void {\n    this._heartbeat?.unsubscribe();\n    this._staleClientUnregisterTimer?.unsubscribe();\n  }\n\n  private logStaleClientWarning(): void {\n    Beans.get(Logger).warn(\n      `[StaleClient] Stale client registration of application '${this.application.symbolicName}' detected.\n       Removing stale registration. Most likely, the client could not disconnect from the broker, for example, because the client was\n       disposed without notice, i.e., without receiving the browser's \"unload\" event, or because the browser discarded the 'DISCONNECT'\n       message. Typically, the browser discards messages for windows that are already closed or if another page has been loaded into the\n       window, both indicating a high load on the client during unloading.`.replace(/\\s+/g, ' '),\n      new LoggingContext(this.application.symbolicName, this.version),\n    );\n  }\n\n  /**\n   * Installs legacy intent subscription support for clients older than version 1.0.0-rc.8.\n   */\n  private installLegacyClientIntentSubscription(): void {\n    const legacyClientSubscription = new IntentSubscription({}, UUID.randomUUID(), this);\n    Beans.get(IntentSubscriptionRegistry).register(legacyClientSubscription);\n  }\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent notification from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays notifications emitted by the source Observable, but drops\n * previous pending delayed emissions if a new notification arrives on the source\n * Observable. This operator keeps track of the most recent notification from the\n * source Observable, and emits that only when `dueTime` has passed\n * without any other notification appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous notification will be dropped\n * and will not be emitted and a new `dueTime` is scheduled.\n * If the completing event happens during `dueTime` the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during `dueTime` or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * notification to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, debounceTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified `dueTime`, and may drop some values\n * if they occur too frequently.\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let activeTask: Subscription | null = null;\n    let lastValue: T | null = null;\n    let lastTime: number | null = null;\n\n    const emit = () => {\n      if (activeTask) {\n        // We have a value! Free up memory first, then emit the value.\n        activeTask.unsubscribe();\n        activeTask = null;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\n      // This is called `dueTime` after the first value\n      // but we might have received new values during this window!\n\n      const targetTime = lastTime! + dueTime;\n      const now = scheduler.now();\n      if (now < targetTime) {\n        // On that case, re-schedule to the new target\n        activeTask = this.schedule(undefined, targetTime - now);\n        subscriber.add(activeTask);\n        return;\n      }\n\n      emit();\n    }\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          lastValue = value;\n          lastTime = scheduler.now();\n\n          // Only set up a task if it's not already up\n          if (!activeTask) {\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n            subscriber.add(activeTask);\n          }\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = activeTask = null;\n        }\n      )\n    );\n  });\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\n/**\n * Provides utilities for working with predicates.\n */\nexport namespace Predicates {\n\n  /**\n   * Negates the given predicate.\n   */\n  export function not<T>(predicate: Predicate<T>): Predicate<T> {\n    return (value: T) => !predicate(value);\n  }\n\n  /**\n   * Represents a predicate that always evaluates to `true`.\n   */\n  export const alwaysTrue = (): true => true;\n}\n\n/**\n * Represents a predicate (boolean-valued function) of one argument.\n */\nexport type Predicate<T> = (value: T) => boolean;\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {EMPTY, from, fromEvent, merge, MonoTypeOperatorFunction, Observable, of, Subject} from 'rxjs';\nimport {catchError, filter, mergeMap, share, takeUntil} from 'rxjs/operators';\nimport {IntentMessage, Message, MessageHeaders, TopicMessage} from '../../messaging.model';\nimport {ConnackMessage, IntentSubscribeCommand, MessageDeliveryStatus, MessageEnvelope, MessagingChannel, MessagingTransport, PlatformTopics, TopicSubscribeCommand, UnsubscribeCommand} from '../../messaging.model';\nimport {ApplicationRegistry} from '../application-registry';\nimport {ManifestRegistry} from '../manifest-registry/manifest-registry';\nimport {UUID} from '@scion/toolkit/uuid';\nimport {Logger, LoggingContext} from '../../logger';\nimport {runSafe} from '../../safe-runner';\nimport {TopicSubscription, TopicSubscriptionRegistry} from './topic-subscription.registry';\nimport {ClientRegistry} from '../client-registry/client.registry';\nimport {chainInterceptors, IntentInterceptor, MessageInterceptor, PublishInterceptorChain} from './message-interception';\nimport {Beans, Initializer, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {Runlevel} from '../../platform-state';\nimport {APP_IDENTITY, VERSION} from '../../platform.model';\nimport {bufferUntil} from '@scion/toolkit/operators';\nimport {filterByChannel, filterByTransport} from '../../operators';\nimport {Client} from '../client-registry/client';\nimport {semver} from '../semver';\nimport {CLIENT_HEARTBEAT_INTERVAL} from '../client-registry/client.constants';\nimport {Client} from '../client-registry/client';\nimport {stringifyError} from '../../error.util';\nimport {IntentSubscription, IntentSubscriptionRegistry} from './intent-subscription.registry';\nimport {TopicMatcher} from '../../topic-matcher.util';\nimport {Defined, Maps} from '@scion/toolkit/util';\nimport {MessageClient} from '../../client/messaging/message-client';\nimport {Predicates} from './predicates.util';\n\n/**\n * The broker is responsible for receiving all messages, filtering the messages, determining who is\n * subscribed to each message, and sending the message to these subscribed clients.\n *\n * The broker allows topic-based and intent-based messaging and supports retained messages.\n *\n * When the broker receives a message from a client, the broker identifies the sending client using the {@Window}\n * contained in the {@link MessageEvent}. The user agent sets the window, which cannot be tampered by the client.\n * However, when the client unloads, the window is not set because already been destroyed. Then, the broker identifies\n * the client using the unique client id. In both cases, the broker checks the origin of the message to match the\n * origin of the registered application.\n *\n * The broker processes client connect requests in runlevel 1 or higher. Message dispatching is enabled in runlevel 2.\n * Prior requests are buffered until entering the respective runlevel.\n *\n * @ignore\n */\nexport class MessageBroker implements Initializer, PreDestroy {\n\n  private readonly _destroy$ = new Subject<void>();\n  private readonly _clientMessage$: Observable<MessageEvent<MessageEnvelope>>;\n\n  private readonly _clientRegistry = Beans.get(ClientRegistry);\n  private readonly _topicSubscriptionRegistry = Beans.get(TopicSubscriptionRegistry);\n  private readonly _intentSubscriptionRegistry = Beans.get(IntentSubscriptionRegistry);\n\n  private readonly _retainedMessageStore = new Map<string, TopicMessage[]>();\n  private readonly _retainedIntentStore = new Map<string, IntentMessage[]>();\n\n  private readonly _applicationRegistry: ApplicationRegistry;\n  private readonly _manifestRegistry: ManifestRegistry;\n\n  private readonly _messagePublisher: PublishInterceptorChain<TopicMessage>;\n  private readonly _intentPublisher: PublishInterceptorChain<IntentMessage>;\n  private readonly _heartbeatInterval: number;\n\n  constructor() {\n    this._applicationRegistry = Beans.get(ApplicationRegistry);\n    this._manifestRegistry = Beans.get(ManifestRegistry);\n    this._heartbeatInterval = Beans.get(CLIENT_HEARTBEAT_INTERVAL);\n\n    // Construct a stream of messages sent by clients.\n    this._clientMessage$ = fromEvent<MessageEvent>(window, 'message')\n      .pipe(\n        filterByTransport(MessagingTransport.ClientToBroker),\n        filterByChannel(MessagingChannel.Intent, MessagingChannel.Topic, MessagingChannel.TopicSubscribe, MessagingChannel.TopicUnsubscribe, MessagingChannel.IntentSubscribe, MessagingChannel.IntentUnsubscribe),\n        bufferUntil(Beans.whenRunlevel(Runlevel.Two)),\n        checkOriginTrusted(),\n        catchErrorAndRetry(),\n        share(),\n      );\n\n    // Install client connect listeners.\n    this.installClientConnectListener();\n    this.installClientDisconnectListener();\n\n    // Install message handling.\n    this.installMessageDispatcher();\n    this.installTopicSubscribeListener();\n    this.installTopicUnsubscribeListener();\n    this.installTopicSubscriberCountObserver();\n    this.sendRetainedMessageOnSubscribe();\n\n    // Install intent handling.\n    this.installIntentDispatcher();\n    this.installIntentSubscribeListener();\n    this.installIntentUnsubscribeListener();\n    this.sendRetainedIntentOnSubscribe();\n    this.deleteRetainedIntentOnCapabilityUnregister();\n\n    // Assemble message interceptors to a chain of handlers which are called one after another. The publisher is added as terminal handler.\n    this._messagePublisher = this.createMessagePublisher();\n    this._intentPublisher = this.createIntentPublisher();\n  }\n\n  public init(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  private installClientConnectListener(): void {\n    fromEvent<MessageEvent>(window, 'message')\n      .pipe(\n        filterByTransport(MessagingTransport.ClientToBroker),\n        filterByChannel(MessagingChannel.ClientConnect),\n        bufferUntil(Beans.whenRunlevel(Runlevel.One)),\n        catchErrorAndRetry(),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MessageEvent) => runSafe(() => {\n        // Ignore stale CONNECT request, e.g. if the origin window has been closed or a page with a different origin has been loaded.\n        if (!event.source) {\n          Beans.get(Logger).debug(`[CONNECT] Ignoring stale connect request from \"${event.origin}\".`);\n          return;\n        }\n\n        const eventSource: Window = event.source as Window;\n        const envelope: MessageEnvelope<TopicMessage<void>> = event.data;\n        const clientAppName = envelope.message.headers.get(MessageHeaders.AppSymbolicName);\n        const clientMessageTarget = new MessageTarget(event);\n        const replyTo = envelope.message.headers.get(MessageHeaders.ReplyTo);\n\n        if (!clientAppName) {\n          const warning = `Client connect attempt rejected by the message broker: Bad request. [origin='${event.origin}']`;\n          Beans.get(Logger).warn(`[CONNECT] ${warning}`);\n          sendTopicMessage<ConnackMessage>(clientMessageTarget, {\n            topic: replyTo,\n            body: {returnCode: 'refused:bad-request', returnMessage: `[MessageClientConnectError] ${warning}`},\n            headers: new Map(),\n          });\n          return;\n        }\n\n        const application = this._applicationRegistry.getApplication(clientAppName);\n        if (!application) {\n          const warning = `Client connect attempt rejected by the message broker: Unknown client. [app='${clientAppName}']`;\n          Beans.get(Logger).warn(`[CONNECT] ${warning}`);\n          sendTopicMessage<ConnackMessage>(clientMessageTarget, {\n            topic: replyTo,\n            body: {returnCode: 'refused:rejected', returnMessage: `[MessageClientConnectError] ${warning}`},\n            headers: new Map(),\n          });\n          return;\n        }\n\n        if (event.origin !== application.messageOrigin) {\n          const warning = `Client connect attempt blocked by the message broker: Wrong origin [actual='${event.origin}', expected='${application.messageOrigin}', app='${application.symbolicName}']`;\n          Beans.get(Logger).warn(`[CONNECT] ${warning}`);\n\n          sendTopicMessage<ConnackMessage>(clientMessageTarget, {\n            topic: replyTo,\n            body: {returnCode: 'refused:blocked', returnMessage: `[MessageClientConnectError] ${warning}`},\n            headers: new Map(),\n          });\n          return;\n        }\n\n        // Check if the client is already connected. If already connected, do nothing. A client can potentially initiate multiple connect requests, for example,\n        // when not receiving connect confirmation in time.\n        const currentClient = this._clientRegistry.getByWindow(eventSource);\n        if (currentClient && currentClient.application.messageOrigin === event.origin && currentClient.application.symbolicName === application.symbolicName) {\n          sendTopicMessage<ConnackMessage>(currentClient, {\n            topic: replyTo,\n            body: {returnCode: 'accepted', clientId: currentClient.id, heartbeatInterval: this._heartbeatInterval},\n            headers: new Map(),\n          });\n          return;\n        }\n\n        const client = new Client(UUID.randomUUID(), eventSource, application, envelope.message.headers.get(MessageHeaders.Version));\n        this._clientRegistry.registerClient(client);\n\n        // Check if the client is compatible with the platform version of the host.\n        if (semver.major(client.version) !== semver.major(Beans.get<string>(VERSION))) {\n          Beans.get(Logger).warn(`[VersionMismatch] Application '${application.symbolicName}' uses a different major version of the @scion/microfrontend-platform than the host application, which may not be compatible. Please upgrade @scion/microfrontend-platform of application '${application.symbolicName}' from version '${(client.version)}' to version '${(Beans.get<string>(VERSION))}'.`, new LoggingContext(application.symbolicName, client.version));\n        }\n\n        sendTopicMessage<ConnackMessage>(client, {\n          topic: replyTo,\n          body: {returnCode: 'accepted', clientId: client.id, heartbeatInterval: this._heartbeatInterval},\n          headers: new Map(),\n        });\n      }));\n  }\n\n  /**\n   * Listens for client disconnect requests.\n   */\n  private installClientDisconnectListener(): void {\n    fromEvent<MessageEvent>(window, 'message')\n      .pipe(\n        filterByTransport(MessagingTransport.ClientToBroker),\n        filterByChannel(MessagingChannel.ClientDisconnect),\n        bufferUntil(Beans.whenRunlevel(Runlevel.One)),\n        checkOriginTrusted(),\n        catchErrorAndRetry(),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MessageEvent<MessageEnvelope>) => runSafe(() => {\n        const client = getSendingClient(event);\n        this._clientRegistry.unregisterClient(client);\n      }));\n  }\n\n  /**\n   * Replies to requests to observe the number of subscribers on a topic.\n   */\n  private installTopicSubscriberCountObserver(): void {\n    Beans.get(MessageClient).observe$<string>(PlatformTopics.RequestSubscriberCount)\n      .pipe(takeUntil(this._destroy$))\n      .subscribe(request => {\n        const topic = request.body!;\n        const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n        const unsubscribe$ = this._topicSubscriptionRegistry.subscriptionCount$(replyTo).pipe(filter(count => count === 0));\n\n        this._topicSubscriptionRegistry.subscriptionCount$(topic)\n          .pipe(takeUntil(merge(this._destroy$, unsubscribe$)))\n          .subscribe(count => Beans.get(MessageClient).publish(replyTo, count)); // eslint-disable-line rxjs/no-nested-subscribe\n      });\n  }\n\n  /**\n   * Dispatches topic messages to subscribed clients.\n   */\n  private installMessageDispatcher(): void {\n    this._clientMessage$\n      .pipe(\n        filterByChannel<TopicMessage>(MessagingChannel.Topic),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MessageEvent<MessageEnvelope<TopicMessage>>) => runSafe(async () => {\n        const client = getSendingClient(event);\n        const message = event.data.message;\n        const messageId = message.headers.get(MessageHeaders.MessageId);\n\n        if (!message.topic) {\n          const error = '[MessagingError] Missing message property: topic';\n          sendDeliveryStatusError(client, messageId, error);\n          return;\n        }\n\n        // If a retained message without payload, remove any stored retained message on that topic, if any.\n        if (message.retain && !isRequest(message) && message.body === undefined) {\n          Maps.removeListValue(this._retainedMessageStore, message.topic, Predicates.not(isRequest));\n          sendDeliveryStatusSuccess(client, messageId);\n          return;\n        }\n\n        try {\n          // If a request of a request-response communication, create a subscription for the requestor to receive replies.\n          const requestorReplySubscription = this.subscribeForRepliesIfRequest(message, client);\n          // Ensure the message header 'SUBSCRIBER_ID' to be removed; is set in request-response communication by the client gateway.\n          message.headers.delete(MessageHeaders.SubscriberId);\n          // Dispatch the message.\n          await this._messagePublisher.interceptAndPublish(message);\n          // If a retained message or request, store it for late subscribers.\n          this.storeMessageIfRetained(message, requestorReplySubscription);\n\n          sendDeliveryStatusSuccess(client, messageId);\n        }\n        catch (error) {\n          sendDeliveryStatusError(client, messageId, error);\n        }\n      }));\n  }\n\n  /**\n   * Dispatches intents to qualified clients.\n   */\n  private installIntentDispatcher(): void {\n    this._clientMessage$\n      .pipe(\n        filterByChannel<IntentMessage>(MessagingChannel.Intent),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MessageEvent<MessageEnvelope<IntentMessage>>) => runSafe(async () => {\n        const client = getSendingClient(event);\n        const message = event.data.message;\n        const messageId = message.headers.get(MessageHeaders.MessageId);\n\n        if (!message.intent) {\n          const error = '[MessagingError] Missing message property: intent';\n          sendDeliveryStatusError(client, messageId, error);\n          return;\n        }\n\n        if (!message.intent.type) {\n          const error = '[MessagingError] Missing message property: type';\n          sendDeliveryStatusError(client, messageId, error);\n          return;\n        }\n\n        if (!this._manifestRegistry.hasIntention(message.intent, client.application.symbolicName)) {\n          const error = `[NotQualifiedError] Application '${client.application.symbolicName}' is not qualified to publish intents of the type '${message.intent.type}' and qualifier '${JSON.stringify(message.intent.qualifier || {})}'. Ensure to have listed the intention in the application manifest.`;\n          sendDeliveryStatusError(client, messageId, error);\n          return;\n        }\n\n        // Find capabilities fulfilling the intent, or send an error otherwise.\n        const capabilities = this._manifestRegistry.resolveCapabilitiesByIntent(message.intent, client.application.symbolicName);\n        if (capabilities.length === 0) {\n          const error = `[NullProviderError] No application found to provide a capability of the type '${message.intent.type}' and qualifiers '${JSON.stringify(message.intent.qualifier || {})}'. Maybe, the capability is not public API or the providing application not available.`;\n          sendDeliveryStatusError(client, messageId, error);\n          return;\n        }\n\n        // If a retained message without payload, remove any stored retained message for the resolved capabilities.\n        if (message.retain && !isRequest(message) && message.body === undefined) {\n          capabilities.forEach(capability => {\n            Maps.removeListValue(this._retainedIntentStore, capability.metadata!.id, Predicates.not(isRequest));\n            sendDeliveryStatusSuccess(client, messageId);\n          });\n          return;\n        }\n\n        try {\n          // If a request of a request-response communication, create a subscription for the requestor to receive replies.\n          const requestorReplySubscription = this.subscribeForRepliesIfRequest(message, client);\n          // Ensure the message header 'SUBSCRIBER_ID' to be removed; is set in request-response communication by the client gateway.\n          message.headers.delete(MessageHeaders.SubscriberId);\n          // Dispatch the message.\n          const messagesPerCapability = await Promise.all(capabilities\n            .map<IntentMessage>(capability => ({...message, capability}))\n            .map(message => this._intentPublisher.interceptAndPublish(message).then(() => message)));\n          // If a retained message or request, store it for late subscribers.\n          messagesPerCapability.forEach(message => this.storeIntentIfRetained(message, requestorReplySubscription));\n          sendDeliveryStatusSuccess(client, messageId);\n        }\n        catch (error) {\n          sendDeliveryStatusError(client, messageId, error);\n        }\n      }));\n  }\n\n  /**\n   * Installs a listener that sends retained messages to new subscribers.\n   */\n  private sendRetainedMessageOnSubscribe(): void {\n    this._topicSubscriptionRegistry.register$\n      .pipe(takeUntil(this._destroy$))\n      .subscribe(subscription => runSafe(() => {\n        Array.from(this._retainedMessageStore.values())\n          .flat()\n          .filter(retainedMessage => subscription.matches(retainedMessage.topic))\n          .forEach(retainedMessage => this._messagePublisher.interceptAndPublish({\n            ...retainedMessage,\n            headers: new Map(retainedMessage.headers).set(MessageHeaders.SubscriberId, subscription.subscriberId),\n          }));\n      }));\n  }\n\n  /**\n   * Installs a listener that sends retained intents to new subscribers.\n   */\n  private sendRetainedIntentOnSubscribe(): void {\n    this._intentSubscriptionRegistry.register$\n      .pipe(takeUntil(this._destroy$))\n      .subscribe(subscription => runSafe(() => {\n        Array.from(this._retainedIntentStore.values())\n          .flat()\n          .filter(retainedMessage => subscription.client.application.symbolicName === retainedMessage.capability.metadata!.appSymbolicName)\n          .filter(retainedMessage => subscription.matches(retainedMessage.intent))\n          .forEach(retainedMessage => this._intentPublisher.interceptAndPublish({\n            ...retainedMessage,\n            headers: new Map(retainedMessage.headers).set(MessageHeaders.SubscriberId, subscription.subscriberId),\n          }));\n      }));\n  }\n\n  /**\n   * Installs a listener that removes retained intent(s) when associated capability is removed.\n   */\n  private deleteRetainedIntentOnCapabilityUnregister(): void {\n    this._manifestRegistry.capabilityUnregister$\n      .pipe(\n        mergeMap(capabilities => from(capabilities)),\n        takeUntil(this._destroy$),\n      )\n      .subscribe(capability => runSafe(() => {\n        Maps.removeListValue(this._retainedIntentStore, capability.metadata!.id, Predicates.alwaysTrue);\n      }));\n  }\n\n  /**\n   * Listens for topic subscription requests.\n   */\n  private installTopicSubscribeListener(): void {\n    this._clientMessage$\n      .pipe(\n        filterByChannel<TopicSubscribeCommand>(MessagingChannel.TopicSubscribe),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MessageEvent<MessageEnvelope<TopicSubscribeCommand>>) => runSafe(() => {\n        const client = getSendingClient(event);\n        const envelope = event.data;\n        const messageId = envelope.message.headers.get(MessageHeaders.MessageId);\n\n        try {\n          const subscriberId = Defined.orElseThrow(envelope.message.subscriberId, () => Error('[TopicSubscribeError] Missing property: subscriberId'));\n          const topic = Defined.orElseThrow(envelope.message.topic, () => Error('[TopicSubscribeError] Missing property: topic'));\n          this._topicSubscriptionRegistry.register(new TopicSubscription(topic, subscriberId, client));\n          sendDeliveryStatusSuccess(client, messageId);\n        }\n        catch (error) {\n          sendDeliveryStatusError(client, messageId, error);\n        }\n      }));\n  }\n\n  /**\n   * Listens for topic unsubscription requests.\n   */\n  private installTopicUnsubscribeListener(): void {\n    this._clientMessage$\n      .pipe(\n        filterByChannel<UnsubscribeCommand>(MessagingChannel.TopicUnsubscribe),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MessageEvent<MessageEnvelope<UnsubscribeCommand>>) => runSafe(() => {\n        const client = getSendingClient(event);\n        const envelope = event.data;\n        const messageId = envelope.message.headers.get(MessageHeaders.MessageId);\n\n        try {\n          const subscriberId = Defined.orElseThrow(envelope.message.subscriberId, () => Error('[TopicUnsubscribeError] Missing property: subscriberId'));\n          this._topicSubscriptionRegistry.unregister({subscriberId});\n          sendDeliveryStatusSuccess(client, messageId);\n        }\n        catch (error) {\n          sendDeliveryStatusError(client, messageId, error);\n        }\n      }));\n  }\n\n  /**\n   * Listens for intent subscription requests.\n   */\n  private installIntentSubscribeListener(): void {\n    this._clientMessage$\n      .pipe(\n        filterByChannel<IntentSubscribeCommand>(MessagingChannel.IntentSubscribe),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MessageEvent<MessageEnvelope<IntentSubscribeCommand>>) => runSafe(() => {\n        const client = getSendingClient(event);\n        const envelope = event.data;\n        const messageId = envelope.message.headers.get(MessageHeaders.MessageId);\n\n        try {\n          const subscriberId = Defined.orElseThrow(envelope.message.subscriberId, () => Error('[IntentSubscribeError] Missing property: subscriberId'));\n          this._intentSubscriptionRegistry.register(new IntentSubscription(envelope.message.selector || {}, subscriberId, client));\n          sendDeliveryStatusSuccess(client, messageId);\n        }\n        catch (error) {\n          sendDeliveryStatusError(client, messageId, error);\n        }\n      }));\n  }\n\n  /**\n   * Listens for intent unsubscription requests.\n   */\n  private installIntentUnsubscribeListener(): void {\n    this._clientMessage$\n      .pipe(\n        filterByChannel<UnsubscribeCommand>(MessagingChannel.IntentUnsubscribe),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MessageEvent<MessageEnvelope<UnsubscribeCommand>>) => runSafe(() => {\n        const client = getSendingClient(event);\n        const envelope = event.data;\n        const messageId = envelope.message.headers.get(MessageHeaders.MessageId);\n\n        try {\n          const subscriberId = Defined.orElseThrow(envelope.message.subscriberId, () => Error('[IntentUnsubscribeError] Missing property: subscriberId'));\n          this._intentSubscriptionRegistry.unregister({subscriberId});\n          sendDeliveryStatusSuccess(client, messageId);\n        }\n        catch (error) {\n          sendDeliveryStatusError(client, messageId, error);\n        }\n      }));\n  }\n\n  /**\n   * Creates the interceptor chain to intercept message publishing. The publisher is added as terminal handler.\n   */\n  private createMessagePublisher(): PublishInterceptorChain<TopicMessage> {\n    return chainInterceptors(Beans.all(MessageInterceptor), async (message: TopicMessage): Promise<void> => {\n      const subscribers = this._topicSubscriptionRegistry.subscriptions({\n        subscriberId: message.headers.get(MessageHeaders.SubscriberId),\n        topic: message.topic,\n      });\n\n      // If request-reply communication, reply with an error if no subscriber is registered to answer the request.\n      if (isRequest(message) && !message.retain && !subscribers.length) {\n        throw Error(`[MessagingError] No subscriber registered to answer the request [topic=${message.topic}]`);\n      }\n\n      subscribers.forEach(subscriber => runSafe(() => sendTopicMessage(subscriber, message)));\n    });\n  }\n\n  /**\n   * Creates the interceptor chain to intercept intent publishing. The publisher is added as terminal handler.\n   */\n  private createIntentPublisher(): PublishInterceptorChain<IntentMessage> {\n    return chainInterceptors(Beans.all(IntentInterceptor), async (message: IntentMessage): Promise<void> => {\n      const subscribers = this._intentSubscriptionRegistry.subscriptions({\n        subscriberId: message.headers.get(MessageHeaders.SubscriberId),\n        appSymbolicName: message.capability.metadata!.appSymbolicName,\n        intent: message.intent,\n      });\n\n      // If request-reply communication, reply with an error if no subscriber is registered to answer the intent.\n      if (isRequest(message) && !message.retain && !subscribers.length) {\n        throw Error(`[MessagingError] No subscriber registered to answer the intent [intent=${JSON.stringify(message.intent)}]`);\n      }\n\n      subscribers.forEach(subscriber => runSafe(() => sendIntentMessage(subscriber, message)));\n    });\n  }\n\n  /**\n   * Create a subscription for the sender to receive replies if request-response communication.\n   */\n  private subscribeForRepliesIfRequest(message: Message, sender: Client): TopicSubscription | null {\n    if (!isRequest(message)) {\n      return null;\n    }\n    if (sender.deprecations.legacyRequestResponseSubscriptionApi) {\n      return null;\n    }\n\n    const subscriberId = Defined.orElseThrow(message.headers.get(MessageHeaders.SubscriberId), () => Error('[MessagingError] Missing message header: subscriberId'));\n    const replyTo = message.headers.get(MessageHeaders.ReplyTo);\n    const subscription = new TopicSubscription(replyTo, subscriberId, sender);\n    this._topicSubscriptionRegistry.register(subscription);\n    return subscription;\n  }\n\n  /**\n   * Stores the message if retained.\n   *\n   * Unlike a regular message, a retained message remains in the broker and is delivered to new subscribers, even if they subscribe\n   * after the request has been sent. The broker stores one retained message per topic, i.e., a later sent retained message will replace\n   * a previously sent retained message. This, however, does not apply to retained requests in request-response communication.\n   * Retained requests are NEVER replaced and remain in the broker until the requestor unsubscribes.\n   *\n   * @param message - Message to be stored if retained.\n   * @param requestorReplySubscription - Subscription of the requestor to receive replies; only set in request-response communication.\n   */\n  private storeMessageIfRetained(message: TopicMessage, requestorReplySubscription: TopicSubscription | null): void {\n    if (!message.retain) {\n      return;\n    }\n\n    // If a retained request, store it. Retained requests are not replaced and are retained until the requestor unsubscribes.\n    if (isRequest(message)) {\n      Defined.orElseThrow(requestorReplySubscription, () => Error('[InternalMessagingError] An unexpected error occurred. Expected subscription not to be null.'));\n      Maps.addListValue(this._retainedMessageStore, message.topic, message);\n      requestorReplySubscription!.whenUnsubscribe.then(() => Maps.removeListValue(this._retainedMessageStore, message.topic, message));\n    }\n    // If a retained message (not a request), replace any previously stored retained message on that topic, if any.\n    else {\n      Maps.removeListValue(this._retainedMessageStore, message.topic, Predicates.not(isRequest));\n      Maps.addListValue(this._retainedMessageStore, message.topic, message);\n    }\n  }\n\n  private storeIntentIfRetained(message: IntentMessage, requestorReplySubscription: TopicSubscription | null): void {\n    if (!message.retain) {\n      return;\n    }\n\n    const capabilityId = message.capability.metadata!.id;\n\n    // If a retained request, store it. Retained requests are not replaced and are retained until the requestor unsubscribes.\n    if (isRequest(message)) {\n      Defined.orElseThrow(requestorReplySubscription, () => Error('[InternalMessagingError] An unexpected error occurred. Expected subscription not to be null.'));\n      Maps.addListValue(this._retainedIntentStore, capabilityId, message);\n      requestorReplySubscription!.whenUnsubscribe.then(() => Maps.removeListValue(this._retainedIntentStore, capabilityId, message));\n    }\n    // If a retained message (i.e. not a request), replace any previously stored retained message for that capability, if any.\n    else {\n      Maps.removeListValue(this._retainedIntentStore, capabilityId, Predicates.not(isRequest));\n      Maps.addListValue(this._retainedIntentStore, capabilityId, message);\n    }\n  }\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n\n/**\n * Resolves to the client that sent the passed message.\n *\n * Throws an error if the client could not be resolved.\n *\n * @ignore\n */\nfunction getSendingClient(event: MessageEvent<MessageEnvelope>): Client {\n  const clientId = event.data.message.headers.get(MessageHeaders.ClientId);\n  const client = Beans.get(ClientRegistry).getByClientId(clientId)!;\n  if (!client) {\n    throw Error(`[NullClientError] Client not found in client registry. [clientId=${clientId}]`);\n  }\n  return client;\n}\n\n/**\n * Passes only messages originating from trusted and registered clients.\n *\n * @ignore\n */\nfunction checkOriginTrusted<T extends Message>(): MonoTypeOperatorFunction<MessageEvent<MessageEnvelope<T>>> {\n  return mergeMap((event: MessageEvent<MessageEnvelope<T>>): Observable<MessageEvent<MessageEnvelope<T>>> => {\n    const envelope: MessageEnvelope = event.data;\n    const messageId = envelope.message.headers.get(MessageHeaders.MessageId);\n    const clientId = envelope.message.headers.get(MessageHeaders.ClientId);\n    const client = Beans.get(ClientRegistry).getByClientId(clientId)!;\n\n    // Assert client registration.\n    if (!client) {\n      if (event.source !== null) {\n        const sender = new MessageTarget(event);\n        const error = `[MessagingError] Message rejected: Client not registered [origin=${event.origin}]`;\n        sendDeliveryStatusError(sender, messageId, error);\n      }\n      return EMPTY;\n    }\n\n    // Assert source origin.\n    if (event.origin !== client.application.messageOrigin) {\n      if (event.source !== null) {\n        const sender = new MessageTarget(event);\n        const error = `[MessagingError] Message rejected: Wrong origin [actual=${event.origin}, expected=${client.application.messageOrigin}, application=${client.application.symbolicName}]`;\n        sendDeliveryStatusError(sender, messageId, error);\n      }\n      return EMPTY;\n    }\n\n    // Assert source window unless the request is stale, i.e., if the origin window has been closed or a site with a different origin has been loaded.\n    // We still process stale requests to enable proper disconnection of the client, such as delivery of messages published by the client during shutdown,\n    // but mark the client as stale and queue it for later removal.\n    if (event.source === null) {\n      client.markStaleAndQueueForRemoval();\n    }\n    else if (event.source !== client.window) {\n      const sender = new MessageTarget(event);\n      const error = `[MessagingError] Message rejected: Wrong window [origin=${event.origin}]`;\n      sendDeliveryStatusError(sender, messageId, error);\n      return EMPTY;\n    }\n\n    return of(event);\n  });\n}\n\n/** @ignore */\nfunction sendDeliveryStatusSuccess(target: MessageTarget | Client, topic: string): void {\n  sendTopicMessage<MessageDeliveryStatus>(target, {\n    topic: topic,\n    body: {ok: true},\n    headers: new Map(),\n  });\n}\n\n/** @ignore */\nfunction sendDeliveryStatusError(target: MessageTarget | Client, topic: string, error: string | Error | unknown): void {\n  sendTopicMessage<MessageDeliveryStatus>(target, {\n    topic: topic,\n    body: {ok: false, details: stringifyError(error)},\n    headers: new Map(),\n  });\n}\n\n/** @ignore */\nfunction sendTopicMessage<T>(target: MessageTarget | Client | TopicSubscription, message: TopicMessage<T>): void {\n  const envelope: MessageEnvelope<TopicMessage<T>> = {\n    transport: MessagingTransport.BrokerToClient,\n    channel: MessagingChannel.Topic,\n    message: {\n      ...message,\n      params: new Map(message.params),\n      headers: new Map(message.headers)\n        .set(MessageHeaders.MessageId, message.headers.get(MessageHeaders.MessageId) ?? UUID.randomUUID())\n        .set(MessageHeaders.AppSymbolicName, message.headers.get(MessageHeaders.AppSymbolicName) ?? Beans.get<string>(APP_IDENTITY)),\n    },\n  };\n\n  if (target instanceof MessageTarget) {\n    !target.window.closed && target.window.postMessage(envelope, target.origin);\n  }\n  else if (target instanceof TopicSubscription) {\n    const subscription = target;\n    const client = subscription.client;\n    envelope.message.headers.set(client.deprecations.legacyIntentSubscriptionApi ? 'TOPIC_SUBSCRIBER_ID' : MessageHeaders.SubscriberId, target.subscriberId);\n    envelope.message.params = new TopicMatcher(subscription.topic).match(message.topic).params;\n    !client.stale && client.window.postMessage(envelope, client.application.messageOrigin);\n  }\n  else {\n    !target.stale && target.window.postMessage(envelope, target.application.messageOrigin);\n  }\n}\n\n/** @ignore */\nfunction sendIntentMessage(subscription: IntentSubscription, message: IntentMessage): void {\n  const envelope: MessageEnvelope<IntentMessage> = {\n    transport: MessagingTransport.BrokerToClient,\n    channel: MessagingChannel.Intent,\n    message: {\n      ...message,\n      headers: new Map(message.headers)\n        .set(MessageHeaders.SubscriberId, subscription.subscriberId)\n        .set(MessageHeaders.MessageId, message.headers.get(MessageHeaders.MessageId) ?? UUID.randomUUID())\n        .set(MessageHeaders.AppSymbolicName, message.headers.get(MessageHeaders.AppSymbolicName) ?? Beans.get<string>(APP_IDENTITY)),\n    },\n  };\n  const client = subscription.client;\n  !client.stale && client.window.postMessage(envelope, client.application.messageOrigin);\n}\n\n/**\n * Catches and logs errors, and resubscribes to the source observable.\n *\n * @ignore\n */\nfunction catchErrorAndRetry<T>(): MonoTypeOperatorFunction<T> {\n  return catchError((error, caught) => {\n    Beans.get(Logger).error('[UnexpectedError] An unexpected error occurred.', error);\n    return caught;\n  });\n}\n\n/**\n * Tests whether given message is a request of a request-response communication.\n * That is a message that contains the {@link MessageHeaders#ReplyTo} message header.\n */\nfunction isRequest(message: Message): boolean {\n  return message.headers.has(MessageHeaders.ReplyTo);\n}\n\n/**\n * Represents the target where to send a message.\n *\n * @ignore\n */\nclass MessageTarget {\n\n  public readonly window: Window;\n  public readonly origin: string;\n\n  constructor(event: MessageEvent) {\n    this.window = event.source as Window;\n    this.origin = event.origin;\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {MessageEnvelope, MessagingChannel, MessagingTransport} from '../../messaging.model';\nimport {UUID} from '@scion/toolkit/uuid';\nimport {MessageHeaders, TopicMessage} from '../../messaging.model';\n\n/**\n * Context lookup options header to control if values should be collected.\n *\n * @ignore\n */\nexport const CONTEXT_LOOKUP_OPTIONS = 'CONTEXT_LOOKUP_OPTIONS';\n\n/**\n * Instructs how to look up context values.\n *\n * @category Context\n */\nexport interface ContextLookupOptions {\n  /**\n   * Controls whether to collect the most specific context value or to collect all values in the context\n   * hierarchy that are associated with a context name. Defaults to `false` if not specified.\n   *\n   * If `true`, collects all values in the context hierarchy that are associated with the context name.\n   * Collected values are returned as an array in context-descending order, i.e., values of parent contexts\n   * come after values of child contexts.\n   *\n   * If `false`, the most specific context value is returned, i.e., the value of the closest context\n   * that has a value associated with that name.\n   */\n  collect?: boolean;\n}\n\n/**\n * Provides the API to lookup context related information.\n *\n * @ignore\n */\nexport namespace Contexts {\n\n  /**\n   * Returns the request-reply topic to lookup the names of associated context values in the context tree.\n   */\n  export function contextTreeNamesLookupTopic(): string {\n    return 'contexttree/names';\n  }\n\n  /**\n   * Returns the request-reply topic to get notified when some context changes at any level in the context tree.\n   */\n  export function contextTreeChangeTopic(): string {\n    return 'contexttree/change';\n  }\n\n  /**\n   * Computes the request-reply topic to lookup a context value from embedded router outlet web content.\n   */\n  export function contextValueLookupTopic(name: string): string {\n    return `context/${name}`;\n  }\n\n  /**\n   * Creates a message envelope to request the context value associated with the given name.\n   *\n   * @param name - The name of the value to lookup.\n   * @param replyTo - The 'replyTo' topic where to send the reply.\n   * @param options - Options to control context lookup.\n   * @param values - The collected values passed to the parent context during a context lookup.\n   *                 Used to collect all values associated with the context name in the context hierarchy.\n   */\n  export function newContextValueLookupRequest(name: string, replyTo: string, options?: ContextLookupOptions, values?: any[]): MessageEnvelope<TopicMessage<any[]>> {\n    return {\n      transport: MessagingTransport.MicrofrontendToOutlet,\n      channel: MessagingChannel.Topic,\n      message: {\n        topic: contextValueLookupTopic(encodeURIComponent(name)), // Encode in order to support names containing forward slashes or starting with a colon.\n        body: values || [],\n        headers: new Map()\n          .set(MessageHeaders.MessageId, UUID.randomUUID())\n          .set(MessageHeaders.ReplyTo, replyTo)\n          .set(CONTEXT_LOOKUP_OPTIONS, options),\n      },\n    };\n  }\n\n  /**\n   * Creates a message envelope to lookup the names of associated context values in the context tree.\n   *\n   * @param replyTo - The 'replyTo' topic where to send the reply.\n   * @param names - The names of the current context to be combined with the names of the parent contexts.\n   */\n  export function newContextTreeNamesLookupRequest(replyTo: string, names?: Set<string>): MessageEnvelope<TopicMessage<Set<string>>> {\n    return {\n      transport: MessagingTransport.MicrofrontendToOutlet,\n      channel: MessagingChannel.Topic,\n      message: {\n        topic: Contexts.contextTreeNamesLookupTopic(),\n        body: names || new Set<string>(),\n        headers: new Map()\n          .set(MessageHeaders.MessageId, UUID.randomUUID())\n          .set(MessageHeaders.ReplyTo, replyTo),\n      },\n    };\n  }\n\n  /**\n   * Creates a message envelope to get notified when some context changes at any level in the context tree.\n   *\n   * @param replyTo - The 'replyTo' topic where to send the reply.\n   */\n  export function newContextTreeObserveRequest(replyTo: string): MessageEnvelope<TopicMessage<void>> {\n    return {\n      transport: MessagingTransport.MicrofrontendToOutlet,\n      channel: MessagingChannel.Topic,\n      message: {\n        topic: Contexts.contextTreeChangeTopic(),\n        headers: new Map()\n          .set(MessageHeaders.MessageId, UUID.randomUUID())\n          .set(MessageHeaders.ReplyTo, replyTo),\n      },\n    };\n  }\n\n  /**\n   * Event emitted when a context value changed.\n   */\n  export interface ContextTreeChangeEvent {\n    type: 'set' | 'remove';\n    name: string;\n    value?: any;\n  }\n\n  /**\n   * Event emitted by the root context when subscribed to it.\n   */\n  export const RootContextSubscribeEvent = 'RootContextSubscribeEvent';\n  export type RootContextSubscribeEventType = 'RootContextSubscribeEvent';\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {BehaviorSubject, fromEvent, Observable, Subject} from 'rxjs';\nimport {filter, share, takeUntil} from 'rxjs/operators';\nimport {filterByChannel, filterByTopicChannel, filterByTransport, pluckMessage} from '../../operators';\nimport {MessageEnvelope, MessagingChannel, MessagingTransport} from '../../messaging.model';\nimport {TopicMatcher} from '../../topic-matcher.util';\nimport {MessageHeaders, ResponseStatusCodes, TopicMessage} from '../../messaging.model';\nimport {MessageClient, takeUntilUnsubscribe} from '../messaging/message-client';\nimport {CONTEXT_LOOKUP_OPTIONS, Contexts} from './context.model';\nimport {runSafe} from '../../safe-runner';\nimport {IS_PLATFORM_HOST} from '../../platform.model';\nimport {Beans} from '@scion/toolkit/bean-manager';\n\n/**\n * Provides a context to the {@link SciRouterOutletElement} allowing the outlet to associate values with that context.\n * For embedded outlet web content, it allows looking up context names and values.\n *\n * A context is a hierarchical key-value map which are linked together to form a tree structure. When a key is not found\n * in a context, the lookup is retried on the parent, repeating until either a value is found or the root of the tree has\n * been reached.\n *\n * @ignore\n */\nexport class RouterOutletContextProvider {\n\n  private _microfrontendRequest$: Observable<MessageEvent<MessageEnvelope<TopicMessage>>>;\n\n  private _entries$ = new BehaviorSubject<Map<string, any>>(new Map());\n  private _entryChange$ = new Subject<Contexts.ContextTreeChangeEvent>();\n  private _outletDisconnect$ = new Subject<void>();\n\n  constructor(iframe: HTMLIFrameElement) {\n    // Listen for requests from embedded web content of the outlet.\n    this._microfrontendRequest$ = fromEvent<MessageEvent>(window, 'message')\n      .pipe(\n        filter(event => event.source === iframe.contentWindow),\n        filterByTransport(MessagingTransport.MicrofrontendToOutlet),\n        filterByChannel<TopicMessage>(MessagingChannel.Topic),\n        share(),\n      );\n  }\n\n  /**\n   * Sets a value to be associated with a given name in this context.\n   *\n   * @param name - Specifies the name to store a value for.\n   * @param value - Specifies the value to be stored. It can be any object which\n   *        is serializable with the structured clone algorithm.\n   */\n  public set(name: string, value: any): void {\n    this._entries$.next(new Map(this._entries$.getValue()).set(name, value));\n    this._entryChange$.next({name, value, type: 'set'});\n  }\n\n  /**\n   * Removes the given name and any corresponding value from this context.\n   *\n   * Removal does not affect parent contexts, so it is possible that a subsequent call to {@link ContextService#observe$} with the same name\n   * will return a non-null result, due to a value being stored in a parent context.\n   *\n   * @param  name - Specifies the name to remove.\n   * @return `true` if the value in the outlet context has been removed successfully; otherwise `false`.\n   */\n  public remove(name: string): boolean {\n    const entries = new Map(this._entries$.getValue());\n    if (entries.delete(name)) {\n      this._entries$.next(entries);\n      this._entryChange$.next({name, type: 'remove'});\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns an Observable that emits the values registered in this outlet. Values inherited from parent contexts are not returned.\n   * The Observable never completes, and emits when a context value is added or removed.\n   */\n  public get entries$(): Observable<Map<string, any>> {\n    return this._entries$;\n  }\n\n  /**\n   * Method invoked when the outlet is mounted to the DOM.\n   */\n  public onOutletMount(): void {\n    this.installContextValueLookupListener();\n    this.installContextTreeNamesLookupListener();\n    this.installContextTreeObserveListener();\n  }\n\n  /**\n   * Method invoked when the outlet is removed from the DOM.\n   */\n  public onOutletUnmount(): void {\n    this._outletDisconnect$.next();\n  }\n\n  /**\n   * Installs a listener to reply to context value lookup requests from embedded content.\n   * When a key is not found in this context, the lookup is passed on to the parent context.\n   */\n  private installContextValueLookupListener(): void {\n    this._microfrontendRequest$\n      .pipe(\n        filterByTopicChannel<any[]>(Contexts.contextValueLookupTopic(':name')),\n        pluckMessage(),\n        takeUntil(this._outletDisconnect$),\n      )\n      .subscribe((lookupRequest: TopicMessage<any[]>) => runSafe(() => {\n        const encodedName = new TopicMatcher(Contexts.contextValueLookupTopic(':name')).match(lookupRequest.topic).params!.get('name')!;\n\n        // The name has to be decoded here because it was encoded in `newContextValueLookupRequest` where the topic was created.\n        const name = decodeURIComponent(encodedName);\n        const replyTo = lookupRequest.headers.get(MessageHeaders.ReplyTo);\n        const options = lookupRequest.headers.get(CONTEXT_LOOKUP_OPTIONS);\n        const entries = this._entries$.getValue();\n\n        if (options?.collect) {\n          const collectedValues = lookupRequest.body || [];\n          if (entries.has(name) && entries.get(name) !== undefined) {\n            collectedValues.push(entries.get(name));\n          }\n\n          if (Beans.get(IS_PLATFORM_HOST)) {\n            // Reply with the collected context values.\n            Beans.get(MessageClient).publish(replyTo, collectedValues, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.OK)});\n          }\n          else {\n            // Pass on the lookup request to the parent context.\n            window.parent.postMessage(Contexts.newContextValueLookupRequest(name, replyTo, options, collectedValues), '*');\n          }\n        }\n        else {\n          if (entries.has(name) && entries.get(name) !== undefined) {\n            // Reply with the found context value.\n            Beans.get(MessageClient).publish(replyTo, entries.get(name), {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.OK)});\n          }\n          else if (Beans.get(IS_PLATFORM_HOST)) {\n            // No context value found; the root of the context tree has been reached; reply with `NOT_FOUND` status code.\n            Beans.get(MessageClient).publish(replyTo, undefined, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.NOT_FOUND)});\n          }\n          else {\n            // Pass on the lookup request to the parent context.\n            window.parent.postMessage(Contexts.newContextValueLookupRequest(name, replyTo, options), '*');\n          }\n        }\n      }));\n  }\n\n  /**\n   * Installs a listener to reply to context names lookup requests from embedded content.\n   *\n   * The context names are accumulated in the lookup request and passed on to the parent context.\n   * When the root context is reached, the request is finally answered with all collected context names.\n   */\n  private installContextTreeNamesLookupListener(): void {\n    this._microfrontendRequest$\n      .pipe(\n        filterByTopicChannel<Set<string>>(Contexts.contextTreeNamesLookupTopic()),\n        pluckMessage(),\n        takeUntil(this._outletDisconnect$),\n      )\n      .subscribe((lookupRequest: TopicMessage<Set<string>>) => runSafe(() => {\n        const replyTo = lookupRequest.headers.get(MessageHeaders.ReplyTo);\n        const entries = this._entries$.getValue();\n        const collectedNames = new Set<string>([...entries.keys(), ...(lookupRequest.body || [])]);\n        if (Beans.get(IS_PLATFORM_HOST)) {\n          // Answer the request when reaching the root of the context tree.\n          Beans.get(MessageClient).publish(replyTo, collectedNames, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.OK)});\n        }\n        else {\n          // Pass on the lookup request to the parent context.\n          window.parent.postMessage(Contexts.newContextTreeNamesLookupRequest(replyTo, collectedNames), '*');\n        }\n      }));\n  }\n\n  /**\n   * Installs a listener to publish a context change event when this context changes.\n   *\n   * For every request a replier is installed which emits when this context changes. It stops replying\n   * when the requestor unsubscribes. The request is also passed on to the parent context.\n   */\n  private installContextTreeObserveListener(): void {\n    this._microfrontendRequest$\n      .pipe(\n        filterByTopicChannel<void>(Contexts.contextTreeChangeTopic()),\n        pluckMessage(),\n        takeUntil(this._outletDisconnect$),\n      )\n      .subscribe((observeRequest: TopicMessage<void>) => runSafe(() => {\n        const replyTo = observeRequest.headers.get(MessageHeaders.ReplyTo);\n\n        this._entryChange$\n          .pipe(\n            takeUntilUnsubscribe(replyTo),\n            takeUntil(this._outletDisconnect$),\n          )\n          .subscribe((event: Contexts.ContextTreeChangeEvent) => { // eslint-disable-line rxjs/no-nested-subscribe\n            Beans.get(MessageClient).publish<Contexts.ContextTreeChangeEvent>(replyTo, event);\n          });\n\n        if (Beans.get(IS_PLATFORM_HOST)) {\n          // Notify that the subscriber subscribed to the root context.\n          Beans.get(MessageClient).publish<Contexts.RootContextSubscribeEventType>(replyTo, Contexts.RootContextSubscribeEvent);\n        }\n        else {\n          // Pass on the registration request to the parent context.\n          window.parent.postMessage(Contexts.newContextTreeObserveRequest(replyTo), '*');\n        }\n      }));\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {runSafe} from '../../safe-runner';\nimport {Navigation} from './metadata';\nimport {Urls} from '../../url.util';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {WINDOW_TOP} from '../../platform.model';\n\n/**\n * Assigns a URL to the iframe of a {@link SciRouterOutletElement `<sci-router-outlet>`}.\n *\n * @category Routing\n */\nexport class RouterOutletUrlAssigner {\n\n  /**\n   * Assigns a URL to the iframe of a {@link SciRouterOutletElement `<sci-router-outlet>`}.\n   *\n   * @param iframe - Iframe for which to set the URL.\n   * @param currNavigation - Current navigation.\n   * @param prevNavigation - Previous navigation, if any.\n   */\n  public assign(iframe: HTMLIFrameElement, currNavigation: Navigation, prevNavigation?: Navigation): void {\n    // Patch the URL to force Chrome to load the content of specified URL.\n    const patchedUrl = this.patchUrl(currNavigation.url, prevNavigation && prevNavigation.url);\n\n    if (currNavigation.pushStateToSessionHistoryStack) {\n      iframe.contentWindow!.location.assign(patchedUrl);\n    }\n    else {\n      iframe.contentWindow!.location.replace(patchedUrl);\n    }\n  }\n\n  /**\n   * Patches the URL to force Chrome to load the content of the given URL into an iframe.\n   *\n   * #### Problem:\n   * Chrome browser does not load the content of a nested iframe if already loaded a document from the same origin and path in a parent iframe.\n   * The problem does not occur if the URL contains query parameters. Also, the hash fragment of the URL does not matter.\n   *\n   * This problem could not be observed in Firefox and Edge.\n   *\n   * #### Motivation:\n   * If using hash-based routing, the microfrontends of an application are served under the same origin and path, and routing is based on the URL hash fragment only.\n   * This Chrome issue would prevent a microfrontend from embedding other microfrontends of its application.\n   *\n   * #### Fix:\n   * If the URL does not contain a query parameter, an arbitrary query parameter is appended to the URL to force Chrome to load the content.\n   * The name and value of the query param do not matter. However, it is crucial always to use the same param to allow the browser to cache the request.\n   *\n   * The only exception to appending a query param is when replacing an outlet's content with content from the same app. Then, the browser already loaded\n   * the application. Otherwise, if appending a query param, the application would load anew.\n   *\n   * #### Alternative fix:\n   * An alternative (but partial) fix would be to initialize the iframe with a `null` source. This fix is partial because only working when setting the initial URL\n   * of the iframe and not when changing it. Also, it has the drawback of temporarily loading the main entry point of the outlet host.\n   *\n   * @param currUrl - Specifies the URL to be patched.\n   * @param prevUrl - Specifies the previous URL, if any.\n   *\n   * @see https://stackoverflow.com/q/36985731\n   * @internal\n   */\n  public patchUrl(currUrl: string, prevUrl?: string): string {\n    const patchedUrl = runSafe(() => {\n      const prevURL = prevUrl ? Urls.newUrl(prevUrl) : undefined;\n      const currURL = Urls.newUrl(currUrl);\n\n      // Do not apply the fix for the \"about\" and \"blob\" protocol.\n      if (currURL.protocol === 'about:' || currURL.protocol === 'blob:') {\n        return currUrl;\n      }\n\n      // Do not apply the fix for top-level iframes.\n      if (window === Beans.get(WINDOW_TOP)) {\n        return currUrl;\n      }\n\n      // Do not apply the fix if the URL already contains query params.\n      if (currURL.search) {\n        return currUrl;\n      }\n\n      // Do not apply the fix when navigating within the same application using hash-based routing.\n      if (prevURL?.origin === currURL.origin && prevURL?.pathname === currURL.pathname) {\n        return currUrl;\n      }\n\n      // Add an arbitrary but fixed query param to the URL.\n      const patchedURL = Urls.newUrl(currUrl);\n      patchedURL.searchParams.set('_', '');\n      return patchedURL.toString();\n    });\n\n    return patchedUrl ?? currUrl;\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {Logger} from '../../logger';\n\n/**\n * Describes a user interaction with the keyboard.\n *\n * @ignore\n */\nexport class Keystroke {\n\n  /**\n   * Represents this keystroke as a string with its parts separated by a dot.\n   */\n  public readonly parts: string;\n\n  /**\n   * Flags to control keystroke handling.\n   */\n  public flags?: KeystrokeFlags;\n\n  constructor(public readonly eventType: string, key: string, modifiers?: {control?: boolean; shift?: boolean; alt?: boolean; meta?: boolean}, flags?: KeystrokeFlags) {\n    const parts = [];\n    parts.push(eventType);\n    if (modifiers) {\n      modifiers.control && parts.push('control');\n      modifiers.alt && parts.push('alt');\n      modifiers.shift && parts.push('shift');\n      modifiers.meta && parts.push('meta');\n    }\n    parts.push(key.toLowerCase());\n    this.parts = parts.join('.');\n    this.flags = flags;\n  }\n\n  public withFlags(flags: KeystrokeFlags): this {\n    this.flags = flags;\n    return this;\n  }\n\n  /**\n   * Creates a {@link Keystroke} from the given keyboard event.\n   */\n  public static fromEvent(event: KeyboardEvent): Keystroke {\n    if (!event) {\n      throw Error('[KeystrokeParseError] Cannot create the keystroke from `null` or `undefined`.');\n    }\n    return new Keystroke(event.type, escapeKeyboardEventKey(event.key), {control: event.ctrlKey, shift: event.shiftKey, alt: event.altKey, meta: event.metaKey});\n  }\n\n  /**\n   * Parses the textual representation of a keystroke into a {@link Keystroke} object.\n   *\n   * keydown.control.alt.enter{preventDefault=true}\n   * |<--1->|<----2---->|<-3->|<--------4--------->|\n   *\n   * 1: Event type\n   * 2: Modifier part(s) (optional)\n   * 3. Key as defined in https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values.\n   *    Two keys are an exception to the value of the {@link KeyboardEvent#key} property: dot and space.\n   * 4. flags (optional)\n   */\n  public static fromString(value: string): Keystroke {\n    if (!value) {\n      throw Error('[KeystrokeParseError] Cannot parse the keystroke from \\'null\\' or \\'undefined\\'.');\n    }\n\n    const flags = parseFlags(value);\n    if (flags !== undefined) {\n      value = value.substring(0, value.indexOf('{'));\n    }\n\n    const parts = value.split('.');\n    if (parts.length < 2) {\n      throw Error(`[KeystrokeParseError] Cannot parse the keystroke '${value}'. Requires at least the event type and keyboard key, and optionally some modifiers. Examples: 'keydown.control.z', 'keydown.escape', 'keyup.enter', 'keydown.control.alt.enter', 'keydown.control.space'`);\n    }\n\n    const eventType = parts[0];\n    if (eventType !== 'keydown' && eventType !== 'keyup') {\n      throw Error(`[KeystrokeParseError] Cannot parse the keystroke '${value}'. Unsupported event type. Supported event types are: 'keydown' or 'keyup'. Examples: 'keydown.control.z', 'keydown.escape', 'keyup.enter', 'keydown.control.alt.enter', 'keydown.control.space'`);\n    }\n\n    const key = parts[parts.length - 1];\n    if (!key || new Set().add('alt').add('shift').add('control').add('meta').has(key.toLowerCase())) {\n      throw Error(`[KeystrokeParseError] Cannot parse the keystroke '${value}'. The keyboard key must be the last part. Examples: 'keydown.control.z', 'keydown.escape', 'keyup.enter', 'keydown.control.alt.enter', 'keydown.control.space'`);\n    }\n\n    const modifiers = new Set(parts.slice(1, -1));\n    const keystroke = new Keystroke(eventType, key, {control: modifiers.delete('control'), shift: modifiers.delete('shift'), alt: modifiers.delete('alt'), meta: modifiers.delete('meta')}, flags);\n    if (modifiers.size > 0) {\n      throw Error(`[KeystrokeParseError] Cannot parse the keystroke '${value}'. Illegal modifier found. Supported modifiers are: 'alt', 'shift', 'control' or 'meta'. Examples: 'keydown.control.z', 'keydown.escape', 'keyup.enter', 'keydown.control.alt.enter', 'keydown.control.space'`);\n    }\n\n    return keystroke;\n  }\n}\n\n/** @ignore */\nfunction escapeKeyboardEventKey(key: string): string {\n  switch (key) {\n    case '.':\n      return 'dot';\n    case ' ':\n      return 'space';\n    default:\n      return key;\n  }\n}\n\n/** @ignore */\nfunction parseFlags(keystroke: string): KeystrokeFlags | undefined {\n  const flagsStr = keystroke.match(/{(?<flagsDictionary>.*)}/)?.groups!['flagsDictionary'] ?? null;\n  if (flagsStr === null) {\n    return undefined;\n  }\n  if (flagsStr === '') {\n    return {};\n  }\n\n  return flagsStr\n    .split(';')\n    .map(flag => flag.split('='))\n    .reduce((flags, [flagName, flagValue]) => {\n      switch (flagName) {\n        case 'preventDefault':\n          return {...flags, preventDefault: flagValue === 'true'};\n        default: {\n          Beans.get(Logger).warn(`[KeystrokeParseError] Ignore unkown flag \\'${keystroke}\\'. Supported flags are: \\'preventDefault\\'.`);\n          return flags;\n        }\n      }\n    }, {} as KeystrokeFlags);\n}\n\n/**\n * Flags to control keystroke handling.\n *\n * @ignore\n */\nexport interface KeystrokeFlags {\n  /**\n   * If set to `true`, the default action of the keystroke is prevented.\n   */\n  preventDefault?: boolean;\n}\n","import {Dictionary} from '@scion/toolkit/util';\n\n/**\n * Options to control outlet navigation.\n *\n * @category Routing\n */\nexport interface NavigationOptions {\n  /**\n   * Specifies the routing target. If not specifying an outlet and if navigating in the context of an outlet, that outlet will be used as the\n   * navigation target, or the {@link PRIMARY_OUTLET primary} outlet otherwise.\n   */\n  outlet?: string;\n  /**\n   * Specifies the base URL to resolve a relative url. If not specified, the current window location is used to resolve a relative path.\n   *\n   * Note that this property has no effect if navigating via intent.\n   */\n  relativeTo?: string;\n  /**\n   * Specifies the parameters that, if navigating via URL, are used to substitute named URL parameters or that are passed along with the intent\n   * if navigating via intent.\n   */\n  params?: Map<string, any> | Dictionary;\n  /**\n   * Instructs the router to push a state to the browser's session history stack, allowing the user to use the back button to navigate back in the outlet.\n   * By default, this behavior is disabled.\n   */\n  pushStateToSessionHistoryStack?: boolean;\n}\n\n/**\n * Routing message header to control if to push a state to the browser's session history stack.\n *\n * @ignore\n */\nexport const PUSH_STATE_TO_SESSION_HISTORY_STACK_MESSAGE_HEADER = 'PUSH_STATE_TO_SESSION_HISTORY_STACK';\n\n/**\n * Represents a navigation.\n */\nexport interface Navigation {\n  /**\n   * The URL where to navigate to.\n   */\n  url: string;\n  /**\n   * If `true`, adds a state to the browser's session history stack.\n   */\n  pushStateToSessionHistoryStack: boolean;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {BehaviorSubject, Observable, Subject} from 'rxjs';\nimport {RouterOutletContextProvider} from '../context/router-outlet-context-provider';\nimport {runSafe} from '../../safe-runner';\nimport {distinctUntilChanged, map, pairwise, skipWhile, startWith, switchMap, takeUntil, tap} from 'rxjs/operators';\nimport {RouterOutletUrlAssigner} from './router-outlet-url-assigner';\nimport {MessageClient} from '../messaging/message-client';\nimport {Defined} from '@scion/toolkit/util';\nimport {UUID} from '@scion/toolkit/uuid';\nimport {mapToBody, TopicMessage} from '../../messaging.model';\nimport {Keystroke} from '../keyboard-event/keystroke';\nimport {PreferredSize} from '../preferred-size/preferred-size';\nimport {Navigation, PUSH_STATE_TO_SESSION_HISTORY_STACK_MESSAGE_HEADER} from './metadata';\nimport {Beans} from '@scion/toolkit/bean-manager';\n\n/** @ignore */\nconst ELEMENT_NAME = 'sci-router-outlet';\n/** @ignore */\nconst ATTR_NAME = 'name';\n/** @ignore */\nconst ATTR_SCROLLABLE = 'scrollable';\n/** @ignore */\nconst ATTR_KEYSTROKES = 'keystrokes';\n/** @ignore */\nconst HTML_TEMPLATE = `\n  <style>\n    :host {\n      display: block;\n      overflow: hidden;\n    }\n\n    iframe {\n      width: 100%;\n      height: 100%;\n      border: none;\n      margin: 0;\n    }\n  </style>\n  <iframe src=\"about:blank\" scrolling=\"yes\" marginheight=\"0\" marginwidth=\"0\"></iframe>\n`;\n\n/**\n * Web component that allows embedding web content using the {@link OutletRouter}. The content is displayed inside\n * an iframe to achieve the highest possible level of isolation between the microfrontends via a separate browsing context.\n *\n * To embed a microfrontend, place this custom HMTL element `<sci-router-outlet></sci-router-outlet>` in an HTML\n * template, give it a name via its `name` attribute and navigate via {@link OutletRouter} to instruct the outlet to\n * load the microfrontend.\n *\n * 1. Place the web component in an HTML template:\n * ```html\n * <sci-router-outlet name=\"detail\"></sci-router-outlet>\n * ```\n *\n * 2. Control the outlet's content:\n * ```ts\n * Beans.get(OutletRouter).navigate('https://micro-frontends.org', {outlet: 'detail'});\n * ```\n *\n * Outlets can be nested, allowing a microfrontend to embed another microfrontend. There is no limit to the number of\n * nested outlets. However, be aware that nested content is loaded cascaded, that is, only loaded once its parent content\n * finished loading.\n *\n * When adding the outlet to the DOM, the outlet displays the last URL routed for it, if any. When repeating routing for\n * an outlet, its content is replaced.\n *\n * ***\n *\n * #### Outlet Context\n * The router outlet allows associating contextual data, which then is available to embedded content at any nesting level.\n * Data must be serializable with the structured clone algorithm. Embedded content can look up contextual data using the\n * {@link ContextService}. Typically, contextual data is  used to provide microfrontends with information about their embedding\n * environment. Looking up contextual data requires the embedded microfrontend to be a registered micro application.\n *\n * Each outlet spans a new context. A context is like a `Map` with key-value entries. Contexts form a hierarchical tree structure.\n * When looking up a value and if the value is not found in the current context, the lookup is retried on the parent context,\n * repeating until either a value is found, or the root of the context tree has been reached.\n *\n * You can set contextual data as following:\n * ```ts\n *  const outlet: SciRouterOutletElement = document.querySelector('sci-router-outlet');\n *  outlet.setContextValue('key', 'value');\n * ```\n *\n * Embedded content can look up contextual data as following:\n * ```ts\n * Beans.get(ContextService).observe$('key').subscribe(value => {\n *   ...\n * });\n * ```\n *\n * #### Outlet size\n * The router outlet can adapt its size to the preferred size of its embedded content. The preferred size is set by the microfrontend embedded\n * in the router outlet, which, therefore, requires the embedded microfrontend to be connected to the platform.\n *\n * Embedded content can report its preferred size using the {@link PreferredSizeService}, causing the outlet to adapt its size.\n *\n * #### Keystroke Bubbling\n * The router outlet allows the registration of keystrokes, instructing embedded content at any nesting level to propagate corresponding keyboard events\n * to this outlet. The outlet dispatches keyboard events for registered keystrokes as synthetic keyboard events via its event dispatcher. They bubble up\n * the DOM tree like regular events. Propagated events are of the original type, meaning that when the user presses a key on the keyboard, a `keydown`\n * keyboard event is dispatched, or a `keyup` event when releasing a key, respectively. Keystroke bubbling requires the embedded microfrontend to be a\n * registered micro application.\n *\n * A keystroke is a `string` that has several parts, each separated with a dot. The first part specifies the event type (`keydown` or `keyup`), followed\n * by optional modifier part(s) (`alt`, `shift`, `control`, `meta`, or a combination thereof) and with the keyboard key as the last part. The key is a\n * case-insensitive value of the `KeyboardEvent.key` property. Two keys are an exception to the value of the `KeyboardEvent.key` property: `dot` and `space`.\n * For a complete list of valid key values, see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values.\n *\n * You can register keystrokes via the `keystrokes` attribute in the HTML template, or via the `keystrokes` property on the DOM\n * element. If setting keystrokes via the HTML template, multiple keystrokes are separated by a comma.\n *\n * If you want to prevent the default action of a keystroke, add the `preventDefault` flag. If not specifying the flag, the default action won't be prevented.\n *\n * HTML template:\n * ```html\n * <sci-router-outlet keystrokes=\"keydown.control.alt.enter{preventDefault=true},keydown.escape,keydown.control.space\"></sci-router-outlet>\n * ```\n *\n * Alternatively, you can register keystrokes on the DOM element as shown below.\n *\n * TypeScript:\n * ```ts\n *  const outlet: SciRouterOutletElement = document.querySelector('sci-router-outlet');\n *  outlet.keystrokes = [\n *      'keydown.control.alt.enter{preventDefault=true}',\n *      'keydown.escape',\n *      'keydown.control.space'\n *  ];\n * ```\n *\n * #### Scrollable Content\n * By default, page scrolling is enabled for the embedded content, displaying a scrollbar when it overflows. If disabled, overflowing content is clipped,\n * unless the embedded content uses a viewport, or reports its preferred size to the outlet.\n *\n * The below code snippet illustrates how to disable page scrolling for the embedded content.\n * ```html\n * <sci-router-outlet scrollable=\"false\"></sci-router-outlet>\n * ```\n *\n * #### Router Outlet Events\n *\n * The router outlet emits the following events as custom DOM events. You can attach an event listener declaratively in the HTML template using the `onevent`\n * handler syntax, or programmatically using the `addEventListener` method.\n *\n * - `activate`\n *   The `activate` custom DOM event is fired when a microfrontend is mounted. It contains the URL of the mounted microfrontend in its `details` property as `string`\n *   value. The microfrontend may not be fully loaded yet.\n * - `deactivate`\n *   The `deactivate` custom DOM event is fired when a microfrontend is about to be unmounted. It contains the URL of the unmounted microfrontend in its `details`\n *   property as `string` value.\n * - `focuswithin`\n *   The `focuswithin` custom DOM event is fired when the microfrontend loaded into the outlet, or any of its child microfrontends, has gained or lost focus.\n *   It contains the current focus-within state in its `details` property as a `boolean` value: `true` if focus was gained, or `false` if focus was lost.\n *   The event does not bubble up through the DOM. After gaining focus, the event is not triggered again until embedded content loses focus completely, i.e.,\n *   when focus does not remain in the embedded content at any nesting level. This event behaves like the `:focus-within` CSS pseudo-class but operates across iframe\n *   boundaries. For example, it can be useful when implementing overlays that close upon focus loss.\n *\n *   Note that SCION can only monitor microfrontends of registered micro apps that are connected to the platform.\n *\n * Usage:\n *\n * ```html\n * <sci-router-outlet onfocuswithin=\"onFocusWithin()\"></sci-router-outlet>\n * ```\n *\n * For an Angular application, it would look as follows:\n * ```html\n * <sci-router-outlet (focuswithin)=\"onFocusWithin($event)\"></sci-router-outlet>\n * ```\n *\n * #### Web component\n * The outlet is registered as a custom element in the browser's custom element registry as defined by the Web Components standard.\n * See https://developer.mozilla.org/en-US/docs/Web/Web_Components for more information.\n *\n * #### Miscellaneous\n * If no content is routed for display in the router outlet, the CSS class `sci-empty` is added to the outlet. An outlet will not display content if\n * either there has not yet been any navigation for the outlet or the outlet content has been cleared.\n *\n * @see {@link OutletRouter}\n * @see {@link PreferredSizeService}\n * @see {@link ContextService}\n *\n * @category Routing\n */\nexport class SciRouterOutletElement extends HTMLElement {\n\n  private _shadowRoot: ShadowRoot;\n  private _disconnect$ = new Subject<void>();\n\n  private _uid = UUID.randomUUID();\n  private _iframe: HTMLIFrameElement;\n  private _outletName$: BehaviorSubject<string>;\n  private _contextProvider: RouterOutletContextProvider;\n  private _empty$ = new BehaviorSubject<boolean>(true);\n\n  /**\n   * Emits whether or not content is routed for display in this router outlet.\n   * Upon subscription, the Observable emits the current empty state, and then continuously emits when it changes. It never completes.\n   *\n   * An outlet does not display content if no navigation has taken place yet, or if the outlet content has been cleared.\n   */\n  public readonly empty$: Observable<boolean>;\n\n  constructor() {\n    super();\n    this._outletName$ = new BehaviorSubject<string>(PRIMARY_OUTLET);\n    this._shadowRoot = this.attachShadow({mode: 'open'});\n    this._shadowRoot.innerHTML = HTML_TEMPLATE.trim();\n    this._iframe = this._shadowRoot.querySelector('iframe')!;\n    this._contextProvider = new RouterOutletContextProvider(this._iframe);\n    this.empty$ = this._empty$.pipe(distinctUntilChanged());\n  }\n\n  /**\n   * Sets the name of this outlet.\n   *\n   * By giving the outlet a name, you can reference the outlet when navigating. The name is optional;\n   * if not set, it defaults to {@link PRIMARY_OUTLET primary}\n   */\n  public set name(name: string | undefined) {\n    if (name) {\n      this.setAttribute(ATTR_NAME, name);\n    }\n    else {\n      this.removeAttribute(ATTR_NAME);\n    }\n  }\n\n  /**\n   * Returns the name of this outlet.\n   */\n  public get name(): string | undefined {\n    return this.getAttribute(ATTR_NAME) ?? undefined;\n  }\n\n  /**\n   * Specifies whether to enable or disable native page scrolling in the embedded document.\n   *\n   * By default, page scrolling is enabled for the embedded content, displaying a scrollbar when it overflows.\n   * If disabled, overflowing content is clipped, unless the embedded content uses a viewport, or reports\n   * its preferred size to the outlet.\n   */\n  public set scrollable(scrollable: boolean) {\n    if (scrollable) {\n      this.setAttribute(ATTR_SCROLLABLE, 'true');\n    }\n    else {\n      this.removeAttribute(ATTR_SCROLLABLE);\n    }\n  }\n\n  /**\n   * Returns whether the embedded document is natively page scrollable.\n   */\n  public get scrollable(): boolean {\n    return this.getAttribute(ATTR_SCROLLABLE) === 'true';\n  }\n\n  /**\n   * Instructs embedded content at any nesting level to propagate keyboard events to this outlet. The outlet dispatches keyboard events for registered\n   * keystrokes as synthetic keyboard events via its event dispatcher. They bubble up the DOM tree like regular events. Propagated events are of the\n   * original type, meaning that when the user presses a key on the keyboard, a `keydown` keyboard event is dispatched, or a `keyup` event when releasing\n   * a key, respectively.\n   *\n   * @param keystrokes - A keystroke is specified as a string that has several parts, each separated with a dot. The first part specifies the event type\n   *                   (`keydown` or `keyup`), followed by optional modifier part(s) (`alt`, `shift`, `control`, `meta`, or a combination thereof) and\n   *                   with the keyboard key as the last part. The key is a case-insensitive value of the `KeyboardEvent#key` property. For a complete\n   *                   list of valid key values, see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values. Two keys are an\n   *                   exception to the value of the `KeyboardEvent#key` property: `dot` and `space`.\n   *                   <br>\n   *                   To prevent the default action of a keystroke, the `preventDefault` flag can be added.\n   *                   <br>\n   *                   Examples: `keydown.control.z{preventDefault=true}`, `keydown.escape`, `keyup.enter`, `keydown.control.alt.enter`, `keydown.control.space`.\n   */\n  public set keystrokes(keystrokes: string[]) {\n    if (keystrokes && keystrokes.length) {\n      this.setAttribute(ATTR_KEYSTROKES, KeystrokesAttributeUtil.join(keystrokes));\n    }\n    else {\n      this.removeAttribute(ATTR_KEYSTROKES);\n    }\n  }\n\n  /**\n   * Returns the keystrokes which to bubble across the iframe boundaries.\n   */\n  public get keystrokes(): string[] {\n    return KeystrokesAttributeUtil.split(this.getAttribute(ATTR_KEYSTROKES));\n  }\n\n  /**\n   * Makes contextual data available to embedded content. Embedded content can lookup contextual data using the {@link ContextService}.\n   * Contextual data must be serializable with the structured clone algorithm.\n   */\n  public setContextValue<T = any>(name: string, value: T): void {\n    this._contextProvider.set(name, value);\n  }\n\n  /**\n   * Removes data registered under the given key from the context.\n   *\n   * Removal does not affect parent contexts, so it is possible that a subsequent call to {@link ContextService.observe$} with the same name\n   * will return a non-null result, due to a value being stored in a parent context.\n   *\n   * @return `true` if removed the value from the outlet context; otherwise `false`.\n   */\n  public removeContextValue(name: string): boolean {\n    return this._contextProvider.remove(name);\n  }\n\n  /**\n   * Returns an Observable that emits the context of this outlet. Context values inherited from parent contexts are not returned.\n   * The Observable never completes, and emits when a context value is added to or removed from the outlet context.\n   */\n  public get contextValues$(): Observable<Map<string, any>> {\n    return this._contextProvider.entries$;\n  }\n\n  /**\n   * Resets the preferred size which may have been set by the embedded content.\n   */\n  public resetPreferredSize(): void {\n    Beans.get(MessageClient).publish(RouterOutlets.preferredSizeTopic(this._uid), null);\n  }\n\n  /**\n   * Returns the preferred size, if any, or `undefined` otherwise.\n   */\n  public get preferredSize(): PreferredSize | undefined {\n    const preferredSize: PreferredSize = {\n      minWidth: this.style.minWidth || undefined,\n      width: this.style.width || undefined,\n      maxWidth: this.style.maxWidth || undefined,\n      minHeight: this.style.minHeight || undefined,\n      height: this.style.height || undefined,\n      maxHeight: this.style.maxHeight || undefined,\n    };\n    if (Object.values(preferredSize).some(Boolean)) {\n      return preferredSize;\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns the reference to the iframe of this outlet.\n   */\n  public get iframe(): HTMLIFrameElement {\n    return this._iframe;\n  }\n\n  private installOutletContext(): void {\n    this._outletName$\n      .pipe(takeUntil(this._disconnect$))\n      .subscribe((name: string) => {\n        const outletContext: OutletContext = {name: name, uid: this._uid};\n        this.iframe.name = name;\n        this.setContextValue(OUTLET_CONTEXT, outletContext);\n      });\n  }\n\n  private installOutletUrlListener(): void {\n    this._outletName$\n      .pipe(\n        switchMap(outlet => outletNavigate$(outlet).pipe(startWith(null! as Navigation))), // start with a `null` navigation in case no navigation took place yet\n        tap(navigation => this._empty$.next(!navigation || navigation.url === 'about:blank')),\n        pairwise(),\n        takeUntil(this._disconnect$),\n      )\n      .subscribe(([prevNavigation, currNavigation]: [Navigation, Navigation]) => runSafe(() => {\n        // Emit a page deactivate event, unless not having a previous navigation\n        prevNavigation && this.dispatchEvent(new CustomEvent('deactivate', {detail: prevNavigation.url}));\n        // Change the outlet URL\n        Beans.get(RouterOutletUrlAssigner).assign(this._iframe, currNavigation || {url: 'about:blank', pushStateToSessionHistoryStack: false}, prevNavigation);\n        // Emit a page activate event, unless not having a current navigation\n        currNavigation && this.dispatchEvent(new CustomEvent('activate', {detail: currNavigation.url}));\n      }));\n  }\n\n  private installPreferredSizeListener(): void {\n    Beans.get(MessageClient).observe$<PreferredSize>(RouterOutlets.preferredSizeTopic(this._uid))\n      .pipe(\n        mapToBody(),\n        takeUntil(this._disconnect$),\n      )\n      .subscribe((preferredSize: PreferredSize | undefined) => {\n        setStyle(this, {\n          'min-width': preferredSize?.minWidth ?? null,\n          'width': preferredSize?.width ?? null,\n          'max-width': preferredSize?.maxWidth ?? null,\n          'min-height': preferredSize?.minHeight ?? null,\n          'height': preferredSize?.height ?? null,\n          'max-height': preferredSize?.maxHeight ?? null,\n        });\n      });\n  }\n\n  /**\n   * Dispatches synthetic keyboard events that bubble up the DOM like regular events.\n   * Note that synthetic events have the `isTrusted` flag set to `false`, preventing them of triggering default actions.\n   *\n   * Therefore, if default actions should be prevented, it has to be done where the original event is listened to.\n   * @see KeyboardEventDispatcher\n   *\n   * For more information about trusted events\n   * @see https://www.w3.org/TR/DOM-Level-3-Events/#trusted-events\n   * @see https://www.chromestatus.com/features#istrusted\n   *\n   * @internal\n   */\n  private installKeyboardEventDispatcher(): void {\n    Beans.get(MessageClient).observe$<KeyboardEventInit>(RouterOutlets.keyboardEventTopic(this._uid, ':eventType'))\n      .pipe(takeUntil(this._disconnect$))\n      .subscribe((event: TopicMessage<KeyboardEventInit>) => {\n        const type = event.params!.get('eventType')!;\n        this.dispatchEvent(new KeyboardEvent(type, event.body));\n      });\n  }\n\n  private installFocusWithinEventDispatcher(): void {\n    Beans.get(MessageClient).observe$<boolean>(RouterOutlets.focusWithinOutletTopic(this._uid))\n      .pipe(\n        mapToBody(),\n        skipWhile(focusWithin => focusWithin === false), // wait until first receiving the focus, otherwise, it would emit immediately.\n        takeUntil(this._disconnect$),\n      )\n      .subscribe((focusWithin: boolean) => {\n        this.dispatchEvent(new CustomEvent('focuswithin', {\n          detail: focusWithin,\n          bubbles: false,\n          cancelable: false,\n        }));\n      });\n  }\n\n  private installHostElementDecorator(): void {\n    this._empty$\n      .pipe(takeUntil(this._disconnect$))\n      .subscribe((empty: boolean) => {\n        if (empty) {\n          this._shadowRoot.host.classList.add('sci-empty');\n        }\n        else {\n          this._shadowRoot.host.classList.remove('sci-empty');\n        }\n      });\n  }\n\n  /**\n   * Lifecycle callback of the 'Custom element' Web Component standard.\n   *\n   * Invoked each time the custom element is appended into a document-connected element.\n   * This will happen each time the node is moved, and may happen before the element's contents have been fully parsed.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n   * @internal\n   */\n  public connectedCallback(): void {\n    this.installOutletUrlListener();\n    this.installOutletContext();\n    this.installPreferredSizeListener();\n    this.installFocusWithinEventDispatcher();\n    this.installKeyboardEventDispatcher();\n    this.installHostElementDecorator();\n    this._contextProvider.onOutletMount();\n  }\n\n  /**\n   * Lifecycle callback of the 'Custom element' Web Component standard.\n   *\n   * Invoked each time the custom element is disconnected from the document's DOM.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n   * @internal\n   */\n  public disconnectedCallback(): void {\n    this._disconnect$.next();\n    this._contextProvider.onOutletUnmount();\n  }\n\n  /**\n   * Lifecycle callback of the 'Custom element' Web Component standard.\n   *\n   * Specifies the attributes which to observe in {@link attributeChangedCallback} method.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n   * @internal\n   */\n  public static observedAttributes = [ATTR_NAME, ATTR_SCROLLABLE, ATTR_KEYSTROKES]; // eslint-disable-line @typescript-eslint/member-ordering\n\n  /**\n   * Lifecycle callback of the 'Custom element' Web Component standard.\n   *\n   * Invoked each time one of the custom element's attributes is added, removed, or changed.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n   * @internal\n   */\n  public attributeChangedCallback(name: string, oldValue: string, newValue: string): void {\n    switch (name) {\n      case ATTR_NAME: {\n        this._outletName$.next(newValue || PRIMARY_OUTLET);\n        break;\n      }\n      case ATTR_SCROLLABLE: {\n        this._iframe.setAttribute('scrolling', coerceBooleanProperty(newValue) ? 'yes' : 'no');\n        break;\n      }\n      case ATTR_KEYSTROKES: {\n        KeystrokesAttributeUtil.split(oldValue).forEach(keystroke => this.removeContextValue(KEYSTROKE_CONTEXT_NAME_PREFIX + Keystroke.fromString(keystroke).parts));\n        KeystrokesAttributeUtil.split(newValue).forEach(keystrokeStr => {\n          const keystroke = Keystroke.fromString(keystrokeStr);\n          this.setContextValue(KEYSTROKE_CONTEXT_NAME_PREFIX + keystroke.parts, keystroke.flags);\n        });\n        break;\n      }\n    }\n  }\n\n  /**\n   * Defines this outlet as custom element in the browser custom element registry; has no effect if the element was already defined.\n   *\n   * @return A Promise that resolves once this custom element is defined.\n   * @internal\n   */\n  public static define(): Promise<void> {\n    if (customElements.get(ELEMENT_NAME)) {\n      return Promise.resolve();\n    }\n    else {\n      customElements.define(ELEMENT_NAME, SciRouterOutletElement);\n      return customElements.whenDefined(ELEMENT_NAME).then(() => Promise.resolve());\n    }\n  }\n}\n\n/**\n * Information about the outlet which embeds a microfrontend.\n *\n * This object can be obtained from the {@link ContextService} using the name {@link OUTLET_CONTEXT}.\n *\n * ```ts\n * Beans.get(ContextService).observe$(OUTLET_CONTEXT).subscribe((outletContext: OutletContext) => {\n *   ...\n * });\n * ```\n *\n * @see {@link OUTLET_CONTEXT}\n * @see {@link ContextService}\n * @category Routing\n */\nexport interface OutletContext {\n  name: string;\n  uid: string;\n}\n\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n *\n * @ignore\n */\nfunction coerceBooleanProperty(value: any): boolean {\n  return value !== null && value !== undefined && `${value}` !== 'false';\n}\n\n/**\n * Key for obtaining the current outlet context using {@link ContextService}.\n *\n * @see {@link OutletContext}\n * @see {@link ContextService}\n */\nexport const OUTLET_CONTEXT = 'OUTLET';\n\n/**\n * Default name for an outlet if no explicit name is specified.\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * Defines constants for {@link SciRouterOutletElement} and {@link OutletRouter}.\n *\n * @category Routing\n */\nexport namespace RouterOutlets {\n\n  /**\n   * Computes the topic via which the URL for an outlet is exchanged as retained message.\n   *\n   * @internal\n   */\n  export function urlTopic(outletName: string): string {\n    return `sci-router-outlets/${outletName}/url`;\n  }\n\n  /**\n   * Computes the topic where to post keyboard events to be dispatched.\n   *\n   * @internal\n   */\n  export function keyboardEventTopic(outletUid: string, eventType: string): string {\n    return `sci-router-outlets/${outletUid}/keyboard-events/${eventType}`;\n  }\n\n  /**\n   * Computes the topic to which the preferred outlet size can be published to.\n   *\n   * @internal\n   */\n  export function preferredSizeTopic(outletUid: string): string {\n    return `sci-router-outlets/${outletUid}/preferred-size`;\n  }\n\n  /**\n   * Computes the topic to which the focus-within event can be published to.\n   *\n   * @internal\n   */\n  export function focusWithinOutletTopic(outletUid: string): string {\n    return `sci-router-outlets/${outletUid}/focus-within`;\n  }\n}\n\n/**\n * @ignore\n */\nnamespace KeystrokesAttributeUtil {\n\n  const delimiter = ',';\n\n  export function split(attributeValue: string | null): string[] {\n    return attributeValue ? attributeValue.split(delimiter) : [];\n  }\n\n  export function join(keystrokes: string[]): string {\n    return keystrokes.join(delimiter);\n  }\n}\n\n/**\n * Keystroke bindings are prefixed with `keystroke:` when registered in the outlet context.\n * @internal\n */\nexport const KEYSTROKE_CONTEXT_NAME_PREFIX = 'keystroke:';\n\n/**\n * Emits when a navigation for the given outlet occurs.\n * @ignore\n */\nfunction outletNavigate$(outlet: string): Observable<Navigation> {\n  const outletNavigationTopic = RouterOutlets.urlTopic(outlet);\n  return Beans.get(MessageClient).observe$<string>(outletNavigationTopic)\n    .pipe(map((navigateMessage: TopicMessage<string>): Navigation => {\n      return {\n        url: navigateMessage.body || 'about:blank',\n        pushStateToSessionHistoryStack: Defined.orElse(navigateMessage.headers.get(PUSH_STATE_TO_SESSION_HISTORY_STACK_MESSAGE_HEADER), false),\n      };\n    }));\n}\n\n/**\n * Applies the given style(s) to the given element.\n *\n * Specify styles to be modified by passing a dictionary containing CSS property names (hyphen case).\n * To remove a style, set its value to `null`.\n *\n * @ignore\n */\nfunction setStyle(element: HTMLElement, style: {[style: string]: any | null}): void {\n  Object.keys(style).forEach(key => element.style.setProperty(key, style[key]));\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n *\n * On every click (starting from the second), emit the relative distance to the previous click\n *\n * ```ts\n * import { fromEvent, pairwise, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(([first, second]) => {\n *     const x0 = first.clientX;\n *     const y0 = first.clientY;\n *     const x1 = second.clientX;\n *     const y1 = second.clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   })\n * );\n *\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return A function that returns an Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return operate((source, subscriber) => {\n    let prev: T;\n    let hasPrev = false;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const p = prev;\n        prev = value;\n        hasPrev && subscriber.next([p, value]);\n        hasPrev = true;\n      })\n    );\n  });\n}\n","import { Falsy, MonoTypeOperatorFunction, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function skipWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, Extract<T, Falsy> extends never ? never : T>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => true): OperatorFunction<T, never>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * Skips all the notifications with a truthy predicate. It will not skip the notifications when the predicate is falsy.\n * It can also be skipped using index. Once the predicate is true, it will not be called again.\n *\n * ## Example\n *\n * Skip some super heroes\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from(['Green Arrow', 'SuperMan', 'Flash', 'SuperGirl', 'Black Canary'])\n * // Skip the heroes until SuperGirl\n * const example = source.pipe(skipWhile(hero => hero !== 'SuperGirl'));\n * // output: SuperGirl, Black Canary\n * example.subscribe(femaleHero => console.log(femaleHero));\n * ```\n *\n * Skip values from the array until index 5\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from([1, 2, 3, 4, 5, 6, 7, 9, 10]);\n * const example = source.pipe(skipWhile((_, i) => i !== 5));\n * // output: 6, 7, 9, 10\n * example.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return A function that returns an Observable that begins emitting items\n * emitted by the source Observable when the specified predicate becomes false.\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => (taking || (taking = !predicate(value, index++))) && subscriber.next(value))\n    );\n  });\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {concat, firstValueFrom, NEVER, Observable, Observer, of, Subject, switchMap, TeardownLogic} from 'rxjs';\nimport {filter, first, map, startWith, take, takeUntil} from 'rxjs/operators';\nimport {UUID} from '@scion/toolkit/uuid';\nimport {MessageClient} from '../messaging/message-client';\nimport {mapToBody, MessageHeaders, ResponseStatusCodes} from '../../messaging.model';\nimport {ContextLookupOptions, Contexts} from './context.model';\nimport {IS_PLATFORM_HOST} from '../../platform.model';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\n\n/**\n * Allows looking up contextual data set on a {@link SciRouterOutletElement `<sci-router-outlet>`} at any parent level.\n *\n * The platform allows associating contextual data with an outlet, which then is available in embedded content using {@link ContextService}.\n * Contextual data must be serializable with the structured clone algorithm.\n *\n * Each outlet spans a new context. A context is similar to a `Map`, but is linked to its parent outlet context, if any, thus forming a hierarchical tree structure.\n * When looking up a value and if the value is not found in the outlet context, the lookup is retried on the parent context, repeating until either a value\n * is found or the root of the context tree has been reached.\n *\n * The platform sets the following context values by default:\n *\n * | Key | Value type | Description |\n * |-----|------------|-------------|\n * | {@link OUTLET_CONTEXT OUTLET} | {@link OutletContext} | Information about the outlet which embeds the microfrontend. |\n * | {@link ACTIVATION_CONTEXT ACTIVATION_CONTEXT} | {@link ActivationContext} | Information about the activation context if loaded by an activator. See {@link ActivatorCapability} for more information about activators. |\n *\n *\n * @category Context\n */\nexport class ContextService implements PreDestroy {\n\n  private _destroy$ = new Subject<void>();\n  private _contextTreeChange$ = new Subject<Contexts.ContextTreeChangeEvent>();\n  private _whenContextTreeChangeListenerInstalled: Promise<void>;\n\n  constructor() {\n    this._whenContextTreeChangeListenerInstalled = this.installContextTreeChangeListener(changeEvent => this._contextTreeChange$.next(changeEvent));\n  }\n\n  /**\n   * Observes the context value associated with the given name.\n   *\n   * The Observable emits the most specific value, i.e., the value of the closest context that has a value associated with that name.\n   * To collect all values in the context hierarchy associated with that name, set {@link ContextLookupOptions#collect} to `true`.\n   *\n   * If not finding a value associated with the given name in the current context, the lookup is retried on the parent context, repeating\n   * until either a value is found or the root of the context tree has been reached. If not finding a value in any context, the Observable\n   * emits `null`.\n   *\n   * @param  name - The name of the context value to observe.\n   * @param  options - Instructs how to look up the context value.\n   * @return An Observable that emits the value associated with the given name, or `null` if not finding a value.\n   *         Upon subscription, the Observable emits the currently associated value, and then continuously when it changes, at any level\n   *         in the context tree. It never completes.\n   */\n  public observe$<T>(name: string, options?: ContextLookupOptions & {collect: false}): Observable<T | null>;\n  /**\n   * Observes the context values associated with the given name.\n   *\n   * The Observable emits all associated values in the context tree as array in context-descending order,\n   * i.e., more specific context values precede others, in other words, values of child contexts precede values of parent contexts.\n   * If not finding a value in any context, the Observable emits an empty array.\n   *\n   * To only obtain the most specific value, i.e., the value of the closest context that has a value associated with that name,\n   * set {@link ContextLookupOptions#collect} to `false`.\n   *\n   * @param  name - The name of the context values to observe.\n   * @param  options - Instructs how to look up context values.\n   * @return An Observable that emits the values associated with the given name, or an empty array if not finding a value.\n   *         Upon subscription, the Observable emits currently associated values, and then continuously when they change.\n   *         It never completes. Collected values are emitted as array in context-descending order, i.e., more specific\n   *         context values precede others, in other words, values of child contexts precede values of parent contexts.\n   */\n  public observe$<T>(name: string, options: ContextLookupOptions & {collect: true}): Observable<T[]>;\n\n  public observe$<T>(name: string, options?: ContextLookupOptions): Observable<T | T[] | null>;\n  public observe$<T>(name: string, options?: ContextLookupOptions): Observable<T | T[] | null> {\n    if (Beans.get(IS_PLATFORM_HOST)) {\n      return concat(of(options?.collect ? [] : null), NEVER);\n    }\n\n    return this._contextTreeChange$\n      .pipe(\n        filter(event => event.name === name),\n        startWith(undefined as void),\n        switchMap(() => this.lookupContextValue$<T>(name, options)),\n      );\n  }\n\n  /**\n   * Looks up the context value associated with the given name.\n   *\n   * The Promise resolves to the most specific value, i.e., the value of the closest context that has a value associated with that name.\n   * To collect all values in the context hierarchy associated with that name, set {@link ContextLookupOptions#collect} to `true`.\n   *\n   * If not finding a value associated with the given name in the current context, the lookup is retried on the parent context, repeating\n   * until either a value is found or the root of the context tree has been reached. If not finding a value in any context, the returned\n   * Promise resolves to `null`.\n   *\n   * @param  name - The name of the context value to look up.\n   * @param  options - Instructs how to look up the context value.\n   * @return A Promise that resolves to the value associated with the given name, or `null` if not finding a value.\n   */\n  public lookup<T>(name: string, options?: ContextLookupOptions & {collect: false}): Promise<T | null>;\n  /**\n   * Looks up context values associated with the given name.\n   *\n   * The Promise resolves to all associated values in the context tree as array in context-descending order,\n   * i.e., more specific context values precede others, in other words, values of child contexts precede values of parent contexts.\n   * If not finding a value in any context, the Promise resolves to an empty array.\n   *\n   * To only obtain the most specific value, i.e., the value of the closest context that has a value associated with that name,\n   * set {@link ContextLookupOptions#collect} to `false`.\n   *\n   * @param  name - The name of the context values to look up.\n   * @param  options - Instructs how to look up context values.\n   * @return A Promise that resolves to the values associated with the given name, or an empty array if not finding a value.\n   *         Collected values are sorted in context-descending order, i.e., more specific context values precede others, in\n   *         other words, values of child contexts precede values of parent contexts.\n   */\n  public lookup<T>(name: string, options: ContextLookupOptions & {collect: true}): Promise<T[]>;\n\n  public lookup<T>(name: string, options?: ContextLookupOptions): Promise<T | T[] | null> {\n    return firstValueFrom(this.observe$<T>(name, options));\n  }\n\n  /**\n   * Checks if a context value is associated with the given name at any level in the context tree.\n   *\n   * @param name - The name of the context value to check if present.\n   * @return A Promise that resolves to `true` if a context value is associated with the given name, or that resolves to `false` otherwise.\n   */\n  public isPresent(name: string): Promise<boolean> {\n    return this.lookup(name).then(value => value !== null);\n  }\n\n  /**\n   * Observes the names of context values registered at any level in the context tree.\n   *\n   * @return An Observable that emits the names of context values registered at any level in the context tree.\n   *         Upon subscription, it emits the names of context values currently registered, and then it emits whenever\n   *         some value is registered or unregistered from a context. The Observable never completes.\n   */\n  public names$(): Observable<Set<string>> {\n    if (Beans.get(IS_PLATFORM_HOST)) {\n      return concat(of(new Set<string>()), NEVER);\n    }\n\n    return this._contextTreeChange$\n      .pipe(\n        startWith(undefined as void),\n        switchMap(() => this.lookupContextNames$()),\n      );\n  }\n\n  /**\n   * Looks up the context tree for a value associated with the given name.\n   *\n   * @param  name - The name of the value to return.\n   * @param  options - Options to control context lookup.\n   * @return An Observable that emits the context value associated with the given key and then completes.\n   *         When the requested value is not found in a context, the Observable emits `null` and then completes.\n   */\n  private lookupContextValue$<T>(name: string, options?: ContextLookupOptions): Observable<T | T[] | null> {\n    return new Observable((observer: Observer<T | T[] | null>): TeardownLogic => {\n      const replyTo = UUID.randomUUID();\n      const unsubscribe$ = new Subject<void>();\n      const contextValueLookupRequest = Contexts.newContextValueLookupRequest(name, replyTo, options);\n\n      // Wait until the reply is received.\n      Beans.get(MessageClient).observe$<T | T[] | null | undefined>(replyTo)\n        .pipe(\n          take(1),\n          map(reply => reply.headers.get(MessageHeaders.Status) === ResponseStatusCodes.OK ? (reply.body ?? null) : null),\n          takeUntil(unsubscribe$),\n        )\n        .subscribe(observer);\n\n      // Send the request.\n      Promise.all([whenSubscribedToReplyTopic(replyTo), this._whenContextTreeChangeListenerInstalled])\n        .then(() => window.parent.postMessage(contextValueLookupRequest, '*'))\n        .catch(error => observer.error(error));\n\n      return (): void => unsubscribe$.next();\n    });\n  }\n\n  /**\n   * Looks up the context names of all values registered in the current and parent contexts.\n   *\n   * @return An Observable that emits the names of all values registered in the current and parent contexts and then completes.\n   */\n  private lookupContextNames$(): Observable<Set<string>> {\n    return new Observable((observer: Observer<Set<string>>): TeardownLogic => {\n      const replyTo = UUID.randomUUID();\n      const unsubscribe$ = new Subject<void>();\n      const contextNamesLookupRequest = Contexts.newContextTreeNamesLookupRequest(replyTo);\n\n      // Wait until the reply is received.\n      Beans.get(MessageClient).observe$<Set<string>>(replyTo)\n        .pipe(\n          take(1),\n          map(reply => reply.headers.get(MessageHeaders.Status) === ResponseStatusCodes.OK ? reply.body! : new Set<string>()),\n          takeUntil(unsubscribe$),\n        )\n        .subscribe(observer);\n\n      // Send the request.\n      Promise.all([whenSubscribedToReplyTopic(replyTo), this._whenContextTreeChangeListenerInstalled])\n        .then(() => window.parent.postMessage(contextNamesLookupRequest, '*'))\n        .catch(error => observer.error(error));\n      return (): void => unsubscribe$.next();\n    });\n  }\n\n  /**\n   * Installs a listener to get notified about context changes at any level in the context tree.\n   *\n   * @return A Promise that resolves when installed the listener.\n   */\n  private installContextTreeChangeListener(listener: (changeEvent: Contexts.ContextTreeChangeEvent) => void): Promise<void> {\n    const replyTo = UUID.randomUUID();\n    const contextObserveRequest = Contexts.newContextTreeObserveRequest(replyTo);\n\n    return new Promise<void>((resolve, reject) => {\n      // Receive change notifications.\n      Beans.get(MessageClient).observe$<Contexts.ContextTreeChangeEvent | Contexts.RootContextSubscribeEventType>(replyTo)\n        .pipe(\n          mapToBody(),\n          takeUntil(this._destroy$),\n        )\n        .subscribe({\n          next: (event: Contexts.ContextTreeChangeEvent | Contexts.RootContextSubscribeEventType) => {\n            if (event === Contexts.RootContextSubscribeEvent) {\n              resolve(); // resolve the promise as subscribed to all parent contexts.\n            }\n            else {\n              listener(event);\n            }\n          },\n          error: reject,\n        });\n\n      // Send the observe request.\n      whenSubscribedToReplyTopic(replyTo)\n        .then(() => window.parent.postMessage(contextObserveRequest, '*'))\n        .catch(error => reject(error));\n    });\n  }\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n\n/**\n * Resolves when subscribed to the given reply topic.\n *\n * @ignore\n */\nfunction whenSubscribedToReplyTopic(topic: string): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    Beans.get(MessageClient).subscriberCount$(topic)\n      .pipe(first(count => count === 1))\n      .subscribe({\n        error: reject,\n        complete: resolve,\n      });\n  });\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Urls} from '../../url.util';\n\n/**\n * Used by {@link OutletRouter} to convert relative paths to absolute paths.\n *\n * Replace this bean to use a different relative path resolution strategy.\n *\n * @see {@link OutletRouter}\n * @category Routing\n */\nexport class RelativePathResolver {\n\n  /**\n   * Converts the given relative path into a navigable URL with relative navigational symbols like `/`, `./`, or `../` resolved.\n   *\n   * @param  path - Specifies the path which to convert into an absolute path.\n   * @param  options - Specifies to which url the given path is relative to.\n   * @return the absolute path.\n   */\n  public resolve(path: string, options: {relativeTo: string}): string {\n    const relativeTo = Urls.newUrl(options.relativeTo);\n\n    // Check if hash-based routing is used\n    if (relativeTo.hash?.startsWith('#/')) {\n      // Apply navigational symbols only to the path of the hash-based route, and not to the context path before the hash, if any.\n      // For that reason, we temporarily remove the context path when constructing the URL.\n      const {pathname, search, hash} = Urls.newUrl(path, `${relativeTo.origin}${relativeTo.hash.substring(1)}`);\n      return relativeTo.origin + relativeTo.pathname + '#' + pathname + search + hash;\n    }\n    else {\n      return Urls.newUrl(path, options.relativeTo).toString();\n    }\n  }\n}\n\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {MessageClient} from '../messaging/message-client';\nimport {OUTLET_CONTEXT, OutletContext, PRIMARY_OUTLET, RouterOutlets} from './router-outlet.element';\nimport {ContextService} from '../context/context-service';\nimport {Urls} from '../../url.util';\nimport {RelativePathResolver} from './relative-path-resolver';\nimport {Maps} from '@scion/toolkit/util';\nimport {NavigationOptions, PUSH_STATE_TO_SESSION_HISTORY_STACK_MESSAGE_HEADER} from './metadata';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {Intent, mapToBody, RequestError} from '../../messaging.model';\nimport {lastValueFrom} from 'rxjs';\nimport {IntentClient} from '../messaging/intent-client';\nimport {ACTIVATION_CONTEXT, PlatformCapabilityTypes, Qualifier} from '../../platform.model';\n\n/**\n * Allows navigating to a web page or microfrontend in a {@link SciRouterOutletElement `<sci-router-outlet>`} element.\n *\n * In SCION Microfrontend Platform, routing means instructing a `<sci-router-outlet>` to display the content of a URL. Routing works\n * across microfrontend and micro application boundaries, allowing the URL of an outlet to be set from anywhere in the application. The\n * web content displayed in an outlet can be any HTML document that has not set the HTTP header X-Frame-Options. Routing is also referred\n * to as navigating.\n *\n * The router supports multiple outlets in the same application to co-exist. By giving an outlet a name, you can reference it as the\n * routing target. If not naming an outlet, its name defaults to {@link PRIMARY_OUTLET primary}. If multiple outlets have the same name,\n * they all show the same content. If routing in the context of a router outlet, that is inside a microfrontend, and not specifying a\n * routing target, the content of the current outlet is replaced.\n *\n * An outlet does not necessarily have to exist at the time of routing. When adding the outlet to the DOM, the outlet displays the last URL\n * routed for it. When repeating routing for an outlet, its content is replaced.\n *\n * A router outlet is defined as follows. If no navigation has been performed for the outlet yet, then its content is empty.\n *\n *  ```html\n * <sci-router-outlet name=\"aside\"></sci-router-outlet>\n * ```\n *\n * ### Navigation via URL\n * The URL of the page to be loaded into the router outlet is passed to the router, as follows:\n *\n * ```ts\n * Beans.get(OutletRouter).navigate('https://micro-frontends.org', {outlet: 'aside'});\n * ```\n *\n * #### Relative URL Navigation\n * The router allows to use both absolute and relative paths. A relative path begins with a navigational symbol `/`, `./`, or `../`. By default,\n * relative navigation is relative to the current window location of the navigating application, unless specifying a base path for the navigation.\n *\n * ```ts\n * // Navigation relative to the root path segment\n * Beans.get(OutletRouter).navigate('/products/:id', {outlet: PRIMARY_OUTLET});\n *\n * // Navigation relative to the parent path segment\n * Beans.get(OutletRouter).navigate('../products/:id', {outlet: PRIMARY_OUTLET});\n * ```\n *\n * #### Named URL Parameters\n * The URL being passed to the router can contain named parameters which the router replaces with values of the provided params object.\n * A named parameter begins with a colon (`:`) and is allowed in path segments, query parameters, matrix parameters and the fragment part,\n * e.g., `product/:id` or `product;id=:id` or `products?id=:id`.\n *\n * ### Navigating via Intent\n * As an alternative to navigating directly to a URL, the router supports navigation to a microfrontend capability via an intent.\n * We refer to this as intent-based routing.\n *\n * We recommend using intent-based routing over url-based routing, especially for cross-application navigations, since the navigation flows\n * are explicit, i.e., declared in the manifest, and to keep the microfrontend URLs an implementation detail of the micro applications that\n * provide the microfrontends.\n *\n * Note that if the microfrontend is provided by another micro app, the navigating app must manifest an intention. Also, the navigating\n * app can only navigate to public microfrontend capabilities.\n *\n * The following code snippet illustrates how to display the _product_ microfrontend in the \"aside\" outlet. Note that you only need to pass\n * the qualifier of the microfrontend capability and not its type. The capability type, which is always `microfrontend`, is implicitly set\n * by the router.\n *\n * ```ts\n * Beans.get(OutletRouter).navigate({entity: 'product'}, {\n *   outlet: 'aside',\n *   params: {id: 123},\n * });\n * ```\n *\n * Applications can provide microfrontend capabilities through their manifest. A microfrontend can be either application private or exposed to\n * other micro applications. The platform requires all microfrontend capabilities to be of type `microfrontend`. A particular microfrontend can\n * be identified using its qualifier.\n *\n * ```json\n * {\n *   \"type\": \"microfrontend\",\n *   \"qualifier\": {\n *     \"entity\": \"product\"\n *   },\n *   \"description\": \"Displays a product.\",\n *   \"params\": [\n *     {\"name\": \"id\", \"required\": true}\n *   ],\n *   \"private\": false,\n *   \"properties\": {\n *     \"path\": \"product/:id\",\n *   }\n * }\n * ```\n *\n * Note that the providing micro application does not need to install an intent handler for its microfrontend capabilities. The platform intercepts\n * microfrontend intents and performs the navigation.\n *\n * ### Persistent Navigation\n * Persistent navigation refers to the mechanism for restoring the navigational state after an application reload.\n *\n * The router does not provide an implementation for persistent navigation out-of-the-box, mostly because many persistence strategies are imaginable.\n * For example, the navigational state could be added to the top-level URL, stored in local storage, or persisted in the backend.\n * However, you can easily implement persistent navigation yourself. The router publishes navigations to the topic `sci-router-outlets/:outlet/url`;\n * thus, they can be captured and persisted. When starting the application, you can then replay persisted navigations using the router.\n *\n * ### Unloading Outlet Content\n * To unload an outlets content, use null as the URL when routing, as follows:\n *\n * ```ts\n * Beans.get(OutletRouter).navigate(null, {outlet: 'aside'});\n * ```\n *\n * ### Browsing History and Session History\n * Routing does not add an entry to the browsing history, and, by default, not push a navigational state to the browsers session history stack.\n *\n * You can instruct the router to add a navigational state to the browsers session history stack, allowing the user to use the back button of the browser to\n * navigate back in an outlet.\n *\n * ```ts\n * Beans.get(OutletRouter).navigate('https://micro-frontends.org', {\n *   outlet: 'aside',\n *   pushStateToSessionHistoryStack: true,\n * });\n * ```\n *\n * @see {@link SciRouterOutletElement}\n *\n * @category Routing\n */\nexport class OutletRouter {\n\n  /**\n   * Navigates to the passed URL.\n   *\n   * If not specifying an outlet and if navigating in the context of an outlet, that outlet will be used as the navigation target,\n   * or the {@link PRIMARY_OUTLET primary} outlet otherwise.\n   *\n   * @param  url - Specifies the URL of the page to be loaded into the router outlet. To clear the outlet, pass `null` as the URL.\n   *         The URL allows the use of navigational symbols and named parameters. A named parameter begins with a colon (`:`)\n   *         and is allowed in path segments, query parameters, matrix parameters and the fragment part. Named parameters\n   *         are replaced with values passed via {@link NavigationOptions#params}. Named query and matrix parameters without\n   *         a replacement are removed.\n   *         Examples:\n   *         - `product/:id` // named path parameter\n   *         - `product;id=:id` // named matrix parameter\n   *         - `products?id=:id` // named query parameter\n   * @param  options - Instructs the router how to navigate, for example, you can specify the router outlet or pass named parameter values for substitution.\n   * @return Promise that resolves when navigated, or that rejects otherwise.\n   */\n  public navigate(url: string | null, options?: NavigationOptions): Promise<void>;\n  /**\n   * Navigates to the microfrontend provided as {@link MicrofrontendCapability} matching the passed qualifier.\n   *\n   * We recommend using intent-based routing over url-based routing, especially for cross-application navigations, since the navigation flows are\n   * explicit, i.e., declared in the manifest, and to keep the microfrontend URLs an implementation detail of the micro applications that provide\n   * the microfrontends.\n   *\n   * If the microfrontend is provided by another micro app, the navigating app must manifest an intention. Also, the navigating app can only navigate\n   * to public microfrontend capabilities.\n   *\n   * If not specifying an outlet and if navigating in the context of an outlet, that outlet will be used as the navigation target,\n   * or the {@link PRIMARY_OUTLET primary} outlet otherwise.\n   *\n   * @param  qualifier - Qualifies the microfrontend which to load into the outlet.\n   * @param  options - Instructs the router how to navigate, for example, you can specify the router outlet or pass intent parameters.\n   * @return Promise that resolves when navigated, or that rejects otherwise.\n   */\n  public navigate(qualifier: Qualifier, options?: NavigationOptions): Promise<void>;\n\n  public async navigate(target: string | Qualifier | null, options?: NavigationOptions): Promise<void> {\n    if (!target || typeof target === 'string') {\n      await this.navigateByUrl(target as string, options);\n    }\n    else {\n      await this.navigateByIntent(target, options);\n    }\n  }\n\n  /**\n   * Navigates to specified URL.\n   */\n  private async navigateByUrl(url: string | null, options?: NavigationOptions): Promise<void> {\n    const outlet = options?.outlet || await this.resolveContextualOutlet() || PRIMARY_OUTLET;\n    const outletUrlTopic = RouterOutlets.urlTopic(outlet);\n    const navigationUrl = this.computeNavigationUrl(url, options);\n\n    return Beans.get(MessageClient).publish(outletUrlTopic, navigationUrl, {\n      retain: true,\n      headers: new Map<string, any>().set(PUSH_STATE_TO_SESSION_HISTORY_STACK_MESSAGE_HEADER, options?.pushStateToSessionHistoryStack ?? false),\n    });\n  }\n\n  /**\n   * Navigates to a microfrontend available as {@link MicrofrontendCapability} matching the passed qualifier.\n   */\n  private async navigateByIntent(qualifier: Qualifier, options?: NavigationOptions): Promise<void> {\n    if (options?.relativeTo) {\n      throw Error('[OutletRouterError][UnsupportedOptionError] Unsupported navigation option \"relativeTo\". This option is not supported in intent-based routing.');\n    }\n\n    const contextualOutlet = await this.resolveContextualOutlet();\n    const intent: Intent = {type: PlatformCapabilityTypes.Microfrontend, qualifier, params: Maps.coerce(options?.params)};\n    const navigate$ = Beans.get(IntentClient).request$<void>(intent, options, {headers: new Map().set(ROUTING_CONTEXT_MESSAGE_HEADER, {[ROUTING_CONTEXT_OUTLET]: contextualOutlet})});\n    try {\n      await lastValueFrom(navigate$.pipe(mapToBody()));\n    }\n    catch (error) {\n      throw (error instanceof RequestError ? error.message : error);\n    }\n  }\n\n  private computeNavigationUrl(urlPattern: string | null | undefined, options?: NavigationOptions): string {\n    if (urlPattern === undefined || urlPattern === null) { // empty path is a valid url\n      return 'about:blank';\n    }\n\n    const params = Maps.coerce(options?.params);\n    const url = this.substituteNamedParameters(urlPattern, params);\n    if (Urls.isAbsoluteUrl(url)) {\n      return url;\n    }\n    else {\n      const relativeTo = options?.relativeTo ?? window.location.href;\n      return Beans.get(RelativePathResolver).resolve(url, {relativeTo});\n    }\n  }\n\n  private async resolveContextualOutlet(): Promise<string | undefined> {\n    // If navigating in the context of an activator, do not use that outlet as contextual outlet.\n    if (await Beans.get(ContextService).isPresent(ACTIVATION_CONTEXT)) {\n      return undefined;\n    }\n    return (await Beans.get(ContextService).lookup<OutletContext>(OUTLET_CONTEXT))?.name;\n  }\n\n  /**\n   * Replaces named parameters in the given path with values contained in the given {@link Map}.\n   * Named parameters begin with a colon (`:`) and are allowed in path segments, query parameters, matrix parameters\n   * and the fragment part.\n   *\n   * Empty query and matrix params are removed, but not empty path params.\n   *\n   * Some examples about the usage of named parameters:\n   * /segment/:param1/segment/:param2 // path params\n   * /segment/segment;matrixParam1=:param1;matrixParam2=:param2 // matrix params\n   * /segment/segment?queryParam1=:param1&queryParam2=:param2 // query params\n   */\n  private substituteNamedParameters(path: string, params: Map<string, any>): string {\n    return path\n      // 1. Replace named params contained in the params map.\n      .replace(/:([^/;&?#]+)/g, (match, paramName) => params.get(paramName) !== undefined ? params.get(paramName) : match)\n      // 2. Remove named matrix params not contained in the params map.\n      .replace(/(?<delimiter>;)(?<paramName>[^=]+)=:(?<placeholder>[^;#?/]+)/g, () => {\n        return '';\n      })\n      // 3. Remove named query params not contained in the params map. Replaces the first query param\n      //    with a special marker for later substitution.\n      .replace(/(?<delimiter>[?&])(?<paramName>[^=]+)=:(?<placeholder>[^&#]+)/g, (match, delimiter) => {\n        return (delimiter === '?') ? '__?__' : '';\n      })\n      // 4. Replace the marker with the question mark if at least one query parameter is present.\n      .replace(/__\\?__&/, '?')\n      // 5. Remove marker if no query params are present.\n      .replace(/__\\?__/, '');\n  }\n}\n\n/**\n * Message header with information about the current context of the navigator.\n * @internal\n */\nexport const ROUTING_CONTEXT_MESSAGE_HEADER = 'context';\n\n/**\n * Name of the current outlet if navigating in the context of an outlet.\n * @internal\n */\nexport const ROUTING_CONTEXT_OUTLET = 'outlet';\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Observable} from 'rxjs';\nimport {PlatformTopics} from '../../messaging.model';\nimport {MessageClient} from '../messaging/message-client';\nimport {mapToBody} from '../../messaging.model';\nimport {Beans} from '@scion/toolkit/bean-manager';\n\n/**\n * Allows observing if the current microfrontend has received focus or contains embedded web content that has received focus.\n *\n * @category Focus\n */\nexport class FocusMonitor {\n\n  /**\n   * Observable that emits when the current microfrontend or any of its child microfrontends has gained or lost focus.\n   * The Observable does not emit while the focus remains within this microfrontend or any of its child microfrontends.\n   * Upon subscription, the Observable emits the current focus-within state, and then continuously emits when it changes.\n   * It never completes.\n   *\n   * This Observable is like the `:focus-within` CSS pseudo-class but operates across iframe boundaries.\n   * For example, it can be useful when implementing overlays that close upon focus loss.\n   *\n   * Note that this Observable emits only for microfrontends that are connected to the platform as registered micro app.\n   *\n   * See also the `onfocuswithin` event triggered by `<sci-router-outlet>` when embedded content has gained or lost focus.\n   */\n  public readonly focusWithin$: Observable<boolean> = Beans.get(MessageClient).request$<boolean>(PlatformTopics.IsFocusWithin).pipe(mapToBody());\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {fromEvent, Subject} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {MessageClient} from '../messaging/message-client';\nimport {PlatformTopics} from '../../messaging.model';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {FocusMonitor} from './focus-monitor';\nimport {OUTLET_CONTEXT, OutletContext, RouterOutlets} from '../router-outlet/router-outlet.element';\nimport {ContextService} from '../context/context-service';\n\n/**\n * Sends a 'focusin' event to the topic {@link PlatformTopics.FocusIn} when this document gains focus.\n *\n * @see FocusTracker\n * @ignore\n */\nexport class FocusInEventDispatcher implements PreDestroy {\n\n  private _destroy$ = new Subject<void>();\n\n  constructor() {\n    // IMPORTANT: In Angular applications, the platform should be started outside of the Angular zone in order to avoid excessive change detection cycles\n    // of platform-internal subscriptions to global DOM events. For that reason, we subscribe to `window.focus` events in the dispatcher's constructor.\n    this.makeWindowFocusable();\n    this.dispatchDocumentFocusInEvent();\n    this.reportFocusWithinEventToParentOutlet();\n  }\n\n  /**\n   * Installs a listener for `focusin` events.\n   */\n  private dispatchDocumentFocusInEvent(): void {\n    fromEvent<FocusEvent>(window, 'focusin')\n      .pipe(takeUntil(this._destroy$))\n      .subscribe(event => {\n        // Do not dispatch the event if the focusing occurs within this document.\n        // In this case, the related target is set, unless the focus owner is disposed.\n        if (!event.relatedTarget) {\n          Beans.get(MessageClient).publish(PlatformTopics.FocusIn, null, {retain: true}); // do not set `undefined` as payload as this would delete the retained message\n        }\n      });\n  }\n\n  /**\n   * Reports the embedding outlet when the current microfrontend or any of its child microfrontends has gained or lost focus.\n   * It does not report while the focus remains within this microfrontend or any of its child microfrontends.\n   */\n  private async reportFocusWithinEventToParentOutlet(): Promise<void> {\n    const outletContext = await Beans.get(ContextService).lookup<OutletContext>(OUTLET_CONTEXT);\n    if (!outletContext) {\n      return;\n    }\n\n    Beans.get(FocusMonitor).focusWithin$\n      .pipe(takeUntil(this._destroy$))\n      .subscribe(focusWithin => {\n        const publishTo = RouterOutlets.focusWithinOutletTopic(outletContext.uid);\n        Beans.get(MessageClient).publish<boolean>(publishTo, focusWithin);\n      });\n  }\n\n  /**\n   * Makes this Window focusable in order to receive 'focusin' events.\n   */\n  private makeWindowFocusable(): void {\n    const body = window.document.body;\n    body.setAttribute('tabindex', '0');\n    body.style.outline = 'none';\n  }\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {BehaviorSubject, Subject} from 'rxjs';\nimport {distinctUntilChanged, map, takeUntil} from 'rxjs/operators';\nimport {MessageClient, takeUntilUnsubscribe} from '../../client/messaging/message-client';\nimport {MessageHeaders, TopicMessage} from '../../messaging.model';\nimport {runSafe} from '../../safe-runner';\nimport {PlatformTopics} from '../../messaging.model';\nimport {ClientRegistry} from '../client-registry/client.registry';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {Client} from '../client-registry/client';\n\n/**\n * Tracks the focus across microfrontends and answers {@link PlatformTopics.IsFocusWithin} requests.\n *\n * @see FocusInEventDispatcher\n * @see FocusMonitor\n * @ignore\n */\nexport class FocusTracker implements PreDestroy {\n\n  private _destroy$ = new Subject<void>();\n  private _focusOwner$ = new BehaviorSubject<Client | undefined>(undefined);\n\n  constructor() {\n    this.monitorFocusInEvents();\n    this.replyToIsFocusWithinRequests();\n  }\n\n  /**\n   * Monitors when a client gains the focus.\n   */\n  private monitorFocusInEvents(): void {\n    Beans.get(MessageClient).observe$<void>(PlatformTopics.FocusIn)\n      .pipe(\n        map(event => event.headers.get(MessageHeaders.ClientId)),\n        distinctUntilChanged(),\n        takeUntil(this._destroy$),\n      )\n      .subscribe(clientId => runSafe(() => {\n        this._focusOwner$.next(Beans.get(ClientRegistry).getByClientId(clientId) || undefined);\n      }));\n  }\n\n  /**\n   * Replies to 'focus-within' requests.\n   */\n  private replyToIsFocusWithinRequests(): void {\n    Beans.get(MessageClient).observe$<void>(PlatformTopics.IsFocusWithin)\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((request: TopicMessage<void>) => runSafe(() => {\n        const clientId = request.headers.get(MessageHeaders.ClientId);\n        const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n\n        this._focusOwner$\n          .pipe(\n            map(focusOwner => this.isFocusWithin(clientId, focusOwner)),\n            distinctUntilChanged(),\n            takeUntilUnsubscribe(replyTo),\n            takeUntil(this._destroy$),\n          )\n          .subscribe((isFocusWithin: boolean) => { // eslint-disable-line rxjs/no-nested-subscribe\n            Beans.get(MessageClient).publish(replyTo, isFocusWithin);\n          });\n      }));\n  }\n\n  /**\n   * Tests whether the given client has received focus or contains embedded web content that has received focus.\n   */\n  private isFocusWithin(clientId: string, focusOwner: Client | undefined): boolean {\n    for (let client = focusOwner; client !== undefined; client = this.getParentClient(client)) {\n      if (client.id === clientId) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getParentClient(client: Client): Client | undefined {\n    if (client.window.parent === client.window) {\n      return undefined; // window has no parent as it is the top-level window\n    }\n    return Beans.get(ClientRegistry).getByWindow(client.window.parent);\n  }\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {fromDimension$} from '@scion/toolkit/observable';\nimport {combineLatestWith, filter, takeUntil} from 'rxjs/operators';\nimport {merge, Subject} from 'rxjs';\nimport {ContextService} from '../context/context-service';\nimport {OUTLET_CONTEXT, OutletContext, RouterOutlets} from '../router-outlet/router-outlet.element';\nimport {MessageClient} from '../messaging/message-client';\nimport {PreferredSize} from './preferred-size';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {runSafe} from '../../safe-runner';\n\n/**\n * Allows web content displayed in a {@link SciRouterOutletElement `<sci-router-outlet>`} to define its preferred size.\n *\n * The preferred size of an element is the minimum size that will allow it to display normally.\n * Setting a preferred size is useful if the outlet is displayed in a layout that aligns its items based on the items's content size.\n *\n * When setting a preferred size, the outlet containing this microfrontend will adapt its size to the reported preferred size.\n *\n * @category Preferred Size\n */\nexport class PreferredSizeService implements PreDestroy {\n\n  private _destroy$ = new Subject<void>();\n  private _fromDimensionElementChange$ = new Subject<void>();\n  private _preferredSizePublisher = new PreferredSizePublisher();\n\n  /**\n   * Sets the preferred size of this web content.\n   * The size is reported to the router outlet embedding this web content and is used as the outlet's size.\n   */\n  public setPreferredSize(preferredSize: PreferredSize): void {\n    this._preferredSizePublisher.publish(preferredSize);\n  }\n\n  /**\n   * Determines the preferred size from the given element's dimension and reports it to the router outlet embedding this web content.\n   * As the value for the preferred size, the `offset-width` and `offset-height` of the element are used, which is the total amount of space\n   * the element occupies, including the width of the visible content, scrollbars (if any), padding, and border.\n   *\n   * When the size of the element changes, the changed size is reported to the outlet, which then adaps its size accordingly.\n   * To stop the notifying of the preferred size to the outlet, pass `undefined` as the value, which also unsets the preferred size.\n   *\n   * If the element is removed from the DOM, the preferred size is reset and reporting suspended until it is attached again.\n   * If a new element is set as dimension observer, then the previous one is unsubscribed.\n   *\n   * *Prerequisites*\n   * - The element to be observed must behave as block-level box and not as inline-level box. So, if you want to observe an inline element,\n   *   set its display type to either `block` or `inline-block`.\n   * - If the element to be observed should not fill the remaining space and may change in size, we recommend taking it out of the document\n   *   element flow, i.e., position it absolutely without defining a width and height. Otherwise, once the element has reported a preferred\n   *   size, it could not shrink below that size.\n   *\n   * @param element - The element of which the preferred size is to be observed and used as the outlet's size.\n   */\n  public fromDimension(element: HTMLElement | undefined): void {\n    this._fromDimensionElementChange$.next();\n\n    if (!element) {\n      this.resetPreferredSize();\n      return;\n    }\n\n    fromDimension$(element)\n      .pipe(takeUntil(merge(this._fromDimensionElementChange$, this._destroy$)))\n      .subscribe(dimension => {\n        // If the element is removed from the DOM, the preferred size is reset and reporting suspended until it is attached again.\n        if (!document.body.contains(dimension.element)) {\n          this.resetPreferredSize();\n        }\n        else {\n          this.setPreferredSize({\n            minWidth: `${dimension.offsetWidth}px`,\n            width: `${dimension.offsetWidth}px`,\n            maxWidth: `${dimension.offsetWidth}px`,\n            minHeight: `${dimension.offsetHeight}px`,\n            height: `${dimension.offsetHeight}px`,\n            maxHeight: `${dimension.offsetHeight}px`,\n          });\n        }\n      });\n  }\n\n  /**\n   * Resets the preferred size. Has no effect if no preferred size is set.\n   */\n  public resetPreferredSize(): void {\n    this._preferredSizePublisher.publish(null);\n  }\n\n  /** @ignore */\n  public preDestroy(): void {\n    this._preferredSizePublisher.destroy();\n    this._destroy$.next();\n  }\n}\n\n/**\n * Publishes the preferred size to the outlet embedding this page.\n */\nclass PreferredSizePublisher {\n\n  private _preferredSize$ = new Subject<PreferredSize | null>();\n  private _destroy$ = new Subject<void>();\n\n  constructor() {\n    this._preferredSize$\n      .pipe(\n        combineLatestWith(Beans.get(ContextService).observe$<OutletContext>(OUTLET_CONTEXT).pipe(filter(Boolean))),\n        takeUntil(this._destroy$),\n      )\n      .subscribe(([preferredSize, outletContext]) => runSafe(() => {\n        const topic = RouterOutlets.preferredSizeTopic(outletContext.uid);\n        Beans.get(MessageClient).publish(topic, preferredSize);\n      }));\n  }\n\n  public publish(preferredSize: PreferredSize | null): void {\n    this._preferredSize$.next(preferredSize);\n  }\n\n  public destroy(): void {\n    this._destroy$.next();\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {fromEvent, Subject} from 'rxjs';\nimport {auditTime, filter, takeUntil} from 'rxjs/operators';\nimport {MessageClient} from '../messaging/message-client';\nimport {UUID} from '@scion/toolkit/uuid';\nimport {mapToBody} from '../../messaging.model';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\n\n/**\n * Dispatches 'mousemove' events originating from other documents as synthetic 'sci-mousemove' events on the document event bus.\n * The events are only propagated when the primary mouse button is pressed down.\n *\n * Mouse event dispatching is important when using custom scrollbars which are positioned at the iframe border. It allows the user\n * to scroll seamlessly even when the mouse cursor leaves the iframe, which is because by default, mouse events are only received\n * by the currently hovering document.\n *\n * @ignore\n */\nexport class MouseMoveEventDispatcher implements PreDestroy {\n\n  private _destroy$ = new Subject<void>();\n  private _dispatcherId = UUID.randomUUID();\n\n  constructor() {\n    // IMPORTANT: In Angular applications, the platform should be started outside of the Angular zone in order to avoid excessive change detection cycles\n    // of platform-internal subscriptions to global DOM events. For that reason, we subscribe to `document.mousemove` events in the dispatcher's constructor.\n    this.produceSynthEvents();\n    this.consumeSynthEvents();\n  }\n\n  /**\n   * Produces synth events from native 'mousemove' events and publishes them on the message bus.\n   * It allows event dispatchers in other documents to consume these events and publish them on the document's event bus.\n   */\n  private produceSynthEvents(): void {\n    fromEvent<MouseEvent>(document, 'mousemove')\n      .pipe(\n        filter(event => event.buttons === PRIMARY_MOUSE_BUTTON),\n        auditTime(20),\n        takeUntil(this._destroy$),\n      )\n      .subscribe((event: MouseEvent) => {\n        const options = {headers: new Map().set(DISPATCHER_ID_HEADER, this._dispatcherId)};\n        Beans.get(MessageClient).publish(MOUSEMOVE_EVENT_TOPIC, [event.screenX, event.screenY], options);\n      });\n  }\n\n  /**\n   * Consumes synth events produced by dispatchers from other documents and dispatches them on the event bus of the current document.\n   */\n  private consumeSynthEvents(): void {\n    Beans.get(MessageClient).observe$<[number, number]>(MOUSEMOVE_EVENT_TOPIC)\n      .pipe(\n        filter(msg => msg.headers.get(DISPATCHER_ID_HEADER) !== this._dispatcherId),\n        mapToBody(),\n        takeUntil(this._destroy$),\n      )\n      .subscribe(([screenX, screenY]: [number, number]) => {\n        const sciMouseEvent: any = new Event('sci-mousemove');\n        sciMouseEvent.screenX = screenX;\n        sciMouseEvent.screenY = screenY;\n        document.dispatchEvent(sciMouseEvent);\n      });\n  }\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n\n/**\n * Indicates that the primary mouse button is pressed (usually left).\n *\n * @ignore\n */\nconst PRIMARY_MOUSE_BUTTON = 1;\n/**\n * Message header to pass the dispatcher's identity.\n *\n * @ignore\n */\nconst DISPATCHER_ID_HEADER = 'DISPATCHER_ID';\n/**\n * Topic to publish 'mousemove' events so that they can be consumed by dispatchers of other documents.\n *\n * @ignore\n */\nconst MOUSEMOVE_EVENT_TOPIC = 'MOUSEMOVE';\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {fromEvent, Subject} from 'rxjs';\nimport {filter, takeUntil} from 'rxjs/operators';\nimport {MessageClient} from '../messaging/message-client';\nimport {UUID} from '@scion/toolkit/uuid';\nimport {mapToBody} from '../../messaging.model';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\n\n/**\n * Dispatches 'mouseup' events originating from other documents as synthetic 'sci-mouseup' events on the document event bus.\n *\n * Mouse event dispatching is important when using custom scrollbars which are positioned at the iframe border. It allows the user\n * to scroll seamlessly even when the mouse cursor leaves the iframe, which is because by default, mouse events are only received\n * by the currently hovering document.\n *\n * @ignore\n */\nexport class MouseUpEventDispatcher implements PreDestroy {\n\n  private _destroy$ = new Subject<void>();\n  private _dispatcherId = UUID.randomUUID();\n\n  constructor() {\n    // IMPORTANT: In Angular applications, the platform should be started outside of the Angular zone in order to avoid excessive change detection cycles\n    // of platform-internal subscriptions to global DOM events. For that reason, we subscribe to `document.mouseup` events in the dispatcher's constructor.\n    this.produceSynthEvents();\n    this.consumeSynthEvents();\n  }\n\n  /**\n   * Produces synth events from native 'mouseup' events and publishes them on the message bus.\n   * It allows event dispatchers in other documents to consume these events and publish them on the document's event bus.\n   */\n  private produceSynthEvents(): void {\n    fromEvent<MouseEvent>(document, 'mouseup')\n      .pipe(takeUntil(this._destroy$))\n      .subscribe(() => {\n        const options = {headers: new Map().set(DISPATCHER_ID_HEADER, this._dispatcherId)};\n        Beans.get(MessageClient).publish(MOUSEUP_EVENT_TOPIC, undefined, options);\n      });\n  }\n\n  /**\n   * Consumes synth events produced by dispatchers from other documents and dispatches them on the event bus of the current document.\n   */\n  private consumeSynthEvents(): void {\n    Beans.get(MessageClient).observe$<void>(MOUSEUP_EVENT_TOPIC)\n      .pipe(\n        filter(msg => msg.headers.get(DISPATCHER_ID_HEADER) !== this._dispatcherId),\n        mapToBody(),\n        takeUntil(this._destroy$),\n      )\n      .subscribe(() => {\n        document.dispatchEvent(new Event('sci-mouseup'));\n      });\n  }\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n\n/**\n * Message header to pass the dispatcher's identity.\n *\n * @ignore\n */\nconst DISPATCHER_ID_HEADER = 'DISPATCHER_ID';\n/**\n * Topic to publish 'mouseup' events so that they can be consumed by dispatchers of other documents.\n *\n * @ignore\n */\nconst MOUSEUP_EVENT_TOPIC = 'MOUSEUP';\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {fromEvent, merge, MonoTypeOperatorFunction, Observable, OperatorFunction, Subject, withLatestFrom} from 'rxjs';\nimport {filter, map, switchMap, takeUntil, tap} from 'rxjs/operators';\nimport {MessageClient} from '../messaging/message-client';\nimport {ContextService} from '../context/context-service';\nimport {KEYSTROKE_CONTEXT_NAME_PREFIX, OUTLET_CONTEXT, OutletContext, RouterOutlets} from '../router-outlet/router-outlet.element';\nimport {Keystroke, KeystrokeFlags} from './keystroke';\nimport {runSafe} from '../../safe-runner';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {filterArray, mapArray} from '@scion/toolkit/operators';\n\n/**\n * Propagates keyboard events for keystrokes registered in the current context or any parent contexts.\n *\n * This dispatcher listens to keyboard events for keystrokes registered in parent contexts and publishes\n * them as {@link KeyboardEventInit} events to the topic {@link RouterOutlets.keyboardEventTopic}.\n *\n * @ignore\n */\nexport class KeyboardEventDispatcher implements PreDestroy {\n\n  private _destroy$ = new Subject<void>();\n  private _keyboardEvents$ = new Subject<KeyboardEvent>();\n\n  constructor() {\n    this.installKeyboardEventListener();\n    this.installKeystrokeListener();\n  }\n\n  /**\n   * Subscribes to keyboard events on document-level and emits them on the {@link _keyboardEvents$} Observable.\n   *\n   * IMPORTANT NOTE FOR ANGULAR APPLICATIONS:\n   * Always subscribe to top-level DOM events during event dispatcher construction. Event dispatchers are eagerly constructed on platform startup.\n   * Typically, Angular applications connect to the platform outside of the Angular zone to avoid excessive change detection cycles for irrelevant DOM events.\n   */\n  private installKeyboardEventListener(): void {\n    merge(fromEvent<KeyboardEvent>(document, 'keydown'), fromEvent<KeyboardEvent>(document, 'keyup'))\n      .pipe(\n        filter(event => event.bubbles && !!event.key),\n        takeUntil(this._destroy$),\n      )\n      .subscribe(event => this._keyboardEvents$.next(event));\n  }\n\n  private installKeystrokeListener(): void {\n    Beans.get(ContextService).names$()\n      .pipe(\n        map(contextNames => Array.from(contextNames)),\n        filterArray(contextName => contextName.startsWith(KEYSTROKE_CONTEXT_NAME_PREFIX)),\n        mapArray(keystrokeContextName => keystrokeContextName.substring(KEYSTROKE_CONTEXT_NAME_PREFIX.length)),\n        mapArray(keystroke => this.observeKeyboardEvent$(keystroke)),\n        switchMap(keyboardEvents => merge(...keyboardEvents)),\n        withLatestFrom(Beans.get(ContextService).observe$<OutletContext>(OUTLET_CONTEXT).pipe(filter(Boolean))),\n        takeUntil(this._destroy$),\n      )\n      .subscribe(([event, outletContext]) => runSafe(() => this.onKeyboardEventToPropagate(event, outletContext.uid)));\n  }\n\n  /**\n   * Method invoked for each keyboard events to be propagated to the parent router outlet across the iframe boundary.\n   */\n  private onKeyboardEventToPropagate(event: KeyboardEvent, outletIdentity: string): void {\n    const eventInit: KeyboardEventInit = {\n      key: event.key,\n      ctrlKey: event.ctrlKey,\n      shiftKey: event.shiftKey,\n      altKey: event.altKey,\n      metaKey: event.metaKey,\n      bubbles: event.bubbles,\n    };\n\n    const publishTo = RouterOutlets.keyboardEventTopic(outletIdentity, event.type);\n    Beans.get(MessageClient).publish<KeyboardEventInit>(publishTo, eventInit);\n  }\n\n  /**\n   * Observes keyboard events matching the given keystroke, applying flags as declared on the keystroke.\n   */\n  private observeKeyboardEvent$(keystroke: string): Observable<KeyboardEvent> {\n    return Beans.get(ContextService).observe$<KeystrokeFlags>(KEYSTROKE_CONTEXT_NAME_PREFIX + keystroke, {collect: true})\n      .pipe(\n        map(collectedFlags => Keystroke\n          .fromString(keystroke)\n          .withFlags(collectedFlags.reduceRight((acc, flags) => ({...acc, ...flags}), {} as KeystrokeFlags)),\n        ),\n        this.switchToKeyboardEvents(),\n      );\n  }\n\n  private switchToKeyboardEvents(): OperatorFunction<Keystroke, KeyboardEvent> {\n    return switchMap(keystroke => this._keyboardEvents$\n      .pipe(\n        filter(event => event.type === keystroke.eventType),\n        filter(event => Keystroke.fromEvent(event).parts === keystroke.parts),\n        applyKeystrokeFlags(keystroke.flags),\n      ),\n    );\n  }\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n\n/**\n * Applies keystroke flags on each keyboard event emitted by the source Observable.\n *\n * Note that `preventDefault()` has to be invoked on the original event, which has its `isTrusted` flag set to `true`.\n *\n * For more information about trusted events\n * @see https://www.w3.org/TR/DOM-Level-3-Events/#trusted-events\n * @see https://www.chromestatus.com/features#istrusted\n *\n * @internal\n */\nfunction applyKeystrokeFlags(flags: KeystrokeFlags | undefined): MonoTypeOperatorFunction<KeyboardEvent> {\n  return tap(keystrokeEvent => {\n    if (flags?.preventDefault) {\n      keystrokeEvent.preventDefault();\n    }\n  });\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {QualifierMatcher} from '../../qualifier-matcher';\nimport {merge, Observable, Subject} from 'rxjs';\nimport {Arrays, Maps} from '@scion/toolkit/util';\nimport {Qualifier} from '../../platform.model';\nimport {ManifestObject, ManifestObjectFilter} from './manifest-object.model';\nimport {map} from 'rxjs/operators';\n\n/**\n * Provides an in-memory store for provided capabilities and registered intentions.\n *\n * @ignore\n */\nexport class ManifestObjectStore<T extends ManifestObject> {\n\n  private readonly _objectById = new Map<string, T>();\n  private readonly _objectsByType = new Map<string, T[]>();\n  private readonly _objectsByApplication = new Map<string, T[]>();\n  private readonly _add$ = new Subject<T>();\n  private readonly _remove$ = new Subject<T[]>();\n\n  /**\n   * Adds the given {@link ManifestObject} to this store.\n   */\n  public add(object: T): void {\n    this._objectById.set(object.metadata!.id, object);\n    Maps.addListValue(this._objectsByType, object.type, object);\n    Maps.addListValue(this._objectsByApplication, object.metadata!.appSymbolicName, object);\n    this._add$.next(object);\n  }\n\n  /**\n   * Removes manifest objects from this store that match the given filter.\n   *\n   * @param filter - Control which manifest objects to remove by specifying filter criteria which are \"AND\"ed together.\n   *        Wildcards in the qualifier criterion, if any, are not interpreted as wildcards, but as exact values instead.\n   */\n  public remove(filter: ManifestObjectFilter): void {\n    const objectsToRemove = this.find(filter);\n    this._remove(objectsToRemove);\n  }\n\n  /**\n   * Finds manifest objects that match the given filter.\n   *\n   * @param filter - Control which manifest objects to return.\n   *        Specified filter criteria are \"AND\"ed together. If no filter criteria are specified, all objects will be returned.\n   * @param qualifierPredicate - Predicate for testing qualifiers; is used in combination with a qualifier filter.\n   *        If not specifying a predicate, qualifiers will be matched against the specified qualifier filter, supporting\n   *        the asterisk wildcard, but not the optional wildcard character.\n   */\n  public find(filter: ManifestObjectFilter, qualifierPredicate?: (testee: Qualifier) => boolean): T[] {\n    const filterById = filter.id !== undefined;\n    const filterByType = filter.type !== undefined;\n    const filterByApp = filter.appSymbolicName !== undefined;\n\n    return Arrays\n      .intersect(\n        filterById ? Arrays.coerce(this._objectById.get(filter.id!)) : undefined,\n        filterByType ? Arrays.coerce(this._objectsByType.get(filter.type!)) : undefined,\n        filterByApp ? Arrays.coerce(this._objectsByApplication.get(filter.appSymbolicName!)) : undefined,\n        (filterById || filterByType || filterByApp) ? undefined : Array.from(this._objectById.values()),\n      )\n      .filter(object => {\n        if (filter.qualifier === undefined) {\n          return true;\n        }\n        if (qualifierPredicate) {\n          return qualifierPredicate(object.qualifier || {});\n        }\n\n        return new QualifierMatcher(filter.qualifier, {evalAsterisk: true, evalOptional: false}).matches(object.qualifier);\n      });\n  }\n\n  /**\n   * Emits when an object is added to or removed from this store.\n   */\n  public get change$(): Observable<void> {\n    return merge(this.add$, this.remove$).pipe(map(() => undefined as void));\n  }\n\n  /**\n   * Emits when an object is added to this store.\n   */\n  public get add$(): Observable<T> {\n    return this._add$;\n  }\n\n  /**\n   * Emits when object(s) are removed from this store.\n   */\n  public get remove$(): Observable<T[]> {\n    return this._remove$;\n  }\n\n  /**\n   * Removes the given objects from all internal maps.\n   */\n  private _remove(objects: T[]): void {\n    const deleted = new Set<T>();\n    objects.forEach(object => {\n      const objectId = object.metadata!.id;\n      if (this._objectById.delete(objectId)) {\n        Maps.removeListValue(this._objectsByType, object.type, candidate => candidate.metadata?.id === objectId);\n        Maps.removeListValue(this._objectsByApplication, object.metadata!.appSymbolicName, candidate => candidate.metadata?.id === objectId);\n        deleted.add(object);\n      }\n    });\n    deleted.size && this._remove$.next(objects);\n  }\n}\n\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Capability} from '../../platform.model';\n\n/**\n * Allows intercepting capabilities before their registration.\n *\n * Interceptors allow intercepting capabilities before they are registered, for example,\n * to perform validation checks, add metadata, or change properties.\n *\n * The following interceptor assigns a stable identifier to each microfrontend capability.\n *\n * ```ts\n * class MicrofrontendCapabilityInterceptor implements CapabilityInterceptor {\n *\n *   public async intercept(capability: Capability): Promise<Capability> {\n *     if (capability.type === 'microfrontend') {\n *       return {\n *         ...capability,\n *         metadata: {...capability.metadata, id: hash(capability)},\n *       };\n *     }\n *     return capability;\n *   }\n * }\n * ```\n *\n * #### Registering Interceptors\n * Interceptors are registered in the bean manager of the host application under the symbol `CapabilityInterceptor` as multi bean.\n * Multiple interceptors can be registered, forming a chain in which each interceptor is called one by one in registration order.\n *\n * ```ts\n * Beans.register(CapabilityInterceptor, {useClass: MicrofrontendCapabilityInterceptor, multi: true});\n * ```\n *\n * @category Capability\n */\nexport abstract class CapabilityInterceptor {\n\n  /**\n   * Intercepts a capability before being registered.\n   *\n   * @param capability - the capability to be intercepted\n   */\n  public abstract intercept(capability: Capability): Promise<Capability>;\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {Capability, Intention, ParamDefinition} from '../../platform.model';\nimport {ManifestObjectStore} from './manifest-object-store';\nimport {concatWith, defer, EMPTY, filter, merge, Observable, of, Subject} from 'rxjs';\nimport {distinctUntilChanged, expand, mergeMap, take, takeUntil} from 'rxjs/operators';\nimport {Intent, MessageHeaders, ResponseStatusCodes, TopicMessage} from '../../messaging.model';\nimport {MessageClient, takeUntilUnsubscribe} from '../../client/messaging/message-client';\nimport {ApplicationRegistry} from '../application-registry';\nimport {runSafe} from '../../safe-runner';\nimport {filterArray} from '@scion/toolkit/operators';\nimport {ManifestRegistry} from './manifest-registry';\nimport {assertExactQualifier, QualifierMatcher} from '../../qualifier-matcher';\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {stringifyError} from '../../error.util';\nimport {Logger, LoggingContext} from '../../logger';\nimport {ManifestObjectFilter} from './manifest-object.model';\nimport {ClientRegistry} from '../client-registry/client.registry';\nimport {CapabilityInterceptor} from './capability-interceptors';\nimport {UUID} from '@scion/toolkit/uuid';\n\nexport class ManifestRegistry implements ManifestRegistry, PreDestroy {\n\n  private _capabilityStore: ManifestObjectStore<Capability>;\n  private _intentionStore: ManifestObjectStore<Intention>;\n  private _destroy$ = new Subject<void>();\n\n  public capabilityRegister$: Observable<Capability>;\n  public capabilityUnregister$: Observable<Capability[]>;\n\n  constructor() {\n    this._capabilityStore = new ManifestObjectStore<Capability>();\n    this._intentionStore = new ManifestObjectStore<Intention>();\n\n    this.capabilityRegister$ = this._capabilityStore.add$;\n    this.capabilityUnregister$ = this._capabilityStore.remove$;\n\n    this.installCapabilityRegisterRequestHandler();\n    this.installCapabilityUnregisterRequestHandler();\n\n    this.installIntentionRegisterRequestHandler();\n    this.installIntentionUnregisterRequestHandler();\n\n    this.installCapabilitiesLookupRequestHandler();\n    this.installIntentionsLookupRequestHandler();\n    this.installVersionLookupHandler();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public resolveCapabilitiesByIntent(intent: Intent, appSymbolicName: string): Capability[] {\n    assertExactQualifier(intent.qualifier);\n    const filter: ManifestObjectFilter = {type: intent.type, qualifier: intent.qualifier || {}};\n    return this._capabilityStore.find(filter, capabilityQualifier => new QualifierMatcher(capabilityQualifier, {evalAsterisk: true, evalOptional: true}).matches(intent.qualifier))\n      .filter(capability => this.isApplicationQualifiedForCapability(appSymbolicName, capability));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public hasIntention(intent: Intent, appSymbolicName: string): boolean {\n    assertExactQualifier(intent.qualifier);\n    const filter: ManifestObjectFilter = {appSymbolicName, type: intent.type, qualifier: intent.qualifier || {}};\n    return (\n      Beans.get(ApplicationRegistry).isIntentionCheckDisabled(appSymbolicName) ||\n      this._intentionStore.find(filter, intentionQualifier => new QualifierMatcher(intentionQualifier, {evalAsterisk: true, evalOptional: true}).matches(intent.qualifier)).length > 0 ||\n      this._capabilityStore.find(filter, capabilityQualifier => new QualifierMatcher(capabilityQualifier, {evalAsterisk: true, evalOptional: true}).matches(intent.qualifier)).length > 0\n    );\n  }\n\n  /**\n   * Tests whether the given micro app is qualified for the given capability. This is true in two cases:\n   *   - The micro app provides the capability itself.\n   *   - The capability has public visibility and the micro app has declared an intention for it.\n   *     If 'scope check' is disabled for the given micro app, it also qualifies for capabilities with private visibility.\n   *     If 'intention check' is disabled for the given micro app, it also qualifies for capabilities for which it has not declared a respective intention.\n   */\n  private isApplicationQualifiedForCapability(appSymbolicName: string, capability: Capability): boolean {\n    if (capability.metadata!.appSymbolicName === appSymbolicName) {\n      return true;\n    }\n    const isCapabilityPublic = !capability.private;\n    const isScopeCheckDisabled = Beans.get(ApplicationRegistry).isScopeCheckDisabled(appSymbolicName);\n    const isIntentionCheckDisabled = Beans.get(ApplicationRegistry).isIntentionCheckDisabled(appSymbolicName);\n    return (isScopeCheckDisabled || isCapabilityPublic) && (isIntentionCheckDisabled || this.hasIntentionForCapability(appSymbolicName, capability));\n  }\n\n  /**\n   * Tests whether the given app has declared a matching intention for the given capability.\n   */\n  private hasIntentionForCapability(appSymbolicName: string, capability: Capability): boolean {\n    const filter: ManifestObjectFilter = {appSymbolicName, type: capability.type, qualifier: capability.qualifier};\n    return this._intentionStore.find(filter, intentionQualifier => new QualifierMatcher(intentionQualifier, {evalAsterisk: true, evalOptional: true}).matches(capability.qualifier)).length > 0;\n  }\n\n  public async registerCapability(capability: Capability, appSymbolicName: string): Promise<string> {\n    if (!capability) {\n      throw Error('[CapabilityRegisterError] Missing required capability.');\n    }\n    if (capability.qualifier && capability.qualifier.hasOwnProperty('*')) {\n      throw Error('[CapabilityRegisterError] Asterisk wildcard (\\'*\\') not allowed in the qualifier key.');\n    }\n\n    // Let the host app intercept the capability to register.\n    const capabilityToRegister = await interceptCapability({\n      ...capability,\n      qualifier: capability.qualifier ?? {},\n      params: coerceCapabilityParamDefinitions(capability, appSymbolicName),\n      requiredParams: undefined,\n      optionalParams: undefined,\n      private: capability.private ?? true,\n      metadata: {\n        id: UUID.randomUUID(),\n        appSymbolicName: appSymbolicName,\n      },\n    });\n\n    // Register the capability.\n    this._capabilityStore.add(capabilityToRegister);\n    return capabilityToRegister.metadata!.id;\n  }\n\n  private unregisterCapabilities(appSymbolicName: string, filter: ManifestObjectFilter): void {\n    this._capabilityStore.remove({...filter, appSymbolicName});\n  }\n\n  public registerIntention(intention: Intention, appSymbolicName: string): string {\n    if (!intention) {\n      throw Error(`[IntentionRegisterError] Missing required intention.`);\n    }\n\n    const intentionToRegister: Intention = {\n      ...intention,\n      metadata: {\n        id: UUID.randomUUID(),\n        appSymbolicName: appSymbolicName,\n      },\n    };\n\n    // Register the intention.\n    this._intentionStore.add(intentionToRegister);\n    return intentionToRegister.metadata!.id;\n  }\n\n  private unregisterIntention(appSymbolicName: string, filter: ManifestObjectFilter): void {\n    this._intentionStore.remove({...filter, appSymbolicName});\n  }\n\n  private installCapabilityRegisterRequestHandler(): void {\n    Beans.get(MessageClient).observe$<Capability>(ManifestRegistryTopics.RegisterCapability)\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((request: TopicMessage<Capability>) => runSafe(async () => {\n        const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n        const capability = request.body!;\n        const appSymbolicName = request.headers.get(MessageHeaders.AppSymbolicName);\n\n        try {\n          const capabilityId = await this.registerCapability(capability, appSymbolicName);\n          Beans.get(MessageClient).publish(replyTo, capabilityId, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.TERMINAL)});\n        }\n        catch (error) {\n          Beans.get(MessageClient).publish(replyTo, stringifyError(error), {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.ERROR)});\n        }\n      }));\n  }\n\n  private installCapabilityUnregisterRequestHandler(): void {\n    Beans.get(MessageClient).observe$<ManifestObjectFilter>(ManifestRegistryTopics.UnregisterCapabilities)\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((request: TopicMessage<ManifestObjectFilter>) => runSafe(() => {\n        const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n        const capabilityFilter = request.body || {};\n        const appSymbolicName = request.headers.get(MessageHeaders.AppSymbolicName);\n\n        try {\n          this.unregisterCapabilities(appSymbolicName, capabilityFilter);\n          Beans.get(MessageClient).publish(replyTo, undefined, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.TERMINAL)});\n        }\n        catch (error) {\n          Beans.get(MessageClient).publish(replyTo, stringifyError(error), {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.ERROR)});\n        }\n      }));\n  }\n\n  private installIntentionRegisterRequestHandler(): void {\n    Beans.get(MessageClient).observe$<Intention>(ManifestRegistryTopics.RegisterIntention)\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((request: TopicMessage<Intention>) => runSafe(() => {\n        const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n        const intention = request.body!;\n        const appSymbolicName = request.headers.get(MessageHeaders.AppSymbolicName);\n\n        try {\n          assertIntentionRegisterApiEnabled(appSymbolicName);\n          const intentionId = this.registerIntention(intention, appSymbolicName);\n          Beans.get(MessageClient).publish(replyTo, intentionId, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.TERMINAL)});\n        }\n        catch (error) {\n          Beans.get(MessageClient).publish(replyTo, stringifyError(error), {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.ERROR)});\n        }\n      }));\n  }\n\n  private installIntentionUnregisterRequestHandler(): void {\n    Beans.get(MessageClient).observe$<ManifestObjectFilter>(ManifestRegistryTopics.UnregisterIntentions)\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((request: TopicMessage<ManifestObjectFilter>) => runSafe(() => {\n        const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n        const intentFilter = request.body || {};\n        const appSymbolicName = request.headers.get(MessageHeaders.AppSymbolicName);\n\n        try {\n          assertIntentionRegisterApiEnabled(appSymbolicName);\n          this.unregisterIntention(appSymbolicName, intentFilter);\n          Beans.get(MessageClient).publish(replyTo, undefined, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.TERMINAL)});\n        }\n        catch (error) {\n          Beans.get(MessageClient).publish(replyTo, stringifyError(error), {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.ERROR)});\n        }\n      }));\n  }\n\n  private installCapabilitiesLookupRequestHandler(): void {\n    Beans.get(MessageClient).observe$<ManifestObjectFilter>(ManifestRegistryTopics.LookupCapabilities)\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((request: TopicMessage<ManifestObjectFilter>) => runSafe(() => {\n        const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n        const appSymbolicName = request.headers.get(MessageHeaders.AppSymbolicName);\n        const lookupFilter = request.body || {};\n\n        // The queried capabilities may change on both, capability or intention change, because the computation\n        // of visible and qualified capabilities depends on registered capabilities and manifested intentions.\n        const registryChange$ = merge(this._capabilityStore.change$, this._intentionStore.change$);\n        const finder$ = defer(() => of(this._capabilityStore.find(lookupFilter)));\n        return finder$\n          .pipe(\n            expand(() => registryChange$.pipe(take(1), mergeMap(() => finder$))),\n            filterArray(capability => this.isApplicationQualifiedForCapability(appSymbolicName, capability)),\n            distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)),\n            takeUntilUnsubscribe(replyTo),\n          )\n          .subscribe(capabilities => { // eslint-disable-line rxjs/no-nested-subscribe\n            Beans.get(MessageClient).publish<Capability[]>(replyTo, capabilities, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.OK)});\n          });\n      }));\n  }\n\n  private installIntentionsLookupRequestHandler(): void {\n    Beans.get(MessageClient).observe$<ManifestObjectFilter>(ManifestRegistryTopics.LookupIntentions)\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((request: TopicMessage<ManifestObjectFilter>) => runSafe(() => {\n        const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n        const lookupFilter = request.body || {};\n\n        const finder$ = defer(() => of(this._intentionStore.find(lookupFilter)));\n        return finder$\n          .pipe(\n            expand(() => this._intentionStore.change$.pipe(take(1), mergeMap(() => finder$))),\n            distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)),\n            takeUntilUnsubscribe(replyTo),\n          )\n          .subscribe(intentions => { // eslint-disable-line rxjs/no-nested-subscribe\n            Beans.get(MessageClient).publish<Intention[]>(replyTo, intentions, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.OK)});\n          });\n      }));\n  }\n\n  private installVersionLookupHandler(): void {\n    Beans.get(MessageClient).onMessage<void, string>(ManifestRegistryTopics.platformVersion(':appSymbolicName'), message => {\n      const appSymbolicName = message.params!.get('appSymbolicName')!;\n      const clientRegister$ = Beans.get(ClientRegistry).register$.pipe(filter(client => client.application.symbolicName === appSymbolicName));\n      const platformVersion$ = defer(() => {\n        const clients = Beans.get(ClientRegistry).getByApplication(appSymbolicName);\n        return clients.length ? of(clients[0].version) : EMPTY;\n      });\n      return platformVersion$\n        .pipe(\n          concatWith(clientRegister$.pipe(mergeMap(() => platformVersion$))),\n          take(1),\n        );\n    });\n  }\n\n  public preDestroy(): void {\n    this._destroy$.next();\n  }\n}\n\n/**\n * Defines the topics to interact with the manifest registry from {@link ManifestService}.\n */\nexport namespace ManifestRegistryTopics {\n  export const LookupCapabilities = 'LOOKUP_CAPABILITIES';\n  export const LookupIntentions = 'LOOKUP_INTENTIONS';\n  export const RegisterCapability = 'REGISTER_CAPABILITY';\n  export const UnregisterCapabilities = 'UNREGISTER_CAPABILITIES';\n  export const RegisterIntention = 'REGISTER_INTENTION';\n  export const UnregisterIntentions = 'UNREGISTER_INTENTIONS';\n\n  export function platformVersion(appSymbolicName: string): string {\n    return `application/${appSymbolicName}/platform/version`;\n  }\n}\n\n/**\n * Checks if the 'Intention Registration API' is enabled for the given app. If not, an error is thrown.\n */\nfunction assertIntentionRegisterApiEnabled(appSymbolicName: string): void {\n  if (Beans.get(ApplicationRegistry).isIntentionRegisterApiDisabled(appSymbolicName)) {\n    throw Error(`[IntentionRegisterError] The 'Intention Registration API' is disabled for the application '${appSymbolicName}'. Contact the platform administrator to enable this API.`);\n  }\n}\n\nfunction coerceCapabilityParamDefinitions(capability: Capability, appSymbolicName: string): ParamDefinition[] {\n  const params: ParamDefinition[] = [];\n\n  capability.requiredParams?.forEach(name => { // eslint-disable-line deprecation/deprecation\n    params.push({name, required: true});\n    const migration = `{ params: [{name: '${name}', required: true}] }`;\n    Beans.get(Logger).warn(`[DEPRECATION][AC3A912] The '${appSymbolicName}' application uses a deprecated API for declaring required parameters of a capability. The API will be removed in a future release. To migrate, declare parameters by using the 'Capability#params' property, as follows: ${migration}`, new LoggingContext(appSymbolicName), capability);\n  });\n  capability.optionalParams?.forEach(name => { // eslint-disable-line deprecation/deprecation\n    params.push({name, required: false});\n    const migration = `{ params: [{name: '${name}', required: false}] }`;\n    Beans.get(Logger).warn(`[DEPRECATION][97C70E9] The '${appSymbolicName}' application uses a deprecated API for declaring optional parameters of a capability. The API will be removed in a future release. To migrate, declare parameters by using the 'Capability#params' property, as follows: ${migration}`, new LoggingContext(appSymbolicName), capability);\n  });\n  capability.params?.forEach(param => {\n    params.push(param);\n  });\n\n  assertCapabilityParamDefinitions(params);\n  return params;\n}\n\n/**\n * Asserts given parameter definitions to be valid.\n */\nfunction assertCapabilityParamDefinitions(params: ParamDefinition[]): void {\n  const validSubstitutes = params.filter(param => !param.deprecated).map(param => param.name);\n\n  params.forEach(param => {\n    if (param.required === undefined) {\n      throw Error(`[CapabilityParamError] Parameter '${param.name}' must be explicitly defined as required or optional.`);\n    }\n\n    if (param.deprecated !== undefined) {\n      // Ensure deprecated param to be optional\n      if (param.required) {\n        throw Error(`[CapabilityParamError] Deprecated parameters must be optional, not required. Alternatively, deprecated parameters can define a mapping to a required parameter via the 'useInstead' property. [param='${param.name}']`);\n      }\n\n      // Ensure existing substitute\n      if (typeof param.deprecated === 'object' && param.deprecated.useInstead && !validSubstitutes.includes(param.deprecated.useInstead)) {\n        throw Error(`[CapabilityParamError] The deprecated parameter '${param.name}' defines an invalid substitute '${param.deprecated.useInstead}'. Valid substitutes are: [${validSubstitutes}]`);\n      }\n    }\n    return param;\n  });\n}\n\n/**\n * Intercepts capability before its registration.\n */\nasync function interceptCapability(capability: Capability): Promise<Capability> {\n  const interceptors = Beans.all(CapabilityInterceptor);\n  for (const interceptor of interceptors) {\n    capability = await interceptor.intercept(capability);\n  }\n  return capability;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {firstValueFrom, lastValueFrom, Observable, OperatorFunction} from 'rxjs';\nimport {MessageClient} from '../messaging/message-client';\nimport {Application, Capability, Intention} from '../../platform.model';\nimport {take} from 'rxjs/operators';\nimport {PlatformTopics} from '../../messaging.model';\nimport {ManifestRegistryTopics} from '../../host/manifest-registry/manifest-registry';\nimport {mapToBody} from '../../messaging.model';\nimport {Beans, Initializer} from '@scion/toolkit/bean-manager';\nimport {BrokerGateway, NullBrokerGateway} from '../messaging/broker-gateway';\nimport {ManifestObjectFilter} from '../../host/manifest-registry/manifest-object.model';\nimport {mapArray} from '@scion/toolkit/operators';\nimport {Application} from '../../host/application-registry';\n\n/**\n * Allows browsing the catalog of capabilities and managing the capabilities of the application.\n *\n * The app can browse only capabilities which are visible to it, i.e., for which the app has declared an intention and\n * which are also publicly available. Capabilities that the app provides itself are always visible to the app.\n *\n * The app can also provide new capabilities or remove existing ones. If the *Intention Registration API* is enabled\n * for the app, the app can also manage its intentions, which, however, is strongly discouraged. Instead, apps should\n * declare the required functionality in their manifests using wildcard intentions.\n *\n * @category Manifest\n * @category Intention API\n */\nexport class ManifestService implements Initializer {\n\n  private _applications: Application[] = [];\n\n  public async init(): Promise<void> {\n    const messagingDisabled = Beans.get(BrokerGateway) instanceof NullBrokerGateway;\n    if (messagingDisabled) {\n      return;\n    }\n\n    // Wait until obtained registered applications so that they can be accessed synchronously by the application via `ManifestService#applications`.\n    const applications$ = Beans.get(MessageClient).observe$<Application[]>(PlatformTopics.Applications);\n    this._applications = await firstValueFrom(applications$.pipe(mapToBody(), mapToApplication()));\n  }\n\n  /**\n   * Applications installed in the platform.\n   */\n  public get applications(): ReadonlyArray<Application> {\n    return this._applications;\n  }\n\n  /**\n   * Allows to lookup the applications installed in the platform.\n   *\n   * @return an Observable that emits the applications in the platform and then completes.\n   * @deprecated since version 1.0.0-beta.8. Use {@link applications} instead.\n   */\n  public lookupApplications$(): Observable<Application[]> {\n    return Beans.get(MessageClient).observe$<Application[]>(PlatformTopics.Applications)\n      .pipe(\n        take(1),\n        mapToBody(),\n        mapToApplication(),\n      );\n  }\n\n  /**\n   * Allows browsing the catalog of capabilities that match the given filter.\n   *\n   * <strong>\n   * You can only browse capabilities that are visible to your application, that is, capabilities that you provide yourself or that are\n   * publicly available and for which you have declared an intention in your manifest.\n   * </strong>\n   *\n   * @param  filter - Control which capabilities to browse. If no or an empty filter is given, all capabilities visible to the requesting\n   *         app are returned. Specified filter criteria are \"AND\"ed together.\\\n   *         <p>\n   *         If specifying a qualifier filter, the capabilities must match that filter exactly. The filter supports the asterisk wildcard\n   *         to match any value, e.g., `{property: '*'}`, or partial matching to find capabilities with at least the specified qualifier\n   *         properties. Partial matching is enabled by appending the _any-more_ entry to the qualifier, as following: `{'*': '*'}`.\n   * @return An Observable that, when subscribed, emits the requested capabilities.\n   *         It never completes and emits continuously when fulfilling capabilities are registered or unregistered.\n   */\n  public lookupCapabilities$<T extends Capability>(filter?: ManifestObjectFilter): Observable<T[]> {\n    return Beans.get(MessageClient).request$<T[]>(ManifestRegistryTopics.LookupCapabilities, filter)\n      .pipe(mapToBody());\n  }\n\n  /**\n   * Allows browsing the catalog of intentions that match the given filter.\n   *\n   * @param  filter - Control which intentions to return. If no or an empty filter is given, no filtering takes place. Specified filter\n   *         criteria are \"AND\"ed together.\\\n   *         <p>\n   *         If specifying a qualifier filter, the intentions must match that filter exactly. The filter supports the asterisk wildcard\n   *         to match any value, e.g., `{property: '*'}`, or partial matching to find intentions with at least the specified qualifier\n   *         properties. Partial matching is enabled by appending the _any-more_ entry to the qualifier, as following: `{'*': '*'}`.\n   * @return An Observable that, when subscribed, emits the requested intentions.\n   *         It never completes and emits continuously when matching intentions are registered or unregistered.\n   */\n  public lookupIntentions$(filter?: ManifestObjectFilter): Observable<Intention[]> {\n    return Beans.get(MessageClient).request$<Intention[]>(ManifestRegistryTopics.LookupIntentions, filter)\n      .pipe(mapToBody());\n  }\n\n  /**\n   * Registers given capability. If the capability has public visibility, other applications can browse the capability and interact with it.\n   *\n   * @return A Promise that resolves to the identity of the registered capability,\n   *         or that rejects if the registration failed.\n   */\n  public registerCapability<T extends Capability>(capability: T): Promise<string> {\n    const register$ = Beans.get(MessageClient).request$<string>(ManifestRegistryTopics.RegisterCapability, capability);\n    return lastValueFrom(register$.pipe(mapToBody()));\n  }\n\n  /**\n   * Unregisters capabilities matching the given filter.\n   *\n   * <strong>You can only unregister capabilities of your application.</strong>\n   *\n   * @param  filter - Control which capabilities to unregister by specifying filter criteria which are \"AND\"ed together. If not passing a filter,\n   *         all capabilities of the requesting app are unregistered.\\\n   *         <p>\n   *         If specifying a qualifier filter, the capabilities to unregister must match that filter exactly. The filter supports the asterisk\n   *         wildcard to match any value, e.g., `{property: '*'}`, or partial matching to unregister capabilities with at least the specified\n   *         qualifier properties. Partial matching is enabled by appending the _any-more_ entry to the qualifier, as following: `{'*': '*'}`.\n   *         Note that specifying a symbolic app name in the filter has no effect.\n   * @return A Promise that resolves when unregistered the capability,\n   *         or that rejects if the unregistration failed.\n   */\n  public unregisterCapabilities(filter?: ManifestObjectFilter): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      Beans.get(MessageClient).request$<void>(ManifestRegistryTopics.UnregisterCapabilities, filter).subscribe({\n        error: reject,\n        complete: resolve,\n      });\n    });\n  }\n\n  /**\n   * Registers the given intention, allowing the application to interact with public capabilities matching the intention.\n   *\n   * The intention can match multiple capabilities by using wildcards (such as `*` or `?`) in the qualifier.\n   *\n   * <strong>This operation requires that the 'Intention Registration API' is enabled for your application.</strong>\n   *\n   * @return A Promise that resolves to the identity of the registered intention,\n   *         or that rejects if the registration failed.\n   */\n  public registerIntention(intention: Intention): Promise<string> {\n    const register$ = Beans.get(MessageClient).request$<string>(ManifestRegistryTopics.RegisterIntention, intention);\n    return lastValueFrom(register$.pipe(mapToBody()));\n  }\n\n  /**\n   * Unregisters intentions matching the given filter.\n   *\n   * <strong>You can only unregister intentions of your application.</strong>\n   * <strong>This operation requires that the 'Intention Registration API' is enabled for your application.</strong>\n   *\n   * @param  filter - Control which intentions to unregister by specifying filter criteria which are \"AND\"ed together. If not passing a filter,\n   *         all intentions of the requesting app are unregistered.\\\n   *         <p>\n   *         If specifying a qualifier filter, the intentions to unregister must match that filter exactly. The filter supports the asterisk\n   *         wildcard to match any value, e.g., `{property: '*'}`, or partial matching to unregister intentions with at least the specified\n   *         qualifier properties. Partial matching is enabled by appending the _any-more_ entry to the qualifier, as following: `{'*': '*'}`.\n   *         Note that specifying a symbolic app name in the filter has no effect.\n   * @return A Promise that resolves when unregistered the intention,\n   *         or that rejects if the unregistration failed.\n   */\n  public unregisterIntentions(filter?: ManifestObjectFilter): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      Beans.get(MessageClient).request$<void>(ManifestRegistryTopics.UnregisterIntentions, filter).subscribe({\n        error: reject,\n        complete: resolve,\n      });\n    });\n  }\n}\n\nfunction mapToApplication(): OperatorFunction<Application[], Application[]> {\n  return mapArray(application => {\n    return {\n      ...application,\n      platformVersion: firstValueFrom(Beans.get(MessageClient).request$<string>(ManifestRegistryTopics.platformVersion(application.symbolicName)).pipe(mapToBody())),\n    };\n  });\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {ACTIVATION_CONTEXT, ActivationContext, ActivatorCapability, PlatformCapabilityTypes} from '../../platform.model';\nimport {first} from 'rxjs/operators';\nimport {ApplicationRegistry} from '../application-registry';\nimport {OutletRouter} from '../../client/router-outlet/outlet-router';\nimport {SciRouterOutletElement} from '../../client/router-outlet/router-outlet.element';\nimport {Arrays, Maps} from '@scion/toolkit/util';\nimport {UUID} from '@scion/toolkit/uuid';\nimport {Logger} from '../../logger';\nimport {MessageHeaders} from '../../messaging.model';\nimport {EMPTY, firstValueFrom, identity, Observable, timeout} from 'rxjs';\nimport {PlatformState} from '../../platform-state';\nimport {Beans, Initializer} from '@scion/toolkit/bean-manager';\nimport {MicrofrontendPlatformRef} from '../../microfrontend-platform-ref';\nimport {ProgressMonitor} from '../progress-monitor/progress-monitor';\nimport {ActivatorLoadProgressMonitor} from '../progress-monitor/progress-monitors';\nimport {ManifestService} from '../../client/manifest-registry/manifest-service';\nimport {MessageClient} from '../../client/messaging/message-client';\n\n/**\n * Activates micro applications which provide an activator capability.\n *\n * Activators enable micro applications to interact with the platform for the entire platform lifecycle.\n * Activators can signal when ready for operation, causing this initializer to wait until received respective readiness messages.\n *\n * @ignore\n */\nexport class ActivatorInstaller implements Initializer {\n\n  public async init(): Promise<void> {\n    // Lookup activators.\n    const activators: ActivatorCapability[] = await firstValueFrom(Beans.get(ManifestService).lookupCapabilities$<ActivatorCapability>({type: PlatformCapabilityTypes.Activator}));\n\n    const monitor = Beans.get(ActivatorLoadProgressMonitor);\n    if (!activators.length) {\n      monitor.done();\n      return;\n    }\n\n    // Group activators by their providing application.\n    const activatorsGroupedByApp: Map<string, ActivatorCapability[]> = activators\n      .filter(this.skipInvalidActivators())\n      .reduce((grouped, activator) => Maps.addListValue(grouped, activator.metadata!.appSymbolicName, activator), new Map<string, ActivatorCapability[]>());\n\n    // Create Promises that wait for activators to signal ready.\n    const subMonitors = monitor.splitEven(activatorsGroupedByApp.size);\n    const activatorReadyPromises: Promise<void>[] = Array\n      .from(activatorsGroupedByApp.entries())\n      .reduce((acc, [appSymbolicName, appActivators], index) => {\n        return acc.concat(this.waitForActivatorsToSignalReady(appSymbolicName, appActivators, subMonitors[index]));\n      }, [] as Promise<void>[]);\n\n    // Mount activators in hidden iframes\n    activatorsGroupedByApp.forEach((sameAppActivators: ActivatorCapability[]) => {\n      // Nominate one activator of each app as primary activator.\n      const primaryActivator = sameAppActivators[0];\n      sameAppActivators.forEach(activator => this.mountActivator(activator, activator === primaryActivator));\n    });\n\n    // Wait until activators signal ready.\n    await Promise.all(activatorReadyPromises);\n  }\n\n  private skipInvalidActivators(): (activator: ActivatorCapability) => boolean {\n    return (activator: ActivatorCapability): boolean => {\n      if (!activator.properties || !activator.properties.path) {\n        Beans.get(Logger).error(`[ActivatorError] Failed to activate the application '${activator.metadata!.appSymbolicName}'. Missing required 'path' property in the provided activator capability.`, activator);\n        return false;\n      }\n      return true;\n    };\n  }\n\n  /**\n   * Creates a Promise that resolves when given activators signal ready.\n   */\n  private async waitForActivatorsToSignalReady(appSymbolicName: string, activators: ActivatorCapability[], monitor: ProgressMonitor): Promise<void> {\n    const t0 = Date.now();\n    const activatorLoadTimeout = Beans.get(ApplicationRegistry).getApplication(appSymbolicName)!.activatorLoadTimeout;\n    const readinessPromises: Promise<void>[] = activators\n      .reduce((acc, activator) => acc.concat(Arrays.coerce(activator.properties.readinessTopics)), new Array<string>()) // concat readiness topics\n      .map(readinessTopic => {\n          const onReadinessTimeout = (): Observable<never> => {\n            Beans.get(Logger).error(`[ActivatorLoadTimeoutError] Timeout elapsed while waiting for application to signal readiness [app=${appSymbolicName}, timeout=${activatorLoadTimeout}ms, readinessTopic=${readinessTopic}].`);\n            return EMPTY;\n          };\n          return new Promise((resolve, reject) => {\n            return Beans.get(MessageClient).observe$<void>(readinessTopic)\n              .pipe(\n                first(msg => msg.headers.get(MessageHeaders.AppSymbolicName) === appSymbolicName),\n                activatorLoadTimeout ? timeout({first: activatorLoadTimeout, with: onReadinessTimeout}) : identity,\n              )\n              .subscribe({\n                error: reject,\n                complete: resolve,\n              });\n          });\n        },\n      );\n\n    if (!readinessPromises.length) {\n      monitor.done();\n      return;\n    }\n\n    await Promise.all(readinessPromises);\n    monitor.done();\n    Beans.get(Logger).info(`Activator startup of '${appSymbolicName}' took ${Date.now() - t0}ms.`);\n  }\n\n  /**\n   * Mounts a hidden <sci-router-outlet> and loads the activator endpoint.\n   */\n  private mountActivator(activator: ActivatorCapability, primary: boolean): void {\n    const application = Beans.get(ApplicationRegistry).getApplication(activator.metadata!.appSymbolicName)!;\n\n    // Create the router outlet and navigate to the activator endpoint.\n    const routerOutlet = document.createElement('sci-router-outlet') as SciRouterOutletElement;\n    routerOutlet.name = UUID.randomUUID();\n    Beans.get(OutletRouter).navigate(activator.properties.path, {\n      outlet: routerOutlet.name,\n      relativeTo: application.baseUrl,\n    }).then();\n\n    // Provide the activation context\n    routerOutlet.setContextValue<ActivationContext>(ACTIVATION_CONTEXT, {primary, activator});\n    // Add CSS classes for debugging purposes\n    routerOutlet.classList.add('sci-activator', application.symbolicName);\n    // Make the router outlet invisible\n    routerOutlet.style.display = 'none';\n    // Take the router outlet out of the document flow\n    routerOutlet.style.position = 'absolute';\n    // Add the router outlet to the DOM\n    document.body.appendChild(routerOutlet);\n    // Unmount the router outlet on platform shutdown\n    Beans.get(MicrofrontendPlatformRef).whenState(PlatformState.Stopped).then(() => document.body.removeChild(routerOutlet));\n  }\n}\n","import {MessageClient, takeUntilUnsubscribe} from './message-client';\nimport {Message, MessageHeaders, ResponseStatusCodes} from '../../messaging.model';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {EMPTY, from, Observable, of, Subscription, throwError} from 'rxjs';\nimport {runSafe} from '../../safe-runner';\nimport {stringifyError} from '../../error.util';\nimport {filter, finalize, takeUntil} from 'rxjs/operators';\nimport {MicrofrontendPlatformRef} from '../../microfrontend-platform-ref';\nimport {PlatformState} from '../../platform-state';\n\n/**\n * Subscribes to messages, passing each message to the callback.\n *\n * The callback can return a response to be transported to the requestor, if any. When the final response is produced,\n * the handler terminates the communication, completing the requestor's Observable. If the callback errors, the error is\n * transported to the requestor, erroring the requestor's Observable.\n *\n * @ignore\n */\nexport class MessageHandler<MSG extends Message, REPLY> {\n\n  private _messageClient = Beans.get(MessageClient);\n\n  /**\n   * Represents this handler's subscription for receiving messages. Calling {@link Subscription.unsubscribe} will also complete\n   * the Observable of all requestors, if any.\n   */\n  public readonly subscription = new Subscription();\n\n  constructor(message$: Observable<MSG>, private _callback: (message: MSG) => Observable<REPLY> | Promise<REPLY> | REPLY | void) {\n    this.subscription.add(message$.subscribe(message => {\n      if (message.headers.has(MessageHeaders.ReplyTo)) {\n        this.handleMessage(message);\n      }\n      else {\n        this.consumeMessage(message);\n      }\n    }));\n  }\n\n  /**\n   * The requestor has initiated a fire-and-forget communication, thus we simply pass the message to the callback and ignore response(s).\n   */\n  private consumeMessage(message: MSG): void {\n    runSafe(() => this._callback(message));\n  }\n\n  /**\n   * The requestor has initiated a request-response communication, thus we pass the request to the callback and send response(s)\n   * or a potential completion or error to the requestor.\n   */\n  private handleMessage(request: MSG): void {\n    const replyTo = request.headers.get(MessageHeaders.ReplyTo);\n    const platformStopping$ = Beans.get(MicrofrontendPlatformRef).state$.pipe(filter(state => state === PlatformState.Stopping));\n\n    // Invoke the callback to produce value(s).\n    let reply: Observable<REPLY> | Promise<REPLY> | REPLY | void;\n    try {\n      reply = this._callback(request);\n    }\n    catch (error) {\n      reply = throwError(() => error);\n    }\n\n    // Send response(s) or a potential completion or error back to the requestor.\n    let observableStatus: 'alive' | 'completed' | 'errored' = 'alive';\n    this.subscription.add(fromCallbackResult$(reply)\n      .pipe(\n        takeUntilUnsubscribe(replyTo), // unsubscribe once the requestor terminates the communication\n        takeUntil(platformStopping$), // terminate the communication when the platform is shutting down.\n        finalize(() => {\n          // Note that the `finalize` operator is also called when unsubscribing from the observable, e.g. when unsubscribing\n          // from the handler. If the observable errors or completes, the `finalize` operator is guaranteed to be called after\n          // the observer's `complete` or `error` methods; thus, the variable `observableStatus` is only `alive` when\n          // unsubscribing from the observable.\n          if (observableStatus === 'alive') {\n            // Terminate the communication when the handler is being unsubscribed.\n            const replyHeaders = new Map().set(MessageHeaders.Status, ResponseStatusCodes.TERMINAL);\n            this._messageClient.publish(replyTo, undefined, {headers: replyHeaders}).then();\n          }\n        }),\n      )\n      .subscribe({\n        next: next => {\n          // Transport the value to the requestor.\n          const replyHeaders = new Map().set(MessageHeaders.Status, ResponseStatusCodes.OK);\n          this._messageClient.publish(replyTo, next, {headers: replyHeaders}).then();\n        },\n        error: error => {\n          observableStatus = 'errored';\n          // Transport the error to the requestor.\n          const replyHeaders = new Map().set(MessageHeaders.Status, ResponseStatusCodes.ERROR);\n          this._messageClient.publish(replyTo, stringifyError(error), {headers: replyHeaders}).then();\n        },\n        complete: () => {\n          observableStatus = 'completed';\n          // Terminate the communication when finished producing responses.\n          const replyHeaders = new Map().set(MessageHeaders.Status, ResponseStatusCodes.TERMINAL);\n          this._messageClient.publish(replyTo, undefined, {headers: replyHeaders}).then();\n        },\n      }));\n  }\n}\n\n/**\n * Creates an Observable from the result of the callback.\n *\n * If the callback returns no value (`void`), returns `undefined`, or returns a Promise that resolves to `undefined`,\n * the returned observable will complete immediately.\n */\nfunction fromCallbackResult$<T>(value: T | Observable<T> | Promise<T>): Observable<T> {\n  if (value === undefined) {\n    return EMPTY;\n  }\n  if (value instanceof Observable) {\n    return value;\n  }\n  if (value instanceof Promise) {\n    return from(value).pipe(filter(resolved => resolved !== undefined));\n  }\n  return of(value);\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {defer, Observable, Subscription} from 'rxjs';\nimport {Intent, IntentMessage, throwOnErrorStatus, TopicMessage} from '../../messaging.model';\nimport {BrokerGateway} from './broker-gateway';\nimport {IntentSubscribeCommand, MessagingChannel} from '../../messaging.model';\nimport {assertExactQualifier} from '../../qualifier-matcher';\nimport {IntentClient, IntentSelector} from './intent-client';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {MessageHandler} from './message-handler';\nimport {PublishOptions, RequestOptions} from './publish-options';\n\nexport class IntentClient implements IntentClient {\n\n  private readonly _brokerGateway = Beans.get(BrokerGateway);\n\n  public publish<T = any>(intent: Intent, body?: T, options?: PublishOptions): Promise<void> {\n    assertExactQualifier(intent.qualifier);\n    const intentMessage: IntentMessage = {\n      intent,\n      retain: options?.retain ?? false,\n      headers: new Map(options?.headers),\n      capability: undefined!, /* set by the broker when dispatching the intent */\n    };\n    setBodyIfDefined(intentMessage, body);\n    return this._brokerGateway.postMessage(MessagingChannel.Intent, intentMessage);\n  }\n\n  public request$<T>(intent: Intent, body?: any, options?: RequestOptions): Observable<TopicMessage<T>> {\n    assertExactQualifier(intent.qualifier);\n    // IMPORTANT:\n    // When sending a request, the platform adds various headers to the message. Therefore, to support multiple subscriptions\n    // to the returned Observable, each subscription must have its individual message instance and headers map.\n    // In addition, the headers are copied to prevent modifications before the effective subscription.\n    const headers = new Map(options?.headers);\n    return defer(() => {\n      const intentMessage: IntentMessage = {\n        intent,\n        retain: options?.retain ?? false,\n        headers: new Map(headers) /* make a copy for each subscription to support multiple subscriptions */,\n        capability: undefined!, /* set by the broker when dispatching the intent */\n      };\n      setBodyIfDefined(intentMessage, body);\n      return this._brokerGateway.requestReply$(MessagingChannel.Intent, intentMessage).pipe(throwOnErrorStatus());\n    });\n  }\n\n  public observe$<T>(selector?: IntentSelector): Observable<IntentMessage<T>> {\n    return this._brokerGateway.subscribe$({\n      messageChannel: MessagingChannel.Intent,\n      subscribeChannel: MessagingChannel.IntentSubscribe,\n      unsubscribeChannel: MessagingChannel.IntentUnsubscribe,\n      newSubscribeCommand: (subscriberId: string): IntentSubscribeCommand => ({selector, subscriberId, headers: new Map()}),\n    });\n  }\n\n  public onIntent<IN = any, OUT = any>(selector: IntentSelector, callback: (intentMessage: IntentMessage<IN>) => Observable<OUT> | Promise<OUT> | OUT | void): Subscription {\n    return new MessageHandler(Beans.get(IntentClient).observe$<IN>(selector), callback).subscription;\n  }\n}\n\nfunction setBodyIfDefined<T>(message: TopicMessage<T> | IntentMessage<T>, body?: T): void {\n  if (body !== undefined) {\n    message.body = body;\n  }\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {defer, noop, Observable, Subject, Subscription} from 'rxjs';\nimport {IntentMessage, mapToBody, throwOnErrorStatus, TopicMessage} from '../../messaging.model';\nimport {BrokerGateway} from './broker-gateway';\nimport {MessagingChannel, PlatformTopics, TopicSubscribeCommand} from '../../messaging.model';\nimport {Topics} from '../../topics.util';\nimport {MessageClient} from './message-client';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {MessageHandler} from './message-handler';\nimport {takeUntil} from 'rxjs/operators';\nimport {PublishOptions, RequestOptions} from './publish-options';\n\nexport class MessageClient implements MessageClient {\n\n  private readonly _brokerGateway = Beans.get(BrokerGateway);\n\n  public publish<T = any>(topic: string, message?: T, options?: PublishOptions): Promise<void> {\n    assertTopic(topic, {allowWildcardSegments: false});\n    const topicMessage: TopicMessage = {\n      topic,\n      retain: options?.retain ?? false,\n      headers: new Map(options?.headers),\n    };\n    setBodyIfDefined(topicMessage, message);\n    return this._brokerGateway.postMessage(MessagingChannel.Topic, topicMessage);\n  }\n\n  public request$<T>(topic: string, request?: any, options?: RequestOptions): Observable<TopicMessage<T>> {\n    assertTopic(topic, {allowWildcardSegments: false});\n    // IMPORTANT:\n    // When sending a request, the platform adds various headers to the message. Therefore, to support multiple subscriptions\n    // to the returned Observable, each subscription must have its individual message instance and headers map.\n    // In addition, the headers are copied to prevent modifications before the effective subscription.\n    const headers = new Map(options?.headers);\n    return defer(() => {\n      const topicMessage: TopicMessage = {\n        topic,\n        retain: options?.retain ?? false,\n        headers: new Map(headers), /* make a copy for each subscription to support multiple subscriptions */\n      };\n      setBodyIfDefined(topicMessage, request);\n      return this._brokerGateway.requestReply$(MessagingChannel.Topic, topicMessage).pipe(throwOnErrorStatus());\n    });\n  }\n\n  public observe$<T>(topic: string): Observable<TopicMessage<T>> {\n    assertTopic(topic, {allowWildcardSegments: true});\n    return this._brokerGateway.subscribe$({\n      messageChannel: MessagingChannel.Topic,\n      subscribeChannel: MessagingChannel.TopicSubscribe,\n      unsubscribeChannel: MessagingChannel.TopicUnsubscribe,\n      newSubscribeCommand: (subscriberId: string): TopicSubscribeCommand => ({topic, subscriberId, headers: new Map()}),\n    });\n  }\n\n  public onMessage<IN = any, OUT = any>(topic: string, callback: (message: TopicMessage<IN>) => Observable<OUT> | Promise<OUT> | OUT | void): Subscription {\n    return new MessageHandler(Beans.get(MessageClient).observe$<IN>(topic), callback).subscription;\n  }\n\n  public subscriberCount$(topic: string): Observable<number> {\n    assertTopic(topic, {allowWildcardSegments: false});\n    return new Observable<number>(observer => {\n      const unsubscribe$ = new Subject<void>();\n      this.request$<number>(PlatformTopics.RequestSubscriberCount, topic)\n        .pipe(\n          mapToBody(),\n          takeUntil(unsubscribe$),\n        )\n        .subscribe({\n          next: reply => observer.next(reply),\n          error: error => observer.error(error),\n          complete: noop, // As per the API, the Observable never completes, even if receiving a TERMINAL signal.\n        });\n      return (): void => unsubscribe$.next();\n    });\n  }\n}\n\nfunction assertTopic(topic: string, options: {allowWildcardSegments: boolean}): void {\n  if (topic === undefined || topic === null || topic.length === 0) {\n    throw Error('[IllegalTopicError] Topic must not be `null`, `undefined` or empty');\n  }\n\n  if (!options.allowWildcardSegments && Topics.containsWildcardSegments(topic)) {\n    throw Error(`[IllegalTopicError] Topic not allowed to contain wildcard segments. [topic='${topic}']`);\n  }\n}\n\nfunction setBodyIfDefined<T>(message: TopicMessage<T> | IntentMessage<T>, body?: T): void {\n  if (body !== undefined) {\n    message.body = body;\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {APP_IDENTITY, Manifest} from '../platform.model';\nimport {PlatformState} from '../platform-state';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {MicrofrontendPlatformRef} from '../microfrontend-platform-ref';\nimport {ApplicationConfig} from './application-config';\nimport {HostConfig} from './host-config';\n\n/**\n * Creates the {@link ApplicationConfig} for the host app.\n */\nexport function createHostApplicationConfig(hostConfig: HostConfig | undefined): ApplicationConfig {\n  return {\n    symbolicName: Beans.get(APP_IDENTITY),\n    manifestUrl: provideHostManifestUrl(hostConfig?.manifest),\n    scopeCheckDisabled: hostConfig?.scopeCheckDisabled,\n    intentionCheckDisabled: hostConfig?.intentionCheckDisabled,\n    intentionRegisterApiDisabled: hostConfig?.intentionRegisterApiDisabled,\n  };\n}\n\nfunction provideHostManifestUrl(hostManifest: string | Manifest | undefined): string {\n  if (typeof hostManifest === 'string') {\n    return hostManifest; // URL specified\n  }\n\n  return serveHostManifest(hostManifest || {name: 'Host Application'});\n}\n\nfunction serveHostManifest(manifest: Manifest): string {\n  const url = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type: 'application/json'}));\n  Beans.get(MicrofrontendPlatformRef).whenState(PlatformState.Stopped).then(() => URL.revokeObjectURL(url));\n  return url;\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {MicrofrontendPlatformRef} from './microfrontend-platform-ref';\n\n/**\n * Stops the platform and disconnect this client from the host when the document is being unloaded.\n *\n * For this purpose, this class binds to the browser's `unload` event. It does not bind to the `beforeunload`\n * event since the browser fires that event only when navigating to another page, but not when removing the iframe.\n */\nexport abstract class MicrofrontendPlatformStopper {\n}\n\n/**\n * @internal\n */\nexport class MicrofrontendPlatformStopper implements MicrofrontendPlatformStopper, PreDestroy {\n\n  private onUnload = (): void => Beans.get(MicrofrontendPlatformRef).destroy();\n\n  constructor() { // eslint-disable-line @typescript-eslint/member-ordering\n    window.addEventListener('unload', this.onUnload, {once: true});\n  }\n\n  public preDestroy(): void {\n    window.removeEventListener('unload', this.onUnload);\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Beans, PreDestroy} from '@scion/toolkit/bean-manager';\nimport {Subject} from 'rxjs';\nimport {Client} from './client';\nimport {Logger, LoggingContext} from '../../logger';\nimport {ClientRegistry} from './client.registry';\n\nexport class ClientRegistry implements ClientRegistry, PreDestroy {\n\n  private readonly _clientsById = new Map<string, Client>();\n  private readonly _clientsByWindow = new Map<Window, Client>();\n  public readonly register$ = new Subject<Client>();\n  public readonly unregister$ = new Subject<Client>();\n\n  public registerClient(client: Client): void {\n    const staleClient = this._clientsByWindow.get(client.window);\n    if (staleClient) {\n      Beans.get(Logger).warn(\n        `[StaleClient] Stale client registration detected when loading application '${client.application.symbolicName}'\n        into the window of '${staleClient.application.symbolicName}'. Removing stale registration. Most likely, the client could not disconnect\n        from the broker, for example, because the client was disposed without notice, i.e., without receiving the browser's \"unload\" event, or\n        because the browser discarded the 'DISCONNECT' message, maybe due to a high load on the client during unloading.`.replace(/\\s+/g, ' '),\n        new LoggingContext(staleClient.application.symbolicName, staleClient.version),\n      );\n      this.unregisterClient(staleClient);\n    }\n    this._clientsById.set(client.id, client);\n    this._clientsByWindow.set(client.window, client);\n    this.register$.next(client);\n  }\n\n  public unregisterClient(client: Client): void {\n    this._clientsById.delete(client.id);\n    this._clientsByWindow.delete(client.window);\n    this.unregister$.next(client);\n    client.dispose();\n  }\n\n  public getByClientId(clientId: string): Client | undefined {\n    return this._clientsById.get(clientId);\n  }\n\n  public getByWindow(window: Window): Client | undefined {\n    return this._clientsByWindow.get(window);\n  }\n\n  public getByApplication(appSymbolicName: string): Client[] {\n    return Array.from(this._clientsById.values()).filter(client => client.application.symbolicName === appSymbolicName);\n  }\n\n  public preDestroy(): void {\n    this._clientsById.forEach(client => this.unregisterClient(client));\n  }\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {IntentMessage, MessageHeaders, ResponseStatusCodes} from '../../messaging.model';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {MicrofrontendCapability, PlatformCapabilityTypes} from '../../platform.model';\nimport {Handler, IntentInterceptor} from '../message-broker/message-interception';\nimport {OutletRouter, ROUTING_CONTEXT_MESSAGE_HEADER, ROUTING_CONTEXT_OUTLET} from '../../client/router-outlet/outlet-router';\nimport {NavigationOptions} from '../../client/router-outlet/metadata';\nimport {MessageClient} from '../../client/messaging/message-client';\nimport {Dictionaries} from '@scion/toolkit/util';\nimport {ApplicationRegistry} from '../application-registry';\nimport {PRIMARY_OUTLET} from '../../client/router-outlet/router-outlet.element';\n\n/**\n * Handles microfrontend intents, instructing the {@link OutletRouter} to navigate to the microfrontend of the resolved microfrontend capability.\n *\n * Microfrontend intents are handled in this interceptor in order to support microfrontends not using the SCION Microfrontend Platform.\n * They are not transported to the providing application.\n */\nexport class MicrofrontendIntentNavigator implements IntentInterceptor {\n\n  /**\n   * Microfrontend intents are handled in this interceptor and then swallowed.\n   */\n  public intercept(intentMessage: IntentMessage, next: Handler<IntentMessage>): Promise<void> {\n    if (intentMessage.intent.type === PlatformCapabilityTypes.Microfrontend) {\n      return this.consumeMicrofrontendIntent(intentMessage);\n    }\n    else {\n      return next.handle(intentMessage);\n    }\n  }\n\n  private async consumeMicrofrontendIntent(message: IntentMessage<NavigationOptions>): Promise<void> {\n    const replyTo = message.headers.get(MessageHeaders.ReplyTo);\n    await this.navigate(message);\n    await Beans.get(MessageClient).publish(replyTo, null, {headers: new Map().set(MessageHeaders.Status, ResponseStatusCodes.TERMINAL)});\n  }\n\n  private async navigate(message: IntentMessage<NavigationOptions>): Promise<void> {\n    const microfrontendCapability = message.capability as MicrofrontendCapability;\n    const options = message.body;\n    const intent = message.intent;\n\n    const microfrontendPath = microfrontendCapability.properties?.path;\n    if (microfrontendPath === undefined || microfrontendPath === null) { // empty path is a valid path\n      throw Error(`[OutletRouterError][NullPathError] Microfrontend capability has no path to the microfrontend defined. [capability=${JSON.stringify(microfrontendCapability)}]`);\n    }\n    const appSymbolicName = microfrontendCapability.metadata!.appSymbolicName;\n    const application = Beans.get(ApplicationRegistry).getApplication(appSymbolicName);\n    if (!application) {\n      throw Error(`[OutletRouterError][NullApplicationError] Unexpected error. No application found with the symbolic name \"${appSymbolicName}\".`);\n    }\n\n    await Beans.get(OutletRouter).navigate(microfrontendPath, {\n      ...options,\n      outlet: this.resolveTargetOutlet(message),\n      relativeTo: application.baseUrl,\n      params: {...intent.qualifier, ...Dictionaries.coerce(intent.params)},\n    });\n  }\n\n  /**\n   * Resolves the target outlet in the following order:\n   *\n   * - Outlet as specified by navigator via {@link NavigationOptions#outlet}.\n   * - Preferred outlet as specified in the microfrontend capability.\n   * - Current outlet if navigating in the context of an outlet.\n   * - {@link PRIMARY_OUTLET primary} outlet.\n   */\n  private resolveTargetOutlet(message: IntentMessage<NavigationOptions>): string {\n    const microfrontendCapability = message.capability as MicrofrontendCapability;\n    const options = message.body;\n\n    if (options?.outlet) {\n      return options.outlet;\n    }\n    if (microfrontendCapability.properties.outlet) {\n      return microfrontendCapability.properties.outlet;\n    }\n    const contextualOutlet = message.headers.get(ROUTING_CONTEXT_MESSAGE_HEADER)?.[ROUTING_CONTEXT_OUTLET];\n    if (contextualOutlet) {\n      return contextualOutlet;\n    }\n    return PRIMARY_OUTLET;\n  }\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\nimport {ParamDefinition} from '../../platform.model';\n\n/**\n * Allows testing whether params match the param definitions.\n * @ignore\n */\nexport class ParamMatcher {\n\n  private readonly _requiredParamDefs = new Array<ParamDefinition>();\n  private readonly _optionalParamDefs = new Array<ParamDefinition>();\n  private readonly _deprecatedParamDefs = new Array<ParamDefinition>();\n\n  constructor(definitions: ParamDefinition[]) {\n    definitions.forEach(paramDef => {\n      if (paramDef.required ?? true) {\n        this._requiredParamDefs.push(paramDef);\n      }\n      else {\n        this._optionalParamDefs.push(paramDef);\n      }\n\n      if (paramDef.deprecated) {\n        this._deprecatedParamDefs.push(paramDef);\n      }\n    });\n  }\n\n  /**\n   * Tests if the given params match the param definitions.\n   */\n  public match(parameters: Map<string, any> | undefined): ParamsMatcherResult {\n    const params = new Map(parameters || []);\n\n    const matcherResult: ParamsMatcherResult = {\n      matches: true,\n      params,\n      missingParams: [],\n      unexpectedParams: [],\n      deprecatedParams: [],\n    };\n\n    // Test if deprecated params are passed and map them to their substitute, if any.\n    this._deprecatedParamDefs\n      .filter(paramDef => params.has(paramDef.name))\n      .forEach(paramDef => {\n        matcherResult.deprecatedParams.push(paramDef);\n\n        // Try mapping the deprecated param to its substitute.\n        const deprecation = paramDef.deprecated;\n        if (typeof deprecation === 'object' && deprecation.useInstead) {\n          params.set(deprecation.useInstead, params.get(paramDef.name));\n          params.delete(paramDef.name);\n        }\n      });\n\n    // Test if required params are passed.\n    this._requiredParamDefs\n      .filter(paramDef => !params.has(paramDef.name) || params.get(paramDef.name) === undefined)\n      .filter(paramDef => !this._deprecatedParamDefs.includes(paramDef))\n      .forEach(paramDef => {\n        matcherResult.matches = false;\n        matcherResult.missingParams.push(paramDef);\n      });\n\n    // Test if no additional params are passed.\n    Array.from(params.keys())\n      .filter(param => !this._requiredParamDefs.some(paramDef => paramDef.name === param) && !this._optionalParamDefs.some(paramDef => paramDef.name === param))\n      .forEach(param => {\n        matcherResult.matches = false;\n        matcherResult.unexpectedParams.push(param);\n      });\n\n    if (!matcherResult.matches) {\n      matcherResult.params = undefined;\n    }\n\n    return matcherResult;\n  }\n}\n\n/**\n * Represents the result of a params matcher test.\n * @ignore\n */\nexport interface ParamsMatcherResult {\n  /**\n   * Indicates whether the params match the param definitions.\n   */\n  matches: boolean;\n  /**\n   * Params as passed to the matcher, but with deprecated params mapped to their substitute,\n   * or `undefined` if the match is not successful.\n   */\n  params: Map<string, any> | undefined;\n  /**\n   * Required params that are missing.\n   */\n  missingParams: ParamDefinition[];\n  /**\n   * Params that are not expected.\n   */\n  unexpectedParams: string[];\n  /**\n   * Params that are deprecated.\n   */\n  deprecatedParams: ParamDefinition[];\n}\n","/*\n * Copyright (c) 2018-2022 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {Handler, IntentInterceptor} from './message-interception';\nimport {Intent, IntentMessage, MessageHeaders} from '../../messaging.model';\nimport {ParamMatcher, ParamsMatcherResult} from './param-matcher';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {Logger, LoggingContext} from '../../logger';\nimport {ParamDefinition} from '../../platform.model';\n\n/**\n * Rejects an intent if passing invalid params and warns if passing deprecated params.\n *\n * @ignore\n */\nexport class IntentParamValidator implements IntentInterceptor {\n\n  public async intercept(intentMessage: IntentMessage, next: Handler<IntentMessage>): Promise<void> {\n    const capability = intentMessage.capability;\n    const sender = intentMessage.headers.get(MessageHeaders.AppSymbolicName);\n\n    // Remove params with `undefined` as value.\n    intentMessage.intent.params?.forEach((value, key) => {\n      if (value === undefined) {\n        intentMessage.intent.params!.delete(key);\n      }\n    });\n\n    // Test params passed with the intent to match expected params as declared on the capability.\n    const paramMatcherResult = new ParamMatcher(capability.params!).match(intentMessage.intent.params);\n    if (!paramMatcherResult.matches) {\n      const error = toParamValidationError(paramMatcherResult, intentMessage.intent);\n      return Promise.reject(Error(`[IntentParamValidationError] ${error}`));\n    }\n\n    // Warn about the usage of deprecated params.\n    if (paramMatcherResult.deprecatedParams.length) {\n      paramMatcherResult.deprecatedParams.forEach(deprecatedParam => {\n        const warning = toDeprecatedParamWarning(deprecatedParam, {appSymbolicName: sender});\n        Beans.get(Logger).warn(`[DEPRECATION][4EAC5956] ${warning}`, new LoggingContext(sender), intentMessage.intent);\n      });\n      // Use the matcher's parameters to have deprecated params mapped to their replacement.\n      intentMessage.intent.params = paramMatcherResult.params!;\n    }\n    return next.handle(intentMessage);\n  }\n}\n\nfunction toParamValidationError(paramsMatcherResult: ParamsMatcherResult, intent: Intent): string {\n  const intentStringified = JSON.stringify(intent, (key, value) => (key === 'params') ? undefined : value);\n  const missingParams = paramsMatcherResult.missingParams.map(param => param.name);\n  const unexpectedParams = paramsMatcherResult.unexpectedParams;\n  return `Params of intent do not match expected params of capability. The intent must have required params and not have additional params. [intent=${intentStringified}, missingParams=[${missingParams}], unexpectedParams=[${unexpectedParams}]].`;\n}\n\nfunction toDeprecatedParamWarning(param: ParamDefinition, metadata: {appSymbolicName: string}): string {\n  const deprecation = param.deprecated!;\n  const useInstead = typeof deprecation === 'object' && deprecation.useInstead || undefined;\n  const message = typeof deprecation === 'object' && deprecation.message || undefined;\n\n  return new Array<string>()\n    .concat(`Application '${metadata.appSymbolicName}' passes a deprecated parameter in the intent: '${param.name}'.`)\n    .concat(useInstead ? `Pass parameter '${useInstead}' instead.` : [])\n    .concat(message || [])\n    .join(' ');\n}\n","/*\n * Copyright (c) 2018-2020 Swiss Federal Railways\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n */\nimport {MessageClient} from './client/messaging/message-client';\nimport {IntentClient} from './client/messaging/intent-client';\nimport {ManifestRegistry} from './host/manifest-registry/manifest-registry';\nimport {ApplicationRegistry} from './host/application-registry';\nimport {BehaviorSubject, from, Observable, Subject} from 'rxjs';\nimport {ConnectOptions} from './client/connect-options';\nimport {MicrofrontendPlatformConfig} from './host/microfrontend-platform-config';\nimport {PlatformPropertyService} from './platform-property-service';\nimport {ConsoleLogger, Logger} from './logger';\nimport {HttpClient} from './host/http-client';\nimport {ManifestCollector} from './host/manifest-collector';\nimport {MessageBroker} from './host/message-broker/message-broker';\nimport {first, takeUntil} from 'rxjs/operators';\nimport {OutletRouter} from './client/router-outlet/outlet-router';\nimport {SciRouterOutletElement} from './client/router-outlet/router-outlet.element';\nimport {FocusInEventDispatcher} from './client/focus/focus-in-event-dispatcher';\nimport {FocusMonitor} from './client/focus/focus-monitor';\nimport {ContextService} from './client/context/context-service';\nimport {RouterOutletUrlAssigner} from './client/router-outlet/router-outlet-url-assigner';\nimport {APP_IDENTITY, IS_PLATFORM_HOST, APP_CONFIG, VERSION, WINDOW_TOP} from './platform.model';\nimport {RelativePathResolver} from './client/router-outlet/relative-path-resolver';\nimport {ClientRegistry} from './host/client-registry/client.registry';\nimport {FocusTracker} from './host/focus/focus-tracker';\nimport {PreferredSizeService} from './client/preferred-size/preferred-size-service';\nimport {MouseMoveEventDispatcher} from './client/mouse-event/mouse-move-event-dispatcher';\nimport {MouseUpEventDispatcher} from './client/mouse-event/mouse-up-event-dispatcher';\nimport {KeyboardEventDispatcher} from './client/keyboard-event/keyboard-event-dispatcher';\nimport {ManifestService} from './client/manifest-registry/manifest-service';\nimport {ManifestRegistry} from './host/manifest-registry/manifest-registry';\nimport {ActivatorInstaller} from './host/activator/activator-installer';\nimport {BrokerGateway, NullBrokerGateway, BrokerGateway} from './client/messaging/broker-gateway';\nimport {PlatformState, Runlevel} from './platform-state';\nimport {BeanInstanceConstructInstructions, Beans} from '@scion/toolkit/bean-manager';\nimport {IntentClient} from './client/messaging/intent-client';\nimport {MessageClient} from './client/messaging/message-client';\nimport {MicrofrontendPlatformRef} from './microfrontend-platform-ref';\nimport {ProgressMonitor} from './host/progress-monitor/progress-monitor';\nimport {ActivatorLoadProgressMonitor, ManifestLoadProgressMonitor} from './host/progress-monitor/progress-monitors';\nimport {PlatformTopics} from './messaging.model';\nimport {createHostApplicationConfig} from './host/host-application-config-provider';\nimport {HostManifestInterceptor, HostManifestInterceptor} from './host/host-manifest-interceptor';\nimport {ApplicationConfig} from './host/application-config';\nimport {TopicSubscriptionRegistry} from './host/message-broker/topic-subscription.registry';\nimport {CLIENT_HEARTBEAT_INTERVAL, STALE_CLIENT_UNREGISTER_DELAY} from './host/client-registry/client.constants';\nimport {MicrofrontendPlatformStopper, MicrofrontendPlatformStopper} from './microfrontend-platform-stopper';\nimport {ClientRegistry} from './host/client-registry/client.registry';\nimport {IntentInterceptor} from './host/message-broker/message-interception';\nimport {MicrofrontendIntentNavigator} from './host/router/microfrontend-intent-navigator.interceptor';\nimport {IntentParamValidator} from './host/message-broker/intent-param-validator.interceptor';\nimport {IntentSubscriptionRegistry} from './host/message-broker/intent-subscription.registry';\n\n/**\n * Current version of the SCION Microfrontend Platform.\n */\nconst version = '1.0.0-rc.10';\n\n/**\n * **SCION Microfrontend Platform is a TypeScript-based open-source library that helps to implement a microfrontend architecture.**\n *\n * SCION Microfrontend Platform enables you to successfully implement a framework-agnostic microfrontend architecture using iframes.\n * It provides you fundamental APIs for microfrontends to communicate with each other across origin, allows embedding microfrontends\n * using a web component and enables routing between microfrontends. SCION Microfrontend Platform is a lightweight, web stack agnostic\n * library that has no user-facing components and does not dictate any form of application structure.\n *\n * You can continue using the frameworks you love since the platform integrates microfrontends via iframes. Iframes by nature provide\n * maximum isolation and allow the integration of any web application without complex adaptation. The platform aims to shield developers\n * from iframe specifics and the low-level messaging mechanism to focus instead on integrating microfrontends.\n *\n * #### Cross-microfrontend communication\n * The platform adds a pub/sub layer on top of the native `postMessage` mechanism to allow microfrontends to communicate with each other\n * easily across origins. Communication comes in two flavors: topic-based and intent-based. Both models feature the request-response message\n * exchange pattern, let you include message headers, and support message interception to implement cross-cutting messaging concerns.\n *\n * Topic-based messaging enables you to publish messages to multiple subscribers via a common topic. Intent-based communication focuses on\n * controlled collaboration between applications. To collaborate, an application must express an intention. Manifesting intentions allows\n * us to see dependencies between applications down to the functional level.\n *\n * #### Microfrontend Integration and Routing\n * The platform makes it easy to integrate microfrontends through its router-outlet. The router-outlet is a web component that wraps an iframe.\n * It solves many of the cumbersome quirks of iframes and helps to overcome iframe restrictions. For example, it can adapt its size to the\n * preferred size of embedded content, supports keyboard event propagation and allows you to pass contextual data to embedded content.\n * Using the router, you control which web content to display in an outlet. Multiple outlets can display different content, determined by\n * different outlet names, all at the same time. Routing works across application boundaries and enables features such as persistent navigation.\n *\n * ***\n *\n * A microfrontend architecture can be achieved in many different ways, each with its pros and cons. The SCION Microfrontend Platform uses\n * the iframe approach primarily since iframes by nature provide the highest possible level of isolation through a separate browsing context.\n * The microfrontend design approach is very tempting and has obvious advantages, especially for large-scale and long-lasting projects, most\n * notably because we are observing an enormous dynamic in web frameworks. The SCION Microfrontend Platform provides you with the necessary\n * tools to best support you in implementing such an architecture.\n *\n * @see {@link MessageClient}\n * @see {@link IntentClient}\n * @see {@link SciRouterOutletElement}\n * @see {@link OutletRouter}\n * @see {@link ContextService}\n * @see {@link PreferredSizeService}\n * @see {@link ManifestService}\n * @see {@link FocusMonitor}\n * @see {@link ActivatorCapability}\n *\n * @category Platform\n */\n// @dynamic `ng-packagr` does not support lambdas in statics if `strictMetaDataEmit` is enabled. `ng-packagr` is used to build this library. See https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-373487183.\nexport class MicrofrontendPlatform {\n\n  private static _state$ = new BehaviorSubject<PlatformState>(PlatformState.Stopped);\n  private static _startupProgress$ = new Subject<number>();\n\n  /**\n   * Starts the platform in the host application.\n   *\n   * The host application, sometimes also called the container application, provides the top-level integration container for microfrontends. Typically, it is the web\n   * application which the user loads into his browser that provides the main application shell, defining areas to embed microfrontends.\n   *\n   * The platform should be started during bootstrapping of the host application. In Angular, for example, the platform is typically started in an app initializer.\n   *\n   * In the host, the web applications are registered as micro applications. Registered micro applications can interact with the platform and other micro applications.\n   * As with micro applications, the host can provide a manifest to contribute behavior. For more information, see {@link HostConfig.manifest} in {@link MicrofrontendPlatformConfig.host}.\n   * If you are integrating the platform in a library, you may want to add behavior to the host's manifest, which you can do with a {@link HostManifestInterceptor}.\n   *\n   * During platform startup, the platform loads the manifests of registered micro applications. Because starting the platform is an asynchronous operation, you should\n   * wait for the startup Promise to resolve before interacting with the platform. Optionally, you can subscribe to the platforms startup progress to provide feedback\n   * to the user about the progress of the platform startup. See {@link MicrofrontendPlatform.startupProgress$} for more information.\n   *\n   * In the lifecycle of the platform, it traverses different lifecycle states that you can hook into by registering a callback to {@link MicrofrontendPlatform.whenState}.\n   * To hook into the startup of the platform, you can register an initializer using {@link @scion/toolkit!Beans.registerInitializer Beans.registerInitializer}, optionally passing a runlevel to control when the initializer\n   * will execute. The platform supports following runlevels:\n   *\n   * - In runlevel `0`, the platform fetches manifests of registered micro applications.\n   * - In runlevel `1`, the platform constructs eager beans and connects to the broker.\n   * - From runlevel `2` and above, messaging is enabled. This is the default runlevel at which initializers execute if not specifying any runlevel.\n   * - In runlevel `3`, the platform installs activator microfrontends. See https://scion-microfrontend-platform-developer-guide.vercel.app/#chapter:activator to learn more about activators.\n   *\n   * @param  config - Configures the platform and defines the micro applications running in the platform.\n   * @return A Promise that resolves once platform startup completed.\n   */\n  public static startHost(config: MicrofrontendPlatformConfig): Promise<void> {\n    return MicrofrontendPlatform.startPlatform(async () => {\n        MicrofrontendPlatform.installHostStartupProgressMonitor();\n\n        // Register platform beans.\n        Beans.register(IS_PLATFORM_HOST, {useValue: true});\n        Beans.registerIfAbsent(WINDOW_TOP, {useValue: window.top});\n        Beans.registerIfAbsent(VERSION, {useValue: version, destroyOrder: BeanDestroyOrders.CORE});\n        Beans.register(APP_IDENTITY, {useValue: config.host?.symbolicName || 'host'});\n        Beans.register(MicrofrontendPlatformConfig, {useValue: config});\n        Beans.registerIfAbsent(MicrofrontendPlatformStopper, {useClass: MicrofrontendPlatformStopper, eager: true});\n        Beans.register(HostManifestInterceptor, {useClass: HostManifestInterceptor, multi: true});\n        Beans.register(ClientRegistry, {useClass: ClientRegistry, destroyOrder: BeanDestroyOrders.CORE});\n        Beans.registerIfAbsent(CLIENT_HEARTBEAT_INTERVAL, {useValue: (config.heartbeatInterval ?? 60) * 10_000});\n        Beans.registerIfAbsent(STALE_CLIENT_UNREGISTER_DELAY, {useValue: 2_000});\n        Beans.registerIfAbsent(Logger, {useClass: ConsoleLogger, destroyOrder: BeanDestroyOrders.CORE});\n        Beans.register(PlatformPropertyService);\n        Beans.registerIfAbsent(HttpClient);\n        Beans.register(ManifestRegistry, {useClass: ManifestRegistry, eager: true});\n        Beans.register(ApplicationRegistry, {eager: true});\n        Beans.register(ContextService);\n        Beans.register(FocusTracker, {eager: true});\n        Beans.register(FocusInEventDispatcher, {eager: true});\n        Beans.register(MouseMoveEventDispatcher, {eager: true});\n        Beans.register(MouseUpEventDispatcher, {eager: true});\n        Beans.register(MessageBroker, {destroyOrder: BeanDestroyOrders.BROKER});\n        Beans.register(TopicSubscriptionRegistry, {destroyOrder: BeanDestroyOrders.BROKER});\n        Beans.register(IntentSubscriptionRegistry, {destroyOrder: BeanDestroyOrders.BROKER});\n        Beans.registerIfAbsent(OutletRouter);\n        Beans.registerIfAbsent(RelativePathResolver);\n        Beans.registerIfAbsent(RouterOutletUrlAssigner);\n        Beans.register(MicrofrontendPlatformRef, {useValue: MicrofrontendPlatform, destroyOrder: BeanDestroyOrders.CORE});\n        Beans.registerIfAbsent(MessageClient, provideMessageClient());\n        Beans.registerIfAbsent(IntentClient, provideIntentClient());\n        Beans.register(FocusMonitor);\n        Beans.register(PreferredSizeService, {eager: true});\n        Beans.register(ManifestService);\n        Beans.register(KeyboardEventDispatcher, {eager: true});\n        Beans.register(IntentInterceptor, {useClass: IntentParamValidator, multi: true});\n        Beans.register(IntentInterceptor, {useClass: MicrofrontendIntentNavigator, multi: true});\n\n        // Register broker gateway.\n        registerBrokerGateway({\n          messageDeliveryTimeout: config.host?.messageDeliveryTimeout,\n          brokerDiscoverTimeout: config.host?.brokerDiscoverTimeout,\n          connectRunlevel: Runlevel.One, // Connect to the broker in runlevel 1, that is, after registration of the applications.\n        });\n\n        // Register initializers.\n        registerRunlevel0Initializers();\n        registerRunlevel2Initializers();\n        registerRunlevel3Initializers();\n\n        // Register app configs under the symbol `APP_CONFIG` in the bean manager.\n        new Array<ApplicationConfig>()\n          .concat(createHostApplicationConfig(config.host))\n          .concat(config.applications)\n          .filter(application => !application.exclude)\n          .forEach(application => Beans.register(APP_CONFIG, {useValue: application, multi: true}));\n      },\n    );\n\n    /**\n     * Registers initializers to run in runlevel 0.\n     */\n    function registerRunlevel0Initializers(): void {\n      // Construct the message broker to buffer connect requests of micro applications.\n      Beans.registerInitializer({useExisting: MessageBroker, runlevel: Runlevel.Zero});\n      // Fetch manifests.\n      Beans.registerInitializer({useClass: ManifestCollector, runlevel: Runlevel.Zero});\n    }\n\n    /**\n     * Registers initializers to run in runlevel 2.\n     */\n    function registerRunlevel2Initializers(): void {\n      // Make platform properties available to micro applications.\n      Beans.registerInitializer({\n        useFunction: () => Beans.get(MessageClient).publish(PlatformTopics.PlatformProperties, config.properties || {}, {retain: true}),\n        runlevel: Runlevel.Two,\n      });\n      // Make applications available to micro applications.\n      Beans.registerInitializer({\n        useFunction: () => Beans.get(MessageClient).publish(PlatformTopics.Applications, Beans.get(ApplicationRegistry).getApplications(), {retain: true}),\n        runlevel: Runlevel.Two,\n      });\n      // Register the router outlet after beans have been registered and messaging is enabled.\n      Beans.registerInitializer({\n        useFunction: () => SciRouterOutletElement.define(),\n        runlevel: Runlevel.Two,\n      });\n    }\n\n    /**\n     * Registers initializers to run in runlevel 3.\n     */\n    function registerRunlevel3Initializers(): void {\n      // Wait until obtained platform properties so that they can be accessed synchronously by the application via `PlatformPropertyService#properties`.\n      Beans.registerInitializer({\n        useExisting: PlatformPropertyService,\n        runlevel: Runlevel.Three,\n      });\n      // Wait until obtained registered applications so that they can be accessed synchronously by the application via `ManifestService#applications`.\n      Beans.registerInitializer({\n        useExisting: ManifestService,\n        runlevel: Runlevel.Three,\n      });\n      // Install activator microfrontends.\n      Beans.registerInitializer({useClass: ActivatorInstaller, runlevel: Runlevel.Three});\n    }\n  }\n\n  /**\n   * Connects a micro application to the platform host.\n   *\n   * The platform host checks whether the connecting micro application is qualified to connect, i.e., is registered in the host application under that origin;\n   * otherwise, the host will reject the connection attempt. Note that the micro application needs to be embedded as a direct or indirect child window of the\n   * host application window.\n   *\n   * After the connection with the platform host is established, the micro application can interact with the host and other micro applications. Typically, the\n   * micro application connects to the platform host during bootstrapping. In Angular, for example, this can be done in an app initializer.\n   *\n   * In the lifecycle of the platform, it traverses different lifecycle states that you can hook into by registering a callback to {@link MicrofrontendPlatform.whenState}.\n   *\n   * @param  symbolicName - Specifies the symbolic name of this micro application. The micro application must be registered in the platform host under this symbol.\n   * @param  connectOptions - Controls how to connect to the platform host.\n   * @return A Promise that resolves once connected to the platform host, or that rejects otherwise.\n   */\n  public static connectToHost(symbolicName: string, connectOptions?: ConnectOptions): Promise<void> {\n    return MicrofrontendPlatform.startPlatform(async () => {\n        this.installClientStartupProgressMonitor();\n\n        // Register platform beans.\n        Beans.register(IS_PLATFORM_HOST, {useValue: false});\n        Beans.registerIfAbsent(WINDOW_TOP, {useValue: window.top});\n        Beans.register(APP_IDENTITY, {useValue: symbolicName});\n        Beans.registerIfAbsent(VERSION, {useValue: version, destroyOrder: BeanDestroyOrders.CORE});\n        Beans.registerIfAbsent(MicrofrontendPlatformStopper, {useClass: MicrofrontendPlatformStopper, eager: true});\n        Beans.register(PlatformPropertyService);\n        Beans.registerIfAbsent(Logger, {useClass: ConsoleLogger, destroyOrder: BeanDestroyOrders.CORE});\n        Beans.registerIfAbsent(HttpClient);\n        Beans.registerIfAbsent(MessageClient, provideMessageClient());\n        Beans.registerIfAbsent(IntentClient, provideIntentClient());\n        Beans.registerIfAbsent(OutletRouter);\n        Beans.registerIfAbsent(RelativePathResolver);\n        Beans.registerIfAbsent(RouterOutletUrlAssigner);\n        Beans.register(FocusInEventDispatcher, {eager: true});\n        Beans.register(FocusMonitor);\n        Beans.register(MouseMoveEventDispatcher, {eager: true});\n        Beans.register(MouseUpEventDispatcher, {eager: true});\n        Beans.register(PreferredSizeService, {eager: true});\n        Beans.register(ContextService);\n        Beans.register(ManifestService);\n        Beans.register(KeyboardEventDispatcher, {eager: true});\n        Beans.register(MicrofrontendPlatformRef, {useValue: MicrofrontendPlatform, destroyOrder: BeanDestroyOrders.CORE});\n\n        // Register broker gateway.\n        registerBrokerGateway({...connectOptions, connectRunlevel: Runlevel.Zero});\n\n        // Register initializers.\n        registerRunlevel2Initializers();\n      },\n    );\n\n    /**\n     * Registers initializers to run in runlevel 2.\n     */\n    function registerRunlevel2Initializers(): void {\n      // Wait until obtained platform properties so that they can be accessed synchronously by the application via `PlatformPropertyService#properties`.\n      Beans.registerInitializer({\n        useExisting: PlatformPropertyService,\n        runlevel: Runlevel.Two,\n      });\n      // Wait until obtained registered applications so that they can be accessed synchronously by the application via `ManifestService#applications`.\n      Beans.registerInitializer({\n        useExisting: ManifestService,\n        runlevel: Runlevel.Two,\n      });\n      // Ensure the SciRouterOutlet to be instantiated after initialization of the platform.\n      // Otherwise, the router outlet construction may fail or result in unexpected behavior, for example, because beans are not yet registered.\n      Beans.registerInitializer({\n        useFunction: () => SciRouterOutletElement.define(),\n        runlevel: Runlevel.Two,\n      });\n    }\n  }\n\n  /**\n   * Checks whether this micro application is connected to the platform host.\n   */\n  public static async isConnectedToHost(): Promise<boolean> {\n    if (MicrofrontendPlatform.state === PlatformState.Stopped) {\n      return false;\n    }\n    const brokerGateway = Beans.opt(BrokerGateway);\n    if (!brokerGateway) {\n      return false;\n    }\n    return brokerGateway.isConnected();\n  }\n\n  /**\n   * Destroys this platform and releases resources allocated.\n   *\n   * @return a Promise that resolves once the platformed stopped.\n   */\n  public static async destroy(): Promise<void> {\n    await MicrofrontendPlatform.enterState(PlatformState.Stopping);\n    Beans.destroy();\n    await MicrofrontendPlatform.enterState(PlatformState.Stopped);\n  }\n\n  /** @internal */\n  public static async startPlatform(startupFn?: () => Promise<void>): Promise<void> {\n    await MicrofrontendPlatform.enterState(PlatformState.Starting);\n    try {\n      await startupFn?.();\n      await Beans.start({eagerBeanConstructRunlevel: Runlevel.One, initializerDefaultRunlevel: Runlevel.Two});\n      await MicrofrontendPlatform.enterState(PlatformState.Started);\n      return Promise.resolve();\n    }\n    catch (error) {\n      await MicrofrontendPlatform.destroy();\n      return Promise.reject(`[MicrofrontendPlatformStartupError] Microfrontend platform failed to start: ${error}`);\n    }\n  }\n\n  /**\n   * @return the current platform state.\n   */\n  public static get state(): PlatformState {\n    return this._state$.getValue();\n  }\n\n  /**\n   * Allows waiting for the platform to enter the specified {@link PlatformState}.\n   * If already in that state, the Promise resolves instantly.\n   *\n   * @param  state - the state to wait for.\n   * @return A Promise that resolves when the platform enters the given state.\n   *         If already in that state, the Promise resolves instantly.\n   */\n  public static async whenState(state: PlatformState): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this._state$\n        .pipe(first(it => it === state))\n        .subscribe({\n          error: reject,\n          complete: resolve,\n        });\n    });\n  }\n\n  /**\n   * Observable that, when subscribed, emits the current platform lifecycle state.\n   * It never completes and emits continuously when the platform enters\n   * another state.\n   */\n  public static get state$(): Observable<PlatformState> {\n    return this._state$;\n  }\n\n  private static async enterState(newState: PlatformState): Promise<void> {\n    const currentState = (this.state === PlatformState.Stopped) ? -1 : this.state;\n    if (currentState >= newState) {\n      throw Error(`[PlatformStateError] Failed to enter platform state [prevState=${PlatformState[this.state]}, newState=${PlatformState[newState]}].`);\n    }\n\n    this._state$.next(newState);\n\n    // Let microtasks waiting for entering that state to resolve first.\n    await this.whenState(newState);\n  }\n\n  /**\n   * Allows listening to the startup progress of the platform.\n   *\n   * In the host, when the platform starts, it fetches the manifests of the registered applications, among other things,\n   * and waits for the applications to signal their readiness, which can take some time.\n   *\n   * You can subscribe to this Observable to provide feedback to the user about the progress of the platform startup.\n   * The Observable reports the progress as a percentage number. The Observable completes once the platform finished startup.\n   */\n  public static get startupProgress$(): Observable<number> {\n    return this._startupProgress$;\n  }\n\n  private static installHostStartupProgressMonitor(): void {\n    const monitor = new ProgressMonitor();\n\n    const [startupProgressMonitor, manifestLoadProgressMonitor, activatorLoadProgressMonitor] = monitor.split(1, 3, 5);\n    Beans.register(ManifestLoadProgressMonitor, {useValue: manifestLoadProgressMonitor});\n    Beans.register(ActivatorLoadProgressMonitor, {useValue: activatorLoadProgressMonitor});\n    MicrofrontendPlatform.whenState(PlatformState.Started).then(() => {\n      startupProgressMonitor.done();\n    });\n    MicrofrontendPlatform.whenState(PlatformState.Stopped).then(() => {\n      MicrofrontendPlatform._startupProgress$ = new Subject<number>();\n    });\n\n    monitor.progress$\n      .pipe(takeUntil(from(MicrofrontendPlatform.whenState(PlatformState.Started))))\n      .subscribe(MicrofrontendPlatform._startupProgress$);\n  }\n\n  private static installClientStartupProgressMonitor(): void {\n    const monitor = new ProgressMonitor();\n    MicrofrontendPlatform.whenState(PlatformState.Started).then(() => {\n      monitor.done();\n    });\n    MicrofrontendPlatform.whenState(PlatformState.Stopped).then(() => {\n      MicrofrontendPlatform._startupProgress$ = new Subject<number>();\n    });\n\n    monitor.progress$\n      .pipe(takeUntil(from(MicrofrontendPlatform.whenState(PlatformState.Started))))\n      .subscribe(MicrofrontendPlatform._startupProgress$);\n  }\n}\n\n/** @ignore */\nfunction registerBrokerGateway(connectOptions: ConnectOptions & {connectRunlevel: number}): void {\n  if (connectOptions.connect ?? true) {\n    Beans.register(BrokerGateway, {\n      useFactory: () => new BrokerGateway(connectOptions),\n      destroyOrder: BeanDestroyOrders.MESSAGING,\n    });\n    Beans.register(BrokerGateway, {useExisting: BrokerGateway});\n    Beans.registerInitializer({useExisting: BrokerGateway, runlevel: connectOptions.connectRunlevel});\n  }\n  else {\n    Beans.register(BrokerGateway, {useClass: NullBrokerGateway});\n  }\n}\n\n/** @ignore */\nfunction provideMessageClient(): BeanInstanceConstructInstructions {\n  return {\n    useClass: MessageClient,\n    eager: true,\n    destroyOrder: BeanDestroyOrders.MESSAGING,\n  };\n}\n\n/** @ignore */\nfunction provideIntentClient(): BeanInstanceConstructInstructions {\n  return {\n    useClass: IntentClient,\n    eager: true,\n    destroyOrder: BeanDestroyOrders.MESSAGING,\n  };\n}\n\n/**\n * Specifies destroy orders of platform-specific beans, enabling controlled termination of the platform.\n *\n * @ignore\n */\nenum BeanDestroyOrders {\n  /**\n   * Use for core platform beans which should be destroyed as the very last beans.\n   */\n  CORE = Number.MAX_SAFE_INTEGER,\n  /**\n   * Use for the {@link MessageBroker}.\n   */\n  BROKER = CORE - 1,\n  /**\n   * Use for messaging-related beans.\n   */\n  MESSAGING = BROKER - 1\n}\n","import {IntentClient, IntentInterceptor, ManifestService, MessageClient, MessageInterceptor, MicrofrontendPlatform, OutletRouter, QualifierMatcher, TopicMatcher} from '@scion/microfrontend-platform';\nimport {Beans} from '@scion/toolkit/bean-manager';\nimport {UUID} from '@scion/toolkit/uuid';\n\nwindow['__SCION_RCP'] = window['__SCION_RCP'] || {};\nwindow['__SCION_RCP'].refs = {\n  get MicrofrontendPlatform() {\n    return MicrofrontendPlatform;\n  },\n  get MessageClient() {\n    return Beans.get(MessageClient);\n  },\n  get IntentClient() {\n    return Beans.get(IntentClient);\n  },\n  get OutletRouter() {\n    return Beans.get(OutletRouter);\n  },\n  get ManifestService() {\n    return Beans.get(ManifestService);\n  },\n  get Beans() {\n    return Beans;\n  },\n  get MessageInterceptor() {\n    return MessageInterceptor;\n  },\n  get IntentInterceptor() {\n    return IntentInterceptor;\n  },\n  get TopicMatcher() {\n    return TopicMatcher;\n  },\n  get QualifierMatcher() {\n    return QualifierMatcher;\n  },\n  get UUID() {\n    return UUID;\n  },\n};\n\n"],"names":["$746141bbf30b1d44$var$extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","$746141bbf30b1d44$export$a8ba968b8961cb8a","TypeError","String","__","this","constructor","create","$746141bbf30b1d44$export$1050f835b63b671e","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","$746141bbf30b1d44$export$67ebef60e6f28a6","body","t","g","_","label","sent","verb","throw","return","Symbol","iterator","n","v","op","y","ops","pop","trys","length","push","f","$746141bbf30b1d44$export$19a8beecd37a4c45","o","s","m","i","$746141bbf30b1d44$export$8d051b38c9118094","r","ar","error","$746141bbf30b1d44$export$1216008129fb82ed","to","from","pack","arguments","l","slice","concat","$746141bbf30b1d44$export$10c90e4f7922046c","q","asyncIterator","a","resume","fulfill","settle","shift","$746141bbf30b1d44$export$e3b29a3d6162315f","$e996a377a476308b$export$f6e2535fb5126e54","$84b00e98e2449571$export$128a15b65d1b6041","createImpl","ctorFunc","instance","Error","stack","$ea002fe37e02483f$export$c9648b76fd580c34","_super","errors","message","map","err","toString","join","name","$e982355222966567$export$dae3f38077fc36c0","arr","item","index","indexOf","splice","$5124a93ca0cff8ae$export$f55210826850c514","Subscription","initialTeardown","closed","_parentage","_finalizers","empty","unsubscribe","isArray","_parentage_1","_parentage_1_1","remove","initialFinalizer","_finalizers_1","_finalizers_1_1","finalizer","$5124a93ca0cff8ae$var$execFinalizer","add","teardown","_hasParent","_addParent","_a","parent","includes","_removeParent","EMPTY","$5124a93ca0cff8ae$export$610f9c3ca1a38dd8","$5124a93ca0cff8ae$export$4f9221cbada3c4fc","$ed09702a4a712d45$export$e506a1d27d1eaa20","onUnhandledError","onStoppedNotification","undefined","useDeprecatedSynchronousErrorHandling","useDeprecatedNextContext","$9cfc76a232e78ed6$export$365aa6bd3c788e3d","setTimeout","handler","timeout","args","_i","delegate","clearTimeout","handle","$e95832991341c572$export$ebf645db02d3e99f","$a2669f8c8173c8d3$export$8793edee2d425525","$a4b08c076fa88601$export$b7f97edb34bc1f87","$a4b08c076fa88601$export$9c8f6e8d39c60cf3","$a4b08c076fa88601$export$ff9346b0d1d30313","kind","$97e50eda4820bbda$var$context","$97e50eda4820bbda$export$d974811edc77eafa","cb","isRoot","errorThrown","$144251abd0e070aa$export$60959659b2c22881","Subscriber","destination","_this","isStopped","$144251abd0e070aa$export$88d395d20619a0af","complete","$144251abd0e070aa$export$94eeb6a328cab6c7","$144251abd0e070aa$var$handleStoppedNotification","_next","_error","_complete","$144251abd0e070aa$var$_bind","Function","bind","$144251abd0e070aa$var$bind","fn","$144251abd0e070aa$var$ConsumerObserver","ConsumerObserver","partialObserver","$144251abd0e070aa$var$handleUnhandledError","SafeSubscriber","observerOrNext","context_1","notification","subscriber","$ea15a553d1249983$export$5ab46cbf6120b33a","observable","$d964bb9c87650d9b$export$f0954fd7d5368655","x","$105ed219d50c6c26$export$a4627e546088548d","fns","$105ed219d50c6c26$export$71f88a61afaa14d7","input","reduce","prev","$157495f65d1fedd6$export$77cea355fa80b5f4","Observable","subscribe","_subscribe","lift","operator","source","$157495f65d1fedd6$var$isObserver","_trySubscribe","sink","forEach","promiseCtor","$157495f65d1fedd6$var$getPromiseCtor","pipe","operations","toPromise","$fc094a53485b6f1b$export$f708eee25634bc80","$489dabb836a96717$export$b6bbab5a9b109038","Subject","currentObservers","observers","hasError","thrownError","subject","$489dabb836a96717$export$155189cde295587d","_throwIfClosed","_b","_c","defineProperty","get","_checkFinalizedStatuses","_innerSubscribe","asObservable","AnonymousSubject","$d80e01a928648151$export$fe960da701faae26","AsyncSubject","_value","_hasValue","_isComplete","$30ec1b283cbb27fa$export$cc3d42e6b2b9cf8b","BehaviorSubject","getValue","subscription","$cb6028617666e135$var$isArray","$cb6028617666e135$var$getPrototypeOf","getPrototypeOf","$cb6028617666e135$var$objectProto","$cb6028617666e135$var$getKeys","keys","$cb6028617666e135$export$8871b3799a14360f","first_1","obj","key","$91d542d0b784d24b$export$1e2f57719e155213","$7700e3a10fed84ae$export$4369c812aac99591","$ba3895138ebfd0d0$export$48c0cddbc99c45c2","$8b01cc4a4fa9c790$export$edb10ab8dd75a915","$80eb79c79e8b4ce6$export$7cbe71b9fa263484","$10702573cd9f2753$export$6f58e2338da23f4d","$3172d966b15186c2$export$9652023d9040757","$022971cd29cb3478$export$cf4785e597badab3","readableStream","reader","getReader","read","releaseLock","$022971cd29cb3478$export$c088ffafdba7405f","$d5e97ca40de1dca2$export$6a9cfa3ebc765910","obs","array","promise","$d5e97ca40de1dca2$export$e073fccf36d78cc1","iterable","iterable_1","iterable_1_1","asyncIterable","asyncIterable_1","asyncIterable_1_1","$d5e97ca40de1dca2$var$process","catch","$bb90871d75d428d3$export$a2b7447487315232","parentSubscription","scheduler","work","delay","repeat","scheduleSubscription","schedule","$b70519f632db53cb$export$871731df685d7753","init","$b70519f632db53cb$export$ebec8610810318c5","liftedSource","$1082674ba26021fb$export$b9e075132cc6937f","onNext","onComplete","onError","onFinalize","$1082674ba26021fb$export$8fbbf0c4d80268e5","OperatorSubscriber","shouldUnsubscribe","err1","closed_1","$b3be89a302f54553$export$9007f49c319d1ac7","$03c04c3ffa6f4f2b$export$1eb44d8f5f64733b","$bfcdfb161bcad5ec$export$ed8bd553a12b6a30","$b200b6eac85b4492$export$fc9afd948577f0a8","$7b1925659fd6b401$export$b34673931371729a","$de7ccd11b81af792$export$2b75c58ab9b5b766","$099e1a95f8be7c6a$export$7c7f0979b56a32f3","$970e2f50a47ce5c8$export$3385251aeecad28a","$428746786ed9c66f$export$49c44dfc2bb21d70","$cecb8b01522e9ff4$export$6788812c4e6611e6","$a344549688aae3fd$export$871de8747c9eaa88","project","$fdef718a708846aa$var$isArray","$fdef718a708846aa$export$559affaa48f4288d","$fdef718a708846aa$var$callOrApply","$c3cdee6cceaf9473$export$187e35932e88c15c","$798a448d65d66d7d$var$last","$798a448d65d66d7d$export$9ae19b645239a61b","$798a448d65d66d7d$export$29534b2f653ae592","$798a448d65d66d7d$export$3de14b735070dcd5","defaultValue","$9ee0b49cb72a62a4$export$79c7e160a7743efd","values","$e9c33d8acb1fdd17$export$77fa7d86f5204e8a","resultSelector","observables","$e9c33d8acb1fdd17$export$f04dcfb475ed2128","valueTransform","$e9c33d8acb1fdd17$var$maybeSchedule","active","remainingFirstValues","_loop_1","hasFirstValue","execute","$28f45fd372d3b455$export$600918ebaa9e0a1b","concurrent","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","bufferedValue","$8657d55690de2a98$export$6b9f6c0d32c093f9","Infinity","ii","$b57c3fedf76caaed$export$18aef43295bbe906","$0280bbcc426dce78$export$b314777ae20abca9","$98685deadaab283c$export$ee1b3e54f0441b22","$2dc044d45b969f33$export$ee1b3e54f0441b22","$a8cf4712258bbbb6$export$6a50f648373d0fa8","otherSources","$ead8e990cfbfe279$export$260e5c0943f31606","observableFactory","$6e7e0ef18f0a3115$export$ccb33e29d92c9a58","$827970c208304071$export$3dea766d36a8935f","predicate","$eec29157d02a25b0$export$78f6d1b1dbcda304","$f03dcc354f8c1062$export$400f9f949cef996c","config","hasConfig","$6ca17bc48d68771b$var$nodeEventEmitterMethods","$6ca17bc48d68771b$var$eventTargetMethods","$6ca17bc48d68771b$var$jqueryMethods","$6ca17bc48d68771b$export$a36e16046ae8f1bb","target","eventName","options","addEventListener","removeEventListener","$6ca17bc48d68771b$var$isEventTarget","methodName","addListener","removeListener","$6ca17bc48d68771b$var$isNodeStyleEventEmitter","$6ca17bc48d68771b$var$toCommonHandlerRegistry","on","off","$6ca17bc48d68771b$var$isJQueryStyleEventEmitter","subTarget","$e731e77718be64fd$export$e19cd5f9376f8cee","Action","state","$a4abb0157f6db370$export$f0ca5e16f6f68711","setInterval","clearInterval","$331a777e5f6dff82$export$b5369ffd7cb2211b","AsyncAction","pending","id","recycleAsyncId","requestAsyncId","_id","flush","_scheduler","_execute","_delay","errorValue","errored","actions","$8777e340304a87e2$export$c1895ea2d519a677","now","Date","$699ca6a12b1d5e7c$export$d3e54bb8584cda7c","Scheduler","schedulerActionCtor","$03059729cc91d1d5$export$8d6b71a2b178fc32","AsyncScheduler","SchedulerAction","_active","action","$03059729cc91d1d5$export$12af436354f1a4f7","$df0ca230b4c087cb$export$c03bb0116ee09d4b","isNaN","$ba06f10a02915e96$export$9dc4ecf953986f04","dueTime","intervalOrScheduler","intervalDuration","due","$7b246f86cff85ef0$export$a175cc82f1f2275e","$30ffe4e7b3d62072$export$4950aa0f605343fb","sources","$62d8f22c904e5fe7$export$96c94437c95d7862","$ed54d2f12a6f8669$export$ba255e9e49e00608","$3abb0c810830a073$export$915d2682b0aa0991","ReplaySubject","_bufferSize","_windowTime","_timestampProvider","_buffer","_infiniteTimeWindow","Math","max","_trimBuffer","copy","adjustedBufferSize","last","$e8a8f4270a768261$export$9f6ea8e48bc26eab","innerSubscriber","innerIndex","outerIndex","$7793e4bb10595700$export$8bf7aba4a9e09055","errorOrErrorFactory","errorFactory","$4be3df9c8b191a2f$export$66d311bf29d5c89c","info","$4be3df9c8b191a2f$export$83e74882c5df8fe1","schedulerArg","first","each","with","_with","$4be3df9c8b191a2f$var$timeoutErrorFactory","_d","meta","originalSourceSubscription","timerSubscription","lastValue","seen","startTimer","$022094d06ff270cc$export$d449030e5c10edf7","inputs","len","otherValues","hasValue","ready","every","$cfad638bbde2c674$export$719c70722b10e5ff","duration","durationSelector","durationSubscriber","endDuration","cleanupDuration","$a3c41b925191c992$export$3dede90624df3ba9","selector","handledResult","innerSub","syncUnsub","$1ee112efcb5b10b8$export$790c233a67baba3","Defined","$1ee112efcb5b10b8$export$3b0ccdbbdb9feaa4","Arrays","$1ee112efcb5b10b8$export$5c089a222833d7b7","$1ee112efcb5b10b8$export$45dae21dfe837dd7","Dictionaries","$1ee112efcb5b10b8$export$2869c604d0a0cf9c","Maps","$1ee112efcb5b10b8$export$3e8af96bd6669133","$4dfab0b79a6f46d4$var$isArray","$4dfab0b79a6f46d4$export$24e1bb79414042be","$b816cfe1994a56f7$export$77fa7d86f5204e8a","$1b8b5ade318bf9a9$export$2c346d97ede9fe0c","$419c2da03c3ac473$export$779c5fb865a0172e","comparator","keySelector","$419c2da03c3ac473$var$defaultCompare","previousKey","currentKey","$7d94a21417a1623d$export$9f77e0932fb78f72","$970a0f030dee86ff$export$578723aef62d92f5","callback","$c7828fe634a19a01$export$b7df5d561049483a","count","$34cec3157a65a432$export$e4ca6d7b7a6dcf9b","$be8653f4a3e95561$export$c8ea5e9f84346833","$be8653f4a3e95561$var$defaultErrorFactory","$cbe8268c6277296f$export$43128fadae87b74a","hasDefaultValue","$f60f59c3c27c3419$export$ed80d9de1d9df928","connector","resetOnError","resetOnComplete","resetOnRefCountZero","wrapperSource","connection","resetConnection","refCount","hasCompleted","hasErrored","cancelReset","reset","resetAndUnsubscribe","conn","dest","$f60f59c3c27c3419$var$handleReset","onSubscriber","$369a1beddcfddd56$export$a4fe86229b0e9bdd","$095ad5aa66f29705$export$ac8dfd3a7ad06e80","notifier","$54e8ed1fe60bf698$export$9384c7afe4015e42","inclusive","$9654f9d6f3b258de$export$3f23594af5f37336","tapObserver","isUnsub","finalize","$1ee112efcb5b10b8$var$createDictionaryFromMap","entries","dictionary","orElse","orElseValue","orElseThrow","orElseThrowFn","coerce","coerceNullOrUndefined","isEqual","array1","array2","exactOrder","element","firstOnly","indexOfElementFn","findIndex","removedElements","distinct","items","itemSet","Set","filter","delete","intersect","arrays","_arrays","intersection","dictionaryLike","Map","withoutUndefinedEntries","object","mapLike","set","addSetValue","multiValueMap","removeSetValue","hasRemoved","predicateFn","removed","it","size","addListValue","removeListValue","$cff806b54a59ff26$export$e1272dadeadaca63","_beanRegistry","_decoratorRegistry","_initializers","_sequence","_runlevel$","_eagerBeansConstructed","_started","register","symbol","instructions","some","property","startsWith","$cff806b54a59ff26$var$containsBeansConstructStrategy","useClass","$cff806b54a59ff26$var$validateBeanConstructInstructions","multi","has","metaData","disposeBean","beanInfo","beanConstructFn","$cff806b54a59ff26$var$createBeanConstructFunction","eager","useValue","constructing","beans","getOrConstructBeanInstance","unregister","registerIfAbsent","registerDecorator","decorator","constructFn","registerInitializer","initializer","initializerInfo","runlevel","useFunction","useExisting","all","orElseGet","orElseSupply","$cff806b54a59ff26$var$getSymbolName","opt","beanInfos","async","initializerDefaultRunlevel","eagerBeanConstructRunlevel","constructEagerBeans","runInitializers","destroy","getBeanInfos","sort","$cff806b54a59ff26$var$compareByDestroyOrder","bean","clear","useFactory","preDestroy","console","currentRunlevel","acc","defaultInitializerRunlevel","initializersGroupedByRunlevel","grouped","runlevels","initializerFn","decorators","reverse","decoratedBean","decorate","constructInstant","bean1","bean2","destroyOrder","useClassFn","useFactoryFn","instruction","JSON","stringify","$84fd935868f92681$export$bc35efed93511c4b","static","window","performance","replace","char","random","floor","$423910d04536f96f$export$8f2c8e61d147b502","matches","match","previous","current","$423910d04536f96f$export$4c9116dcf1374231","projectFn","$423910d04536f96f$export$b5f2084817235760","closingNotifier$","guard$","$fa82205ce6a81f78$export$e17d0a8e529bc2ca","observer","resizeObserver","ResizeObserver","clientWidth","offsetWidth","clientHeight","offsetHeight","observe","disconnect","$f360cb19a7470d55$export$36e3ecc814ff657b","PlatformCapabilityTypes","$f360cb19a7470d55$export$abac07b0d121aae2","$f360cb19a7470d55$export$4ce958c9d1dac10e","$f360cb19a7470d55$export$a11aa4b1ad6eec09","$f360cb19a7470d55$export$af1ba2d30ad6bd95","$f360cb19a7470d55$export$81c17362cfb54e66","$f360cb19a7470d55$export$3200a3edec649cbd","$f360cb19a7470d55$export$b23af55470b7f1e1","MessageHeaders","$f360cb19a7470d55$export$846c248a91ff93f7","RequestMethods","$f360cb19a7470d55$export$a499daaa5fe026d2","ResponseStatusCodes","$f360cb19a7470d55$var$MessagingTransport","MessagingTransport","$f360cb19a7470d55$var$MessagingChannel","MessagingChannel","$f360cb19a7470d55$var$PlatformTopics","PlatformTopics","$f360cb19a7470d55$var$Topics","$f360cb19a7470d55$export$c3e6bb28c793a982","status","headers","Status","OK","messageBody","$f360cb19a7470d55$export$43ee7d0e4f429743","BAD_REQUEST","NOT_FOUND","ERROR","TERMINAL","$f360cb19a7470d55$export$d6978861bb0c00c2","msg","super","$f360cb19a7470d55$export$a5b24081a734c6a9","$f360cb19a7470d55$export$2509be367963fa45","topic","subscriberCount$","RequestSubscriberCount","FocusIn","IsFocusWithin","PlatformProperties","Applications","heartbeat","clientId","Topics","isWildcardSegment","segment","split","Boolean","containsWildcardSegments","computeWildcardSegmentPermutations","wildcardCharacter","segments","permutations","permutation","replaceWildcardSegments","replacement","$f360cb19a7470d55$export$417f7cd86929f164","pattern","_patternSegments","inputTopicSegments","patternSegments","params","patternSegment","substring","$f360cb19a7470d55$var$filterByTransport","transport","event","envelope","data","channel","$f360cb19a7470d55$var$filterByChannel","channels","$f360cb19a7470d55$var$filterByTopicChannel","Topic","messageTopic","$f360cb19a7470d55$var$filterByMessageHeader","header","messageHeaders","$f360cb19a7470d55$var$pluckMessage","messageEvent","$f360cb19a7470d55$export$efa9a398d6368992","$f360cb19a7470d55$export$ba6a9c7ac8291f7f","debug","log","warn","severity","loggingContext","$f360cb19a7470d55$export$cfece0898859977d","appSymbolicName","version","prefix","consoleFn","$f360cb19a7470d55$export$1643d64233a33b47","$f360cb19a7470d55$export$f677ff3cbab00a1f","PlatformState","$f360cb19a7470d55$export$63daa6aa86ffb707","Runlevel","$f360cb19a7470d55$var$GatewayErrors","GatewayErrors","$f360cb19a7470d55$var$MicrofrontendPlatformRef","$f360cb19a7470d55$var$runSafe","runnable","$f360cb19a7470d55$var$stringifyError","$f360cb19a7470d55$var$BrokerGateway","$f360cb19a7470d55$var$NullBrokerGateway","isConnected","message$","postMessage","requestReply$","subscribe$","subscriptionDescriptor","connectOptions","_platformStopping$","_session","_session$","_appSymbolicName","_brokerDiscoverTimeout","brokerDiscoverTimeout","_messageDeliveryTimeout","messageDeliveryTimeout","session","connectToBroker","installBrokerMessageListener","installHeartbeatPublisher","$f360cb19a7470d55$var$isPlatformStopped","PLATFORM_STOPPED_ERROR","messageId","randomUUID","ClientToBroker","MessageId","Timestamp","AppSymbolicName","ClientId","postError$","whenPosted","MESSAGE_DISPATCH_ERROR","statusMessage","ok","details","broker","origin","request","replyTo","subscriberId","unsubscribe$","requestError$","ReplyTo","unsubscribeChannel","TopicUnsubscribe","logContext","reply","messageChannel","subscribeChannel","newSubscribeCommand","subscribeError$","descriptor","unsubscribeCommand","window1","BrokerToClient","Intent","intentMessage","intent","topicMessage","period","heartbeatInterval","publish","connectPromise","response","returnCode","returnMessage","BROKER_DISCOVER_ERROR","connectMessage","ClientConnect","Version","windowHierarchy","collectWindowHierarchy","disconnectFromBroker","disconnectMessage","ClientDisconnect","candidates","candidate","unshift","platformState","Stopped","$f360cb19a7470d55$export$795435d319aa5def","_properties","properties$","observe$","properties","contains","$f360cb19a7470d55$export$453ace576174a6eb","$f360cb19a7470d55$var$ManifestRegistry","$f360cb19a7470d55$var$ABSOLUTE_URL_REGEX","$f360cb19a7470d55$var$Urls","Urls","isAbsoluteUrl","url","test","newUrl","base","baseUrl","URL","pathname","endsWith","ensureTrailingSlash","$f360cb19a7470d55$export$2eb36f74b177828a","$f360cb19a7470d55$var$ApplicationRegistry","_applications","registerApplication","applicationConfig","manifest","symbolicName","manifestUrl","SYMBOLIC_NAME_REGEXP","application","computeBaseUrl","manifestLoadTimeout","activatorLoadTimeout","messageOrigin","scopeCheckDisabled","intentionCheckDisabled","intentionRegisterApiDisabled","capability","_e","capabilities","registerCapability","_f","intentions","intention","registerIntention","getApplication","getApplications","isScopeCheckDisabled","isIntentionRegisterApiDisabled","isIntentionCheckDisabled","manifestURL","$f360cb19a7470d55$var$HttpClient","fetch","$f360cb19a7470d55$var$ProgressMonitor","_progress$","_done$","_hasSubMonitors","progress$","progress","round","ratio","subMonitors","subMonitor","ratioSum","sum","weight","subMonitorsProgress","totalProgress","subMonitorWeight","subMonitorIndex","$f360cb19a7470d55$var$computeProgress","splitEven","fill","$f360cb19a7470d55$var$ManifestLoadProgressMonitor","$f360cb19a7470d55$var$ActivatorLoadProgressMonitor","$f360cb19a7470d55$export$3af33b08f01f58a3","intercept","hostManifest","$f360cb19a7470d55$var$provideActivatorIntentionIfEnabled","activatorApiDisabled","type","Activator","qualifier","$f360cb19a7470d55$var$ManifestCollector","fetchAndRegisterManifests","appConfigs","monitor","appConfig","fetchAndRegisterManifest","fetchManifest$","manifestFetchTimeout","onManifestFetchTimeout","manifestFetchResponse","statusText","json","interceptor","$f360cb19a7470d55$var$ClientRegistry","$f360cb19a7470d55$var$MessageSubscriptionRegistry","_destroy$","_subscriptions","_subscriptionsByApp","_subscriptionsByClient","_register$","_unregister$","unregister$","client","onRegister","subscriptions","onUnregister","notifyUnsubscribe","filterById","filterByClient","filterByApp","subscriptionById","subscriptionsByClient","subscriptionsByApp","register$","$f360cb19a7470d55$var$MessageSubscription","whenUnsubscribe","$f360cb19a7470d55$var$ASTERISK","$f360cb19a7470d55$var$TopicSubscriptionRegistry","_subscriptionsByTopic","filterByTopic","subscriptionsByTopic","subscriptionCount$","$f360cb19a7470d55$var$TopicSubscription","$f360cb19a7470d55$export$928c6333c0fd2868","$f360cb19a7470d55$export$93458e9b1705f47e","$f360cb19a7470d55$export$218fc7342c49994f","interceptors","publisher","terminalHandler","$f360cb19a7470d55$export$a428cd33b25d5283","handlerChain","reduceRight","interceptAndPublish","$f360cb19a7470d55$var$SEMVER_REGEX","$f360cb19a7470d55$var$semver","semver","parseVersion","major","groups","minor","patch","preRelease","identifier","numericIdentifier","Number","lt","version1","version2","v1","v2","semVer1","semVer2","majorCompare","sign","minorCompare","patchCompare","identifier1","identifier2","comparePreRelease","compare","$f360cb19a7470d55$var$CLIENT_HEARTBEAT_INTERVAL","$f360cb19a7470d55$var$STALE_CLIENT_UNREGISTER_DELAY","$f360cb19a7470d55$export$26246f283d6ee833","flags","_pattern","_patternKeys","_flags","testee","testeeKeys","patternKeys","evalOptional","evalAsterisk","$f360cb19a7470d55$export$1690027cb4ee275f","$f360cb19a7470d55$var$IntentSubscriptionRegistry","$f360cb19a7470d55$var$IntentSubscription","_heartbeatInterval","_staleClientUnregisterDelay","installHeartbeatMonitor","deprecations","legacyIntentSubscriptionApi","legacyRequestResponseSubscriptionApi","installLegacyClientIntentSubscription","_heartbeat","activeTask","lastTime","emit","emitWhenIdle","targetTime","logStaleClientWarning","unregisterClient","markStaleAndQueueForRemoval","_staleClientUnregisterTimer","stale","dispose","legacyClientSubscription","$f360cb19a7470d55$var$Predicates","Predicates","not","alwaysTrue","$f360cb19a7470d55$var$MessageBroker","_clientRegistry","_topicSubscriptionRegistry","_intentSubscriptionRegistry","_retainedMessageStore","_retainedIntentStore","_applicationRegistry","_manifestRegistry","_clientMessage$","TopicSubscribe","IntentSubscribe","IntentUnsubscribe","whenRunlevel","Two","$f360cb19a7470d55$var$checkOriginTrusted","$f360cb19a7470d55$var$catchErrorAndRetry","installClientConnectListener","installClientDisconnectListener","installMessageDispatcher","installTopicSubscribeListener","installTopicUnsubscribeListener","installTopicSubscriberCountObserver","sendRetainedMessageOnSubscribe","installIntentDispatcher","installIntentSubscribeListener","installIntentUnsubscribeListener","sendRetainedIntentOnSubscribe","deleteRetainedIntentOnCapabilityUnregister","_messagePublisher","createMessagePublisher","_intentPublisher","createIntentPublisher","One","eventSource","clientAppName","clientMessageTarget","$f360cb19a7470d55$var$MessageTarget","warning","$f360cb19a7470d55$var$sendTopicMessage","warning1","warning2","currentClient","getByWindow","registerClient","$f360cb19a7470d55$var$getSendingClient","retain","$f360cb19a7470d55$var$isRequest","$f360cb19a7470d55$var$sendDeliveryStatusSuccess","requestorReplySubscription","subscribeForRepliesIfRequest","storeMessageIfRetained","error1","$f360cb19a7470d55$var$sendDeliveryStatusError","hasIntention","error2","resolveCapabilitiesByIntent","assign","storeIntentIfRetained","error4","metadata","error3","flat","retainedMessage","capabilityUnregister$","subscribers","$f360cb19a7470d55$var$sendIntentMessage","sender","capabilityId","getByClientId","caught","$f360cb19a7470d55$var$CONTEXT_LOOKUP_OPTIONS","$f360cb19a7470d55$var$Contexts","Contexts","contextValueLookupTopic","contextTreeNamesLookupTopic","contextTreeChangeTopic","newContextValueLookupRequest","MicrofrontendToOutlet","encodeURIComponent","newContextTreeNamesLookupRequest","names","newContextTreeObserveRequest","RootContextSubscribeEvent","$f360cb19a7470d55$var$RouterOutletContextProvider","iframe","_entries$","_entryChange$","_outletDisconnect$","_microfrontendRequest$","contentWindow","entries$","onOutletMount","installContextValueLookupListener","installContextTreeNamesLookupListener","installContextTreeObserveListener","onOutletUnmount","lookupRequest","encodedName","decodeURIComponent","collect","collectedValues","collectedNames","observeRequest","$f360cb19a7470d55$export$b84d9f3cc1de7d1d","currNavigation","prevNavigation","patchedUrl","patchUrl","pushStateToSessionHistoryStack","location","currUrl","prevUrl","prevURL","currURL","protocol","search","patchedURL","searchParams","$f360cb19a7470d55$var$Keystroke","eventType","modifiers","parts","control","alt","toLowerCase","withFlags","$f360cb19a7470d55$var$escapeKeyboardEventKey","ctrlKey","shiftKey","altKey","metaKey","keystroke","flagsStr","flag","flagName","flagValue","preventDefault","$f360cb19a7470d55$var$parseFlags","$f360cb19a7470d55$var$PUSH_STATE_TO_SESSION_HISTORY_STACK_MESSAGE_HEADER","$f360cb19a7470d55$var$ELEMENT_NAME","$f360cb19a7470d55$var$ATTR_NAME","$f360cb19a7470d55$var$ATTR_SCROLLABLE","$f360cb19a7470d55$var$ATTR_KEYSTROKES","$f360cb19a7470d55$var$HTML_TEMPLATE","$f360cb19a7470d55$export$40346ab29ce71372","HTMLElement","_disconnect$","_uid","_empty$","_outletName$","$f360cb19a7470d55$export$61656ab94335dbc0","_shadowRoot","attachShadow","mode","innerHTML","trim","_iframe","querySelector","_contextProvider","empty$","setAttribute","removeAttribute","getAttribute","scrollable","keystrokes","$f360cb19a7470d55$var$KeystrokesAttributeUtil","setContextValue","removeContextValue","contextValues$","resetPreferredSize","$f360cb19a7470d55$export$5747e8c66ba169f9","preferredSizeTopic","preferredSize","minWidth","style","width","maxWidth","minHeight","height","maxHeight","installOutletContext","outletContext","uid","$f360cb19a7470d55$export$ff8ad477982f6328","installOutletUrlListener","outlet","outletNavigationTopic","urlTopic","navigateMessage","$f360cb19a7470d55$var$outletNavigate$","navigation","hasPrev","dispatchEvent","CustomEvent","detail","installPreferredSizeListener","setProperty","installKeyboardEventDispatcher","keyboardEventTopic","KeyboardEvent","installFocusWithinEventDispatcher","focusWithinOutletTopic","focusWithin","taking","bubbles","cancelable","installHostElementDecorator","host","classList","connectedCallback","disconnectedCallback","attributeChangedCallback","oldValue","newValue","$f360cb19a7470d55$var$KEYSTROKE_CONTEXT_NAME_PREFIX","fromString","keystrokeStr","customElements","define","whenDefined","observedAttributes","RouterOutlets","KeystrokesAttributeUtil","outletName","outletUid","attributeValue","$f360cb19a7470d55$export$a8e56bb192edf201","_contextTreeChange$","_whenContextTreeChangeListenerInstalled","installContextTreeChangeListener","changeEvent","switchMap","lookupContextValue$","lookup","isPresent","names$","lookupContextNames$","contextValueLookupRequest","$f360cb19a7470d55$var$whenSubscribedToReplyTopic","contextNamesLookupRequest","listener","contextObserveRequest","$f360cb19a7470d55$export$fc96cab2c66d5054","path","relativeTo","hash","$f360cb19a7470d55$export$7fb6e18939c89ffa","navigate","navigateByIntent","navigateByUrl","resolveContextualOutlet","outletUrlTopic","navigationUrl","computeNavigationUrl","contextualOutlet","Microfrontend","navigate$","request$","$f360cb19a7470d55$var$ROUTING_CONTEXT_MESSAGE_HEADER","$f360cb19a7470d55$var$ROUTING_CONTEXT_OUTLET","urlPattern","substituteNamedParameters","href","paramName","delimiter","$f360cb19a7470d55$export$9b078e20c2505aad","focusWithin$","$f360cb19a7470d55$var$FocusInEventDispatcher","makeWindowFocusable","dispatchDocumentFocusInEvent","reportFocusWithinEventToParentOutlet","relatedTarget","publishTo","document","outline","$f360cb19a7470d55$var$FocusTracker","_focusOwner$","monitorFocusInEvents","replyToIsFocusWithinRequests","focusOwner","isFocusWithin","getParentClient","$f360cb19a7470d55$export$a0e8060499828631","_fromDimensionElementChange$","_preferredSizePublisher","$f360cb19a7470d55$var$PreferredSizePublisher","setPreferredSize","fromDimension","dimension","_preferredSize$","$f360cb19a7470d55$var$MouseMoveEventDispatcher","_dispatcherId","produceSynthEvents","consumeSynthEvents","buttons","$f360cb19a7470d55$var$PRIMARY_MOUSE_BUTTON","DISPATCHER_ID_HEADER","$f360cb19a7470d55$var$MOUSEMOVE_EVENT_TOPIC","screenX","screenY","sciMouseEvent","Event","$f360cb19a7470d55$var$MouseUpEventDispatcher","$f360cb19a7470d55$var$DISPATCHER_ID_HEADER","$f360cb19a7470d55$var$MOUSEUP_EVENT_TOPIC","$f360cb19a7470d55$var$KeyboardEventDispatcher","_keyboardEvents$","installKeyboardEventListener","installKeystrokeListener","contextNames","contextName","keystrokeContextName","observeKeyboardEvent$","keyboardEvents","onKeyboardEventToPropagate","outletIdentity","eventInit","collectedFlags","switchToKeyboardEvents","fromEvent","keystrokeEvent","$f360cb19a7470d55$var$ManifestObjectStore","_objectById","_objectsByType","_objectsByApplication","_add$","_remove$","objectsToRemove","find","_remove","qualifierPredicate","filterByType","change$","add$","remove$","objects","deleted","objectId","$f360cb19a7470d55$export$6b68619c82449d52","_capabilityStore","_intentionStore","capabilityRegister$","installCapabilityRegisterRequestHandler","installCapabilityUnregisterRequestHandler","installIntentionRegisterRequestHandler","installIntentionUnregisterRequestHandler","installCapabilitiesLookupRequestHandler","installIntentionsLookupRequestHandler","installVersionLookupHandler","capabilityQualifier","isApplicationQualifiedForCapability","intentionQualifier","isCapabilityPublic","private","hasIntentionForCapability","capabilityToRegister","$f360cb19a7470d55$var$interceptCapability","$f360cb19a7470d55$var$coerceCapabilityParamDefinitions","requiredParams","optionalParams","unregisterCapabilities","intentionToRegister","unregisterIntention","$f360cb19a7470d55$var$ManifestRegistryTopics","RegisterCapability","UnregisterCapabilities","capabilityFilter","RegisterIntention","$f360cb19a7470d55$var$assertIntentionRegisterApiEnabled","intentionId","UnregisterIntentions","intentFilter","LookupCapabilities","lookupFilter","registryChange$","finder$","LookupIntentions","onMessage","platformVersion","clientRegister$","platformVersion$","clients","getByApplication","ManifestRegistryTopics","required","migration","param","validSubstitutes","deprecated","useInstead","$f360cb19a7470d55$var$assertCapabilityParamDefinitions","$f360cb19a7470d55$export$aafa7a6a222a9fad","applications$","$f360cb19a7470d55$var$mapToApplication","applications","lookupApplications$","lookupCapabilities$","lookupIntentions$","unregisterIntentions","$f360cb19a7470d55$var$ActivatorInstaller","activators","activatorsGroupedByApp","skipInvalidActivators","activator","activatorReadyPromises","appActivators","waitForActivatorsToSignalReady","sameAppActivators","primaryActivator","mountActivator","t0","readinessPromises","readinessTopics","readinessTopic","onReadinessTimeout","primary","routerOutlet","createElement","display","position","appendChild","whenState","removeChild","$f360cb19a7470d55$var$MessageHandler","_callback","_messageClient","handleMessage","consumeMessage","platformStopping$","state$","Stopping","observableStatus","resolved","replyHeaders","_brokerGateway","setBodyIfDefined","onIntent","$f360cb19a7470d55$var$assertTopic","allowWildcardSegments","$f360cb19a7470d55$var$setBodyIfDefined","$f360cb19a7470d55$var$provideHostManifestUrl","createObjectURL","Blob","revokeObjectURL","$f360cb19a7470d55$var$serveHostManifest","$f360cb19a7470d55$export$61c6825dcf81208b","$f360cb19a7470d55$export$33b9eb3dc0ea6d8","onUnload","once","_clientsById","_clientsByWindow","staleClient","$f360cb19a7470d55$var$MicrofrontendIntentNavigator","consumeMicrofrontendIntent","microfrontendCapability","microfrontendPath","resolveTargetOutlet","$f360cb19a7470d55$var$ParamMatcher","definitions","_requiredParamDefs","_optionalParamDefs","_deprecatedParamDefs","paramDef","parameters","matcherResult","missingParams","unexpectedParams","deprecatedParams","deprecation","$f360cb19a7470d55$var$IntentParamValidator","paramMatcherResult","paramsMatcherResult","intentStringified","$f360cb19a7470d55$var$toParamValidationError","deprecatedParam","$f360cb19a7470d55$var$toDeprecatedParamWarning","$f360cb19a7470d55$var$version","$f360cb19a7470d55$export$5cce370cfaa52f9e","startPlatform","hostConfig","installHostStartupProgressMonitor","top","$f360cb19a7470d55$var$BeanDestroyOrders","CORE","BROKER","$f360cb19a7470d55$var$provideMessageClient","$f360cb19a7470d55$var$provideIntentClient","$f360cb19a7470d55$var$registerBrokerGateway","connectRunlevel","Zero","Three","exclude","installClientStartupProgressMonitor","brokerGateway","enterState","startupFn","Starting","start","Started","_state$","newState","startupProgress$","_startupProgress$","startupProgressMonitor","manifestLoadProgressMonitor","activatorLoadProgressMonitor","connect","MESSAGING","BeanDestroyOrders","MAX_SAFE_INTEGER","refs","MicrofrontendPlatform","MessageClient","IntentClient","OutletRouter","ManifestService","Beans","MessageInterceptor","IntentInterceptor","TopicMatcher","QualifierMatcher","UUID"],"version":3,"file":"refs.js.map"}